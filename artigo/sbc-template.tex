\documentclass[12pt]{article}

\usepackage{sbc-template}

\usepackage{graphicx,url}

%\usepackage[brazil]{babel}   
\usepackage[latin1]{inputenc}  

     
\sloppy

\title{Aplicação de \textit{Domain-Driven Design} no Gerenciamento de GRU de Cronotacógrafo no Inmetro/RS}

\author{Tiago O. de Farias\inst{1}}


\address{UniRitter Laureate International Universities\\
  Rua Orfanatrófio, 555 - Alto Teresópolis - 90840-440 - Porto Alegre - RS - Brasil
  \email{tiago.farias.poa@gmail.com}
}

\begin{document} 

\maketitle

\begin{abstract}
Since 1997, when it was instituted the Brazilian Traffic Code, cargo vehicles with a gross weight exceeding 4536 kilograms and passengers with more than 10 seats must have tachograph. From 2009, the instruments should also be checked periodically by Inmetro (National Institute of Metrology, Quality and Technology), which increases the reliability of the measurements. All the tachograph verification process is managed through a web system, this system is used a framework that provides an architecture based on the MVC architecture. This paper presents a proposal for restructuring the current architecture according to the techniques of \textit {Domain-Driven Design}. Throughout this work is done a study on the concept of Domain-driven design and how it helps in the field of identification, as well as the delegation of the architectural point of view responsibilities, beyond the case study of the organization of GRU module tachograph.
\end{abstract}
     
\begin{resumo} 
Desde 1997, quando foi instituído o Código de Trânsito Brasileiro, veículos de carga com peso bruto superior a 4.536 kg e de passageiros com mais de 10 lugares devem possuir cronotacógrafo. A partir de 2009, os instrumentos também devem ser verificados periodicamente pelo Inmetro (Instituto Nacional de Metrologia, Qualidade e Tecnologia), o que aumenta a confiabilidade das medições. Todo o processo de verificação do cronotacógrafo é gerenciado através de um sistema web, neste sistema é utilizado um framework que oferece uma arquitetura baseada na arquitetura MVC. Este trabalho apresenta uma proposta de reestruturação da arquitetura atual segundo as técnicas de \textit{Domain-Driven Design}. Ao longo deste trabalho é feito um estudo sobre o conceito de \textit{Domain-Driven design} e como ele ajuda na identificação do domínio, bem como a delegação de responsabilidades do ponto de vista arquitetural, além do estudo de caso da nova organização do módulo de GRU de Cronotacógrafo.
\end{resumo}


\section{Introdução}

Cronotacógrafo é o instrumento ou conjunto de instrumentos destinado a indicar e registrar, de forma simultânea, inalterável e instantânea, a velocidade e a distância percorrida pelo veículo, em função do tempo decorrido, assim como os parâmetros relacionados com o condutor do veículo, tais como: o tempo de trabalho e os tempos de parada e de direção \cite{oquecronotacografo} e o Brasil está entre os países que tornaram o uso do cronotacógrafo obrigatório em ônibus e caminhões, pois registra o histórico das velocidades, distâncias percorridas e tempos de movimento e paradas do veículo \cite{oquecronotacografo}.

O processo de verificação do Cronotacógrafo tem basicamente três grandes etapas: emissão e pagamento da GRU (Guia de Recolhimento da União), realização da selagem e realização do ensaio metrológico.
As informações do processo de verificação de Cronotacógrafo são gerenciadas através de um sistema web que inicialmente foi concebido para simples emissão de GRU onde o proprietário do veículo acessava o site do cronotaógrafo preenchia os dados pessoais e dados sobre o veículo, emitia e pagava GRU, após se dirigia à um posto de selagem para dar inicio ao processo, ao finalizar a selagem e dentro de um período determinado deve procurar um posto de ensaio para realizar o ensaio metrológico e assim recebia o certificado do Inmetro que garante que o instrumento juntamente com o veículo atendem aos padrões vigentes sob penalização de ser autuado pela polícia federal. 

A cada etapa do processo de selagem e de ensaio o posto deve registrar no site do Cronotacógrafo as informações sobre os serviços realizados.

O sistema web de gerenciamento de verificação do cronotacógrafo existe há pelo menos oito anos e atende à todos os estados da federação. Foi desenvolvido em PHP com o \textit{framework} \textit{CakePHP}. Aplicações bem escritas em \textit{CakePHP} seguem o \textit{design pattern} MVC (\textit{Model-View-Controller}) \cite{cakephpmvc}. O \textit{framework} permitite uma programação orientada a objetos, mas é muito comum, por culpa do desenvolvedor ver código escrito de forma estruturada, implementação de regras de negócio dentro da camada \textit{view} e a mesma regra duplicada ou triplicada dentro de \textit{controllers}, classes que tem o papel apenas de repositório de funções e que não tem se quer relação com o propósito da classe. Algumas classes e métodos só fazem sentido para o desenvolvedor que a criou. As classes são altamente acopladas, e por isso alterações mesmo que pequenas se não bem testadas causam um grande defeito que se propaga em outros módulos do sistema. Algumas informações para serem utilizadas no site do Cronotacógrafo tem como origem o SGI (Sistema de Gestão Integrada) que possui banco de dados próprio, e alguns termos que tem o mesmo significado sofreram alteração de nome no banco de dados do Cronotacógrafo, causando mais dificuldades quando os desenvolvedores tentam fazer os dois sistemas se comunicarem.

No dia 01 de janeiro de 2016 houve uma grande mudança no processo de emissão de GRU, atualmente os postos de selagem e de ensaio (PAC) emitem a GRU, e  semelhante a um plano pré-pago de celular, o posto compra créditos para cada GRU emitida, cada crédito permite ao posto acessar o site do Cronotacógrafo e registrar os dados do serviço realizado, seja serviço de selagem ou de ensaio metrológico.

Essa alteração afetou diretamente a codificação no sistema, o código e a arquitetura que antes já eram complicados, ficou maior e mais complexo, pois as regras antigas deveriam ser mantidas sem alteração, e o sistema teve que comportar muitas regras novas, os desenvolvedores tiveram que adquirir conhecimento das novas regras de negócio e que algumas vezes ao serem implementadas se confundiam com regras antigas.

O objetivo deste artigo é fornecer uma estrutura organizada, altamente reutilizável e produtiva para o módulo de GRU, pois todas as etapas de verificação dependem da GRU, e utilizando os conceitos de \textit{Domain-Driven Design} que segundo \cite{Evans:2003:DDT:861502} reúne um conjunto de conceitos, princípios e técnicas cujo foco esta no domínio e na lógica do domínio para que o ciclo de vida da aplicação possa ser prolongado.

Como roteiro, este artigo encontra-se estruturado da seguinte maneira. Na seção 2.2 é descrito o significa e importância da linguagem ubíquia. A seção 2.3 apresenta a importância da criação de um mapa de contexto. Na seção 2.4 descreve a importância dos blocos de construção e seus elementos para auxiliar na modelagem do modelo do domínio. A seção 2.5 descreve o que são entidades. A seção 2.6 descreve as características de um objeto de valor. Na seção 2.7 é apresentado o conceito de serviços. Na seção 2.8 é descrito como agrupar objetos de valor e entidades. A seção 2.9 descreve como trabalhar com objetos complexos através de fábricas. Na seção 2.10 é descrito como utilizar repositórios para acessar dados externos. Na seção 2.11 é apresentado o conceito de módulos. Na seção 3 é descrito trabalhos relacionados ao \textit{Domain-Driven design} e as soluções propostas. A seção 4 descreve a solução referente ao problema apresentado neste artigo utilizando \textit{Domain-Driven design}.

\section{Referencial Teórico} \label{sec:firstpage}

\subsection{Domain-Driven Design}
\textit{Domain-Driven Design} é uma abordagem de desenvolvimento de software desenhado para gerir a complexa e grande escala de produtos de software \cite{Evans:2003:DDT:861502}.

A melhor maneira de justificar uma tecnologia ou técnica é fornecer valor ao negócio \cite{DDDinPHP}.

Segundo \cite{Evans:2003:DDT:861502} é um processo que alinha o código do desenvolvedor com o problema real,  um conjunto de técnicas de desenvolvimento de software, usadas principalmente em projetos complexos que provê conceitos e regras para ajudar no cilco do desenvolvimento de software, essas técnicas também tem o objetivo de ajudar clientes, gestores e todas as pessoas envolvidas no processo de desenvolvimento. Seguir a filosofia DDD dará aos desenvolvedores o conhecimento e as habilidades que eles precisam para enfrentar sistemas de negócios grandes e complexos de maneira eficaz \cite{millett2015patterns}.

DDD utiliza o princípio da separação de conceitos. Este princípio é usado para separar a aplicação do modelo em um modelo de domínio, que consiste de domínio relacionado com a funcionalidade, e domínio independente de funcionalidade, que é representado por diferentes serviços que facilitam a usabilidade do modelo de domínio \cite{essay58268}.

A solução está em resolver o problema do domínio, focado no domínio do problema, falar a mesma linguagem dos especialistas do domínio. Pode ser aplicado em qualquer projeto desde que não torne complicado o desenvolvimento, algumas vezes o desenvolvimento não é tão complexo que necessite do DDD. O foco está na criação de uma linguagem comum conhecida como a linguagem ubíqua para descrever de forma eficiente e eficaz um domínio de problemas \cite{millett2015patterns}. 
De acordo com o conceito do DDD o mais importante em um software não é somente o código, não é somente a arquitetura, tampouco a tecnologia sobre o qual foi desenvolvido, mas sim o problema que o mesmo se propõe a resolver, a regra de negócio. Ela é a razão do software existir. 
DDD é sobre o desenvolvimento de conhecimento em torno do negócio e de utilizar a tecnologia para fornecer valor \cite{DDDinPHP}.

Ainda segundo \cite{DDDinPHP} \textit{Domain-Driven design} não é uma bala de prata, como tudo em software, depende do contexto. Como regra geral, deve ser utilizado para simplificar o domínio, nunca para adicionar mais complexidade.
DDD é mais do que tecnologia ou metodologia, ou até mesmo um \textit{framework}. É uma maneira de pensar, é um conjunto de prioridades que visa acelerar projetos de software que têm de lidar com domínios complicados \cite{vernon2013implementing}.

Pensar nos problemas de forma técnica não é ruim, o único problema é que, às vezes, pensar menos tecnicamente é melhor. A fim pensar em comportamentos de objetos precisa-se pensar na Linguagem universal em primeiro lugar \cite{DDDinPHP}.

De forma geral \cite{DDDinPHP} afirma que os benefícios com a utilização do DDD são:
\begin{itemize}
  \item Alinhamento com o modelo do domínio
  \item Especialistas do domínio contribuem para o \textit{design} do software
  \item Melhor experiência do usuário
  \item Limites claros
  \item Melhor organização da arquitetura
  \item Modelagem contínua de forma ágil
\end{itemize}

\subsection{Linguagem Ubíqua}

A linguagem ubíqua é uma linguagem de equipe compartilhada. Ela é compartilhada por especialistas em domínio e desenvolvedores. Na verdade, ela é compartilhada por todos na equipe do projeto. Não importa o seu papel na equipe, uma vez que você está na equipe que usa a linguagem ubíqua do projeto \cite{vernon2013implementing}.
Esta linguagem é composta de documentos, diagramas de modelo, e mesmo código. Se um termo está ausente no projeto, é uma oportunidade para melhorar o modelo incluindo-a \cite{Evans:2003:DDT:861502}.
A linguagem ubíqua exige que os desenvolvedores trabalhem duro para entender o domínio do problema, mas também exige que a empresa trabalhe duro para ser precisa em suas nomenclaturas e descrição desses conceitos \cite{haywood2009domain}. Se uma ideia não pode ser expressa usando este grupo de conceitos, o modelo deve ser extendido para procurar e remover as ambiguidades e as inconsistências \cite{haywood2009domain}.

Especialistas do domínio podem se comunicar com os times de desenvolvedores de sistema sobre as regras do domínio através da linguagem ubíqua que também representa a especificação formal do sistema \cite{vernon2013implementing}. 

Para \cite{millett2015patterns} se a equipe de desenvolvimento não se envolver com especialistas de domínio para compreender plenamente a linguagem e usá-la no âmbito da implementação de código, muito do seu benefício é perdido. Para alcançar uma melhor compreensão, as equipes precisam se comunicar de forma eficaz. É a criação da linguagem onipresente que permite uma compreensão mais profunda do que vai permanecer após o código ser reescrito e substituído \cite{millett2015patterns}. Ainda segundo \cite{millett2015patterns} a utilidade da criação de uma linguagem ubíqua tem um impacto que vai além da aplicação para o produto em desenvolvimento. Ela ajuda a definir explicitamente o que a empresa faz, revela uma compreensão mais profunda do processo e a lógica do negócio, e melhora a comunicação empresarial. Enquanto as equipes estão implementando o modelo em código, novos conceitos podem aparecer. Estes termos descobertos precisam ser levados de volta para os especialistas de domínio para validação e esclarecimentos \cite{millett2015patterns}.

Um projeto enfrenta sérios problemas quando os membros da equipe não compartilham uma linguagem comum para discutir o domínio \cite{avram2007domain}.
Ele ainda defende usar um modelo como espinha dorsal de uma línguagem. Solicitando que a equipe deve usar a linguagem de forma consistente em todas as comunicações e
também no código.

\subsection{Mapa de Contexto}

Além de demonstrar como o modelo se relaciona dentro de outros contextos, permite também delimitar a aplicabilidade de um modelo do domínio para que a equipe de desenvolvimento tenha um conhecimento mais claro e que possa ser compatilhado de forma eficiente \cite{Evans:2003:DDT:861502}.

Segundo é de vital importância para proteger a integridade de cada modelo  definir claramente os limites da sua responsabilidade no código \cite{millett2015patterns}.

Ainda segundo \cite{Evans:2003:DDT:861502}, o mapa de contexto é uma ferramenta de modelagem muito importante no \textit{Domain-Driven Design} e quando se pensa em vários subsistemas de uma aplicação como \textit{Bounded Contexts}, se perde a visão geral do negócio como um todo, e que é inevitável que os vários delimitadores de contextos de uma aplicação serão necessários para comunicar ou compartilhar dados entre eles.

Um mapa de contexto é uma visão geral da aplicação como um todo. Cada contexto delimitado (\textit{Bounded Context}) se encaixa dentro de um mapa de contexto para mostrar como eles devem se comunicar entre si e como os dados devem ser compartilhados.


Para \cite{millett2015patterns}, \textit{Bounded Contexts} permitem que se possa dividir um problema grande e complexo em problemas de menor complexidade e assim pode-se focar nas particularidades de forma individual sem interferências externas, o que permite ainda criar um linguagem em torno do problema específico que todos tem como definicção clara de cada termo relevante.

Normalmente em aplicações do meio web tem diferentes definições em contextos diferentes da aplicação. Dividindo a aplicação em contextos limitados, pode-se ter a certeza que as idéias, terminologias e conceitos da aplicação estarão plenamente entendidos \cite{millett2015patterns}.


%\subsection{Diagrama de Casos de Uso}
%É a especificação de uma seqûencia de interações entre um sistema e os agentes externos que utilizam esse sistema \cite{bezerra2006principios}.

%O diagrama de casos de uso procura, por meio de uma linguagem simples possibilitar a compreensão do comportamento externo do sistema por qualquer pessoa, tentanto apresentar o sistema através da perspectiva do usuário \cite{guedes2009uml}.

%Ainda segundo {\cite{guedes2009uml} o diagrama de casos de uso sendo uma linguagem informal, apresenta uma visão geral do comportamento do sistema a ser desenvolvido, que pode e deve ser apresentado durante as reuniões inicias com os clientes com uma forma de ilustrar o comportamento do sistema, facilitando a compreenção dos usuários e auxiliando na identificação de possíveis falhas de especificação, verificando se os requisitos do sistema foram bem compreendidos.

%Sendo um cenário uma descrição de umas das maneiras pelas quais um caso de uso pode ser realizado, então um cenário é chamado também de instância de caso de uso  \cite{bezerra2006principios}. E segundo \cite{guedes2009uml} atores e casos de uso são itens principais do diagrama de casos de uso. Atores represenam os papéis desempenhados pelos diversos usuários que poderão utilizar os serviços do sistema. Um ator também pode representar um hardware ou ouro software que interaja com o sistema, pode ser qualquer elemento externo que interaja com o software. \cite{guedes2009uml} Segundo \cite{bezerra2006principios} Um ator pode estar envolvido em vários casos de uso, e para cada caso de uso pode ter responsabilidades diferentes, o mais importante é que o nome dado a esse ator deve lembrar o seu papel em vez de lembrar o que o representa.

%Para \cite{guedes2009uml} um caso de uso normalmente é documentado de maneira informal, mas o engenheiro de software se considerar necessário, pode inserir detalhes de implementação em uma linguagem mais técnica e que a UML (Linguagem de Modelagem Unificada) não define um formato específico de documentação para casos de uso.

\subsection{Blocos de Construção}

A finalidade desses padrões é apresentar alguns dos principais elementos da modelagem de objeto e \textit{design} de software do ponto de vista do \textit{design} orientado por domínio \cite{avram2007domain}.

\begin{figure}[ht]
\centering
\includegraphics[width=.9\textwidth]{imagens/ddd-building-blocks.png}
\caption{Padrões para auxiliar a modelagem de objetos}
\label{fig:exampleFig1}
\end{figure}

A figura 1 representa os \textit{patterns} que ajudam na modelagem do  \textit{domain model} com o objetivo de apresentar alguns elementos-chave para modelagem de objetos e software do ponto de vista do DDD e que segundo \cite{Evans:2003:DDT:861502}, um desafio para os desenvolvedores é de criar um modelo que reflita os conceitos do domínio de forma clara que também seja útil para o desenvolvimento.

Segundo \cite{avram2007domain} existe uma necessidade de se ter um conhecimento aprimorado do domínio e que a camada modelo, tem como principal objetivo organizar todas as informações obtidas através dos especialistas.

Os efeitos destes padrões é apresentar alguns dos elementos-chave para modelagem de objetos e  software do ponto de vista no DDD. Neste caso, o domínio sendo modelado é o próprio DDD \cite{Evans:2003:DDT:861502}.

A criação de programas que podem lidar com chamadas de tarefas muito complexas para a separação de responsabilidades, permitindo a concentração em diferentes partes do projeto isoladamente. Ao mesmo tempo, o complexo de interações dentro do sistema deve ser mantido apesar da separação \cite{Evans:2003:DDT:861502}.

\begin{figure}[ht]
\centering
\includegraphics[width=.9\textwidth]{imagens/layered-architecture.png}
\caption{separação de responsabilidades}
\label{fig:exampleFig1}
\end{figure}

Desenvolver um projeto dentro de cada camada que seja coesa e que depende apenas de níveis abaixo. Siga os padrões de padrões de arquitetura para fornecer acoplamento frouxo para as camadas acima. Concentrar todo o código relacionadas com o modelo de domínio em uma camada e isolar a partir da interface do usuário, aplicativo e código de infra-estrutura  \cite{avram2007domain}.
Normalmente encontra-se no desenvolvimento códigos de lógica comercial incorporado no comportamento de elementos na interface do usuário juntando e adicionando os scripts de acesso  dados e até de retorno de informações do objeto. Isso acontece porque é a maneira mais fácil que o desenvolvedor encontra para fazer com que as funcionalidades apresentem resultados, no curto prazo. \cite{vernon2013implementing}

Observa-se que neste contexto fala-se a respeito de uma lógica comercial incorporada em elementos, ou seja não há uma separação de responsabilidade entre as camadas. Desse modo pode-se chamar de camadas, aquilo que tem uma separação de responsabilidades entre elas  \cite{Evans:2003:DDT:861502}.

A figura 2 representa a separação em camadas da arquitetura, que segundo  \cite{Evans:2003:DDT:861502} e \cite{vernon2013implementing} para que seja realmente funcional deve seguir algumas premissas: completamente isolada uma da outra, a comunicação entre elas deve ocorrer através de interfaces e a camada inferior não deve executar operações na camada superior. Ainda segundo \cite{vernon2013implementing} a arquitetura de camandas não se resume apenas na reusabilidade de componentes ou numa arquitetura que evolui juntamente com a aplicação mas no fato que ela oforece maior manutenibilidade.

Para \cite{Evans:2003:DDT:861502} a arquitetura em camadas do sistema deve ser capaz de substituir uma camada que está no nível superior e colocar uma camada de outro tipo de aplicação e ela deve funcionar, isso quer dizer, se há uma aplicação WEB e adiciona uma aplicação Mobile, então todo o resto continua funcionando. Isso é possível por conta dessa separação, onde pode-se citar: Camada de acesso a dados, Camada de lógica de negócio, entre outras, sem a necessidade de recodificar tudo que já foi definido ou modelado.
	No entanto, quando o código é relacionado ao domínio e misturado com as outras camadas, torna-se extremamente difícil de ver e pensar \cite{Evans:2003:DDT:861502}.  Mudanças superficiais na interface do usuário podem realmente mudar a lógica comercial. Para alterar uma regra de negócio pode exigir um rastreamento na Interface com Usuário, no código de banco de dados ou outros elementos do programa. Para evitar esse tipo de problema, deve-se isolar todo o código responsável por controlar o domínio de maneira que ele tenha uma única responsabilidade: implementar regras de negócio  \cite{Evans:2003:DDT:861502}.

	No DDD a arquitetura proposta muda um pouco do MVC, embora conceitualmente nas duas divisões eles sejam bastante parecidas, algumas questões técnicas fazem com que elas sejam diferentes \cite{DDDinPHP}.
	
As camadas da arquitetura são descritas por \cite{Evans:2003:DDT:861502}:

\textit{User Interface}: Responsável pela interação com o usuário, seja interpretando comandos ou exibindo informação para o mesmo. Tudo daquilo que o usuário interage diretamente, elementos visuais.

\textit{Application}: Coordena as atividades da aplicação, sua responsabilidade é de trabalhar com os objetos de domínio, e não mantém estado de domino, ou seja, não contém regras de negócio. Pode por exemplo manter um estado de determinada transação. Porém ela possui uma ligação muito forte com a camada de domínio (\textit{Domain}).

\textit{Domain}: Camada que concentra toda a regra de negócio da aplicação. para \cite{Evans:2003:DDT:861502}, esta camada é o coração de um software de negócios, ou seja DDD é utilizado em softwares de negócios com regras complexas.

\textit{Infrastructure}: É a camada de mais baixo nível, responsável por interações com infraestrutura técnica, a esta camada são colocadas as tarefas como interface com o sistemas de e-mail, banco de dados, sistemas de arquivos e outros objetos de infra-estrutura, ou seja, dar suporte tecnológico para as demais camadas.
    
\begin{figure}[ht]
\centering
\includegraphics[width=.9\textwidth]{imagens/mvc.jpeg}
\caption{arquitetura MVC (Model-View-Controller)}
\label{fig:exampleFig1}
\end{figure}
    
    Model View Controller (MVC) é o \textit{design} pattern mais conhecido de todos. Seus conceitos remontam à plataforma Smaltalk na década de 1970. Basicamente uma aplicação que segue o pattern Model View Controller é dividida em três camadas. As letras que compõem o nome deste pattern representam cada um desses aspectos \cite{dall2015php}.

\subsection{Entidades}
Muitos objetos não são fundamentalmente definidos por seus atributos, mas sim por uma linha de continuidade e identidade \cite{Evans:2003:DDT:861502}.
Um objeto deve ser distinguido por sua identidade, ao invés de seus atributos. Esse objeto, que é definido por sua identidade, é chamado de entidade. O modelo deve definir o que significa ser a mesma coisa. Suas identidades devem ser definidas de modo que possam ser efetivamente controladas. 
Normalmente existem 4 maneiras de definir a identidade de uma entidade: Um cliente fornece a identidade, o próprio aplicativo fornece uma identidade, o mecanismo de persistência fornece a identidade ou outro contexto limitado fornece uma identidade \cite{DDDinPHP}.

Entidades têm considerações especiais de modelagem e arquitetura. Elas têm ciclos de vida que podem mudar sua forma e conteúdo, mas sua continuidade deve ser mantida. Suas definições de responsabilidades, atributos e associações devem girar em torno de quem elas são mais do que sobre os atributos que elas carregam \cite{vernon2013implementing}. Entidades são objetos importantes de um modelo de domínio, e elas deve ser considerada a partir do começo da modelagem processo. É também importante para determinar se um objeto precisa de ser uma entidade ou não. \cite{avram2007domain}

\subsection{Objetos de Valor}
Um objeto que representa um aspecto descritivo do domínio sem identidade conceitual é chamado de Objeto de Valor e entidades de implementação em software significa criar
identidade \cite{Evans:2003:DDT:861502}.

Segundo \cite{Evans:2003:DDT:861502} entender o \textit{pattern} \textit{Value Object} não é tão simples, já que na aplicabilidade exige abstração de orientação a objetos para identificar quando precisamos de um. Um ponto de partida é ter sempre em mente que objeto de valor é um objeto pequeno e que pode ser facilmente criado, e que não representa nenhuma entidade de domínio. Outro ponto é relacionado a igualdade, uma entidade de domínio seja na aplicação orientada a objetos ou no banco relacional, existe um modo de especificar que é único.
Um objeto de valor não deve ser considerado apenas uma coisa em seu domínio. Como um valor, é medido, quantificado, ou descreve um conceito no Domínio \cite{DDDinPHP}.

Em banco de dados utiliza-se chave primária (PK), para tal identificação. Objetos de valor podem existir inúmeros objetos iguais ao mesmo tempo. Algumas classes de característica VO são: Dinheiro, Data, Coordenadas e etc \cite{DDDinPHP}.

Quando um objeto de valor é do tipo imutável no projeto, os desenvolvedores são livres para tomar decisões sobre questões como a cópia e compartilhamento em uma base puramente técnica, com a certeza de que a aplicação não depende de determinadas instâncias dos objetos \cite{Evans:2003:DDT:861502}.
	
\subsection{Serviços}
Alguns conceitos do domínio não são naturais para modelar como objetos \cite{vernon2013implementing}. Forçar a funcionalidade de domínio necessário para ser da responsabilidade de uma entidade ou valor ou distorce a definição de um objeto baseado em modelo ou adiciona objetos artificiais sem sentido \cite{Evans:2003:DDT:861502}.

Serviços agem como interfaces para prover operações. Eles não possuem um estado interno, seu objetivo é simplesmente fornecer funcionalidades para o domínio sobre um conjunto de entidades ou objetos de valor \cite{avram2007domain}.

Declarando explicitamente um serviço, o conceito é encapsulado criando uma distinção clara no domínio. Desta forma evita-se criar a confusão de onde colocar essa funcionalidade, se em uma entidade ou objeto de valor.
Serviços de domínio não possuem qualquer tipo de estado por si só \cite{DDDinPHP}.

\subsection{Fábricas}
Segundo \cite{avram2007domain} a criação de um objeto pode ser uma grande operação em si, mas as operações de montagem complexas não se encaixam a responsabilidade dos objetos criados. 

No domínio, fábricas ajudam a criar objetos complexos e agregados e definir uma interface para criar um objeto, mas deixar a escolha do seu tipo na subclasse, a criação a ser definida em tempo de execução \cite{DDDinPHP}.

	Fábricas em DDD são as mesmas classes normalmente responsáveis pela criação de objetos complexos, onde é necessário esconder alguma implementação, onde cada operação deve ser atômica e se preocupar caso a criação do objeto falhe, minimizando a dependência e o acoplamento \cite{avram2007domain}.
Para manter o baixo acoplamento, o cliente faz uma solicitação por meio de uma factory (fábrica). A fábrica por sua vez cria o produto solicitado. Outra maneira de pensar é que a fábrica torna o produto independente de seu solicitante.\cite{vernon2013implementing}
	Fábricas podem criar \textit{Value Objects}, que produzem objetos prontos, no formato final, ou \textit{Entity factories} apenas para os atributos essenciais \cite{DDDinPHP}.
\subsection{Repositórios}
Um cliente precisa de um meio prático para obter referências e persistir objetos de domínio. Se a infra-estrutura torna mais fácil para fazer isso, os desenvolvedores do cliente pode adicionar associações mais traversable, atrapalhando o modelo \cite{Evans:2003:DDT:861502}. Por outro lado, eles pode-se usar consultas para puxar os dados exatos de que precisam a partir do banco de dados, ou para puxar alguns objetos específicos, em vez de navegar a partir de raízes de agregação \cite{Evans:2003:DDT:861502}.
	Muitas regras no \textit{domain model} acabam sendo colocadas nas consultas sql, consequentemente se perdendo da aplicação, os repositórios tentam fazer a transição entre o \textit{domain} e a camada de persistência.
	Repositórios podem representar algo muito próximo aos objetos guardados na camada de persistência ou mesmo retornar calculos, somatórias ou relatórios \cite{vernon2013implementing}.
	Pensando em DDD, o \textit{repository} é um padrão conceitual simples para encapsular soluções de SQL, mapeamento de dados (ORM, DAO, e etc), fábricas e trazer de volta o foco no modelo. Quando o desenvolvedor tiver construído uma consulta SQL, transmitindo essa consulta para um serviço de consultas da camada de infraestrutura, obtendo um \textit{ RecordSet} que extrai as informações e transmite para um construtor ou fábrica, o foco do modelo já não existe mais \cite{vernon2013implementing}.

Repositórios representam coleções, enquanto DAOs estão mais perto do banco de dados. Normalmente, um DAO conteria métodos CRUD para um objeto de domínio particular  \cite{avram2007domain}.
Coleções são importantes por serem uma forma de expressar um dos mais fundamentais tipos de variação na programação:  a variação de número [Beck, Kent. 2013].
	O padrão repositório representa todos objetos de um determinado tipo como sendo um conjunto conceitual. Ele age como uma coleção, exceto por ter recursos mais elaborados para consultas. Essa definição une um conjunto coeso de responsabilidades para fornecer acesso às raízes dos agregados desde o início do clico de vida até o seu final \cite{DDDinPHP}.
	
\subsection{Módulos}
Para aplicações complexas, o modelo tende a ficar muito grande, tornando-se difícil de ser compreendido como um todo \cite{DDDinPHP}. Por esse motivo, é preciso reorganizar o modelo em módulos. Existem várias formas de coesão entre elementos de um módulo. Os módulos são capítulos \cite{Evans:2003:DDT:861502}.
	Uma preocupação comum ao criar uma aplicação segundo o DDD, é onde é colocar o código, qual é a maneira recomendada para colocar o código na aplicação, onde colocar código de infra-estrutura? E o mais importante, como devem os diferentes conceitos dentro do modelo ser estruturados. Existe um padrão tático para isso: módulos \cite{DDDinPHP}. 
	
	Módulo é responsável pela representação de todos os fluxos de uma aplicação. Desde a sua criação até que ele seja entregue ao cliente. Além disso, é uma applicação independente  \cite{DDDinPHP}.

Dar aos módulos nomes que passam a fazer parte da linguagem ubíqua e seus nomes devem refletir uma visão sobre o domínio \cite{Evans:2003:DDT:861502}.

Módulos não separam o código mas separam o significado conceitual \cite{DDDinPHP}.

\section{Estado da Arte}

\subsection{Domain-driven design in action: designing an identity provider}

Nesta tese de mestrado, os princípios de \textit{Domain-Driven Design} são usados para modelar um problema de negócio do mundo real, um provedor de identidade extensível (PDI). O trabalho mostra que a aplicação de \textit{Domain-Driven Design} é uma boa abordagem para a modelagem de um domínio complexo.
O projeto do trabalho é desenvolvido na empresa Safewhere e tem como interessados além do autor do trabalho também o diretor técnico e o CEO da Safewhere.

O trabalho cita que no início, a empresa por ter pouco capital para investir, ainda tinha como prioridade máxima mostrar um produto real. Dessa forma não houve comprometimento com \textit{design} de software e modelagem. Desenvolvedores eram contratados, e cada um tinha seu próprio estilo de desenvolvimento e compreensção do domínio comercial.

E, que no inicio não parecia causar grandes problemas e a versão do produto foi entregue e totalmente funcional. Após o lançamento inicial a necessidade de novos recursos cresceu rapidamente. O produto estava funcionando bem, mas se tornou cada vez mais dificil adicionar novos recursos em funcionalidades existentes, como refatorar o código base. Apesar de orientações de codificação estabelecidas, havia algo faltando no processo de desenvolvimento. Uma das maneiras de como isso se manifesta em si foi que tínhamos várias classes na di entravarão um conjuntos com nomes semelhantes mas com significado desiguais. Foi também difícil explicar a arquitectura para novos membros da equipe, dado que o código não foi organizado de forma heterogênea.
Em retrospecto, o problema foi que claramente não tinha um modelo nem um idioma onipresente.

Para ter a certeza de ter conseguido fazer uma fácil manutenção e um modelo extensível o autor solicitou a alguns dos colegas para rever o modelo. Entrevistou cada pessoa para que avalia-se a qualidade do \textit{design} e os benefícios do DDD:

\begin{itemize}
  \item Resolve bem o problema do negócio.
  \item Representa uma linguagem ubíqua concisa e expressiva, o que torna mais fácil de discutir.
  \item É flexível e tem uma clara separação de responsabilidades entre as camdas, tornando fácil  				refatorar
  \item Conduz a um estável e maduro do produto final.
\end{itemize}
    
\subsection{Implications of Domain-driven Design in Complex Software Value Estimation and Maintenance using DSL Platform}

Neste artigo é apresentado e analisado a ferramenta DSL. Plataforma de DSL é um serviço que permite a concepção, criação e manutenção de aplicações de negócio. O objetivo deste artigo é analisar as implicações do uso do DDD através da plataforma DSL sobre vários aspectos importantes do gerenciamento de software.

O objetivo deste trabalho é investigar possíveis benefícios da adopção de \textit{Domain-Driven Design} no gerenciamento de software, com especial ênfase na fase de manutenção durante a produção de ativos de software. Inevitavelmente estas considerações irá reflectir sobre o valor do ativo de software e assim uma abordagem validada estimatida de ativos de software é chamado para implementar as principais características do objeto. Usando \textit{Domain-Driven Design} pode ser utilizado para criar uma plataforma unificada para de desenvolvimento e evolução de sistemas de software complexos.

A Plataforma DSL permite a a automação do processo de desenvolvimento de aplicativos de negócios. A
plataforma utiliza o modelo de negócio específico como entrada e saídas de componentes acabados para software de negócios correspondente sistema.

Dois principais desafios que podem ser eficazmente solucionados com Plataforma DSL e abordagem DDD subjacente é a eliminação de falta de comunicação entre clientes e desenvolvedores em equipes de desenvolvedores.

A outra é a eliminação do trabalho repetitivo realizado pelos desenvolvedores ao automatizar tarefas repetitivas no processo de desenvolvimento.

O principal obstáculo impedindo a maior aceitação de \textit{Domain-Driven Design} na prática, é a falta de compreensão dos benefícios do DDD e as ferramentas potenciais que ele fornece.

Assim como no sistem de gerenciamento de GRU, a equipe de desenvolvimento às vezes esbarra na questão de conhecimento sobre a tecnologia que esta sendo utilizada para codificação, embora muitas as vezes a compreensão do domínio esteja bem disolvida na equipe.

\subsection{Evaluating Domain-Driven Design for Refactoring Existing Information Systems}

Esta tese de mestrado descreve a utilização de \textit{Domain-Driven Design} na refatoração e evolução de um sistema legado na empresa MERCAREON.

O autor cita que o principal desafio é que o DDD foi concebido para aplicação em novos sistemas, e não para refatoração de sistemas existentes. E foi necessário fazer um mapeamento da arquitetura antiga no sentido de obter conhecimento necessário para utilizar o \textit{Design-Domain Driven} de uma forma eficiente. Se fez necessário criar camadas que impedissem o vazamento de informações independentes para a nova arquitetura.

Embora o sistema de gestão esteja sendo executado com êxito, a empresa MERCAREON decidiu alterar a arquitetura do sistema introduzindo \textit{Domain-Driven Design}. A justificativa se origina do sistema de ser muito antigo. Outro fator é a comunicação, pois para aumentar esse problema, existem desenvolvedor na Alemanha e na Polônia o que prejudica tanto pela distância física quanto nos termos utilados pela equipe de desenvolimento.

O sistema de TSM, em especial foi criado com uma arquitetura em camadas tradicionais, que sofre continuamente de complexidade. O Autor ainda afirma que como em qualquer arquitetura de refatoração, a arquitetura sugerida pelo DDD também pode sofrer pela complexidade, mas menos do que as propostas tradicionais. Durante o processo de refatoração foi definido utilizar linguadem ubíqua que dee ser utilizada para qualquer comunicação e deve-se mantê-la atualizada.

Um ponto importante a ser observado durante a criação do mapa de contexto é que delimitar contextos também ajuda a pensar em como  distribuir as diferentes equipes.

\subsection{Architectural Improvement by use of Strategic Level Domain-Driven Design}

Neste artigo é apresentado a utilização de \textit{Domain-Driven Design} na empresa de petróleo Statoil ASA situada na Noruega, com foco nos conceitos do nível estratégico. O objetivo é aumentar a arquitetura corporativa utilizando a extensão da arquitetura empresarial e melhoria de software existente de empresarial para melhorar a arquitetura de software de um grande sistema corporativo.

O artigo cita a utilização de mapas de contexto e que a utilização foi de grande valor também pelo conhecimento adquirido, permitiu melhorar o escopo de novos projetos arquiteturais e melhoria do softwre existente de forma controlada.

O autor afirma que grandes empresas não tem um único núcelo. Mas que por outro lado, a nível de projeto, deve-se sempre ter um núcleo e que assim é melhor para conhecer o domínio principal e os objetivos.

A partir da análise da criação do mapa de contexto, um novo objetivo foi estabelecido e utilizado posteriormente para definir o escopo de um novo projeto, e este objetivo é a melhoria da arquitetura em novos projetos, gerenciamento e controle de recursos de documento.

Os contextos reais são derivados da Arquitetura corporativa, e transformando a arquitetura da empresa em uma ferramenta útila para a arquitetura de software de melhoria.

Um mapa de contexto é um desenho que documenta contextos de modelagem e suas relações. Grandes sistemas contém vários contextos de modelagem, então, eles representaram no contexto de modelagem de interesses, não as aplicações ou sistemas de informação que implementam os diferentes contextos.
O autor ainda afirma que mapa de contexto representa o primeiro ítem no nível estratégico \textit{Domain-Driven design}. Para o autor ficou a percepção de que a utilização do mapa de contexto e o seu papel na melhoria da arquitetura foi bem compreendido pela equipe, e que o sistema \textit{Digital Cargo File (DCF)} foi refatorado em 2006 para corresponder as recomendações sugeridas.

A empresa Statoil também adotou formalmente o uso de mapas de contexto como um artefato da arquitetura. O autor finaliza afirmando que o uso de camadas de responsabilidade parece reduzir a complexidade percebida.

\subsection{Diretrizes para desenvolvimento de linhas de produtos de software com base em Domain-Driven Design e métodos ágeis}

Esta dissertação de mestrado tem como principal objetivo demonstrar através de um estudo de caso a aplicação de DDD (Domain-Driven Design) e métodos ágeis no desenvolvimento de linhas de produtos de software, a fim de analisar as principais vantagens em relação aos métodos tradicionais.

O autor afirma que o processo de desenvolvimento em linhas de produtos de software (LPS) geralmente é sequencial e que o projeto não está focado em um modelo de domínio, mas mais intenssamente preocupado com questões técnicas, como alocação de componentes e separação em subsistemas. O aumento no reúso do software leva a um aumento por transformações nos sistemas.

O trabalho apresenta um estudo de caso, em que se desenvolve uma linha de produtos baseados em DDD para sistemas de transporte urbano. O BET (Bilhetes Eletrônicos de Transporte) é um protótipo de sistema que tem por objetivo gerenciamento de sistemas de transporte urbano onde propõe-se um conjunto de diretrizes de desenvolvimento de LPS. Segundo o autor são regras de caráter prático que visam a guiar o desenvolvimento de novas linhas de produtos. Adaptadas a cada contexto particular, as diretrizes podem ajudar a alcançar maior flexibilidade e extensibilidade nas LPS.

O estudao de caso considera que as regras para transporte urbano variam de cidade para cidade, essas diferenças foram modeladas como variabilidades da linha, enquanto as regras e conceitos comuns foram desenvolvidos como parte do núcleo. 

Foi priorizado um backlog contendo as histórias de usuário ordenadas por prioridade. Conforme sugere o DDD o sistema foi arquitetado em quatro camadas: apresentação, aplicação, domínio e infra-estrutura, e ainda sob o conceito do MVC (Model-View-Controller).
A camada de aplicação é composta por classes de serviço que coordenam outros serviços ou objetos do domínio, na camada de infra-estrutura encontram-se classes para persistencia de dados e onde objetos de domínio não conhecem nada sobre persistencia. Toda essa organização favorece ainda a injeção de dependência.

A criação das histórias e a conseqüente priorização do backlog foi feita com a ajuda de uma pessoa com bastante conhecimento sobre o domínio em questão Durante a implementação do sistema BET utilizando como base os princípios de DDD e métodos ágeis, surgiram vários problemas práticos de projeto.
Ao contrário de métodos tradicionais onde é encorajado criar o modelo completo de todo o projeto logo no início, baseado nas \textit{features} que são as funcionalidades previstas para o sistema crescem a cada iteração.

O estudo de caso sugere que é possível construir linhas de produtos fundamentadas em um
modelo de domínio mais expressivo, comparado ao que propõem os métodos tradicionais. A expressividade do modelo tem um grande impacto na facilidade de manutenção de uma linha de produtos e, conseqüentemente, na sua evolução. Com isso, a adaptabilidade a mudanças ao longo do tempo é bem maior. Além disso, um modelo de domínio expresso diretamente no código da aplicação reduz a necessidade de documentação não executável, como diagramas UML e documentos de casos de uso.

Durante o desenvolvimento do projeto, houve uma preocupação em aumentar a coesão das classes e reduzir o acoplamento entre elas. Para tal, foram utilizadas várias técnicas e princípios, como polimorfismo e princípio da responsabilidade única. O \textit{design} resultante mostrou-se bastante flexível e extensível. A inclusão ou alteração de regras de negócio ou mesmo de fluxos inteiros de atividade (como a funcionalidade de crédito em lote) podem ser feitas facilmente. A configuração das funcionalidades requeridas para um produto consiste apenas de configuração do grafo de dependências, por meio de uma linguagem específica de domínio.

A aplicação de DDD ao desenvolvimento de linhas de produtos de software mostrou-se bastante adequada. A razão disto é o enfoque do desenvolvimento baseado em uma linguagem ubíqua do domínio. Destarte, os conceitos do domínio revelam-se com muito mais clareza no código da LPS. O efeito mais relevante dessa transparência é uma maior facilidade de manutenção da linha a curto e longo prazo. As principais vantagens observadas na abordagem proposta em relação aos métodos tradicionais são: menor esforço na implementação de uma nova regra de negócios (em geral, uma nova classe, comparada a vários componentes e classes no modelo de componentes da implementação de referência) e maior capacidade de reúso, pela atribuição adequada de responsabilidades, pela divisão em vários níveis de granularidade (compatíveis com o nível de abstração da classe) e pela aplicação de princípios de orientação a objetos, como o princípio de substituição de Liskov e o princípio aberto-fechado.

Em algumas situações, o uso de uma linguagem ubíqua pode trazer problemas, embora estes
não tenham sido experimentados neste trabalho. Trata-se dos casos em que as linguagens utiliza-
das no contexto de cada produto sejam diferentes.

Como a equipe de desenvolvimento não tinham experiência anterior com o \textit{Domain-Driven design} e ainda tem de manter o atual sistema de TSM a MERCAREON decidiu que apenas como um primeiro passo de um pequeno módulo, o Live Yardview, foi criado usando a proposta de refatoração técnicas baseadas em DDD para estabelecer uma arquitetura sustentável. Este módulo vai coexistir com o atual sistema de TSM. Quando concluído, o módulo a partir do limite do contexto deverá ser continuamente expandido até chegar a uma verdadeira arquitectura de refatoração.

\subsection{ Quadro Comparativo }

A tabela 1 apresenta um quadro comparativo baseado na solulção dos artigos apresentados nesta seção, e que resume a conceito central utilizado em cada artigo na solução do problema do domínio segundo o \textit{Domain-Driven design}.

%\newpage

\begin{table}[ht]
\centering
\caption{Soluções apresentadas por cada artigo baseados no \textit{Domain-Driven design}}
\label{my-label}
\begin{tabular}{|l|l|l|l|}
\hline
 & Linguagem Ubíqua & Mapa de Contexto & Arquitetura \\ \hline
 \cite{DesigningIidentityProvider} & \multicolumn{1}{c|}{X}                &                  &             \\ \hline
 \cite{vlahovicimplications} & \multicolumn{1}{c|}{X}                &                  &             \\ \hline
 \cite{hess2016evaluating} & \multicolumn{1}{c|}{X}                & \multicolumn{1}{c|}{X}                &             \\ \hline
 \cite{landre2006architectural} & \multicolumn{1}{c|}{X}                &                  & \multicolumn{1}{c|}{X}           \\ \hline
 \cite{macedodiretrizes} & \multicolumn{1}{c|}{X}                 & \multicolumn{1}{c|}{X}                  & \multicolumn{1}{c|}{X}            \\ \hline
 Gerenciamento de GRU & \multicolumn{1}{c|}{X}                & \multicolumn{1}{c|}{X}                 & \multicolumn{1}{c|}{X}           \\ \hline
\end{tabular}
\end{table}

\newpage
%\clearpage


\section{Solução Implementada}

\subsection{Diagramas de Casos de Uso}
O atual sistema web de gerenciamento de verificação do cronotacógrafo que tem como ferramenta de desenvovlimento o \textit{framework} \textit{CakePHP} inicialmente era responsável apenas pela simples emissão de GRU, então era um cenário simples de manter até por conta da regra de negócio que também era simples, fácil identificar o propósito das classes e seus métodos e por consequência se tornava fácil implementar as alterações de regras de negócio. Outro fator relevante é que somente um desenvolvedor era o responsável pela manutenção do sistema. Ao passar dos anos com a popularização da utilização de serviços web e a maior facilidade do acesso ao público à internet não somente pelo computador de casa mas também através de dispositivos móveis, fez com que no Cronotacógrafo muitos serviços que não existiam ou que eram realizados de forma manual passassem a ser realizados pelo atual sistema. E como o Inmetro do estado do Rio Grande do Sul é o orgão que mantém a equipe responsável por atender e regulamentar o processo de verificação de Cronotacógrafo abrangendo todos os estados do país, o sistema passou a ter que suportar muitas novas funcionalidades, funcionalidades estas que refletem diretamente desde a emissão da GRU até a emissão do certificado final.

Assim houve a necessidade de se aumentar aos poucos a equipe de desenvolvimento e muitas vezes é difícil alinhar o conhecimento, manter o mesmo padrão no desenvolvimento do código, refatorar, realizar testes unitários, mesmo porque novos programadores são vinculados a equipe e outros acabam saindo.

Entendendo que o framework provê uma arquitetura MVC sugerindo uma separação de responsabilidades, e se entendia também que isso era o suficiente para manter o código organizado do ponto de vista do domínio do problema, mas conforme o domínio foi aumentando e ficando complexo a estrutura do \textit{framework} se manteve a mesma, apenas acumulando classes e funções dentro das pastas \textit{Controllers}, \textit{Models} e \textit{Views}.

Algumas informações do sistema do Cronotacógrafo tem origem em outro sistema, o SGI (Sistema de Gestão Integrada) que possui banco de dados próprio, e alguns termos que tem o mesmo significado sofreram alteração de nome no banco de dados do Cronotacógrafo, causando mais dificuldades quando os desenvolvedores tentam fazer os dois sistemas se comunicarem. No dia 01 de janeiro de 2016 houve uma grande mudança no processo de emissão de GRU, atualmente os postos de selagem e de ensaio (PAC) emitem a GRU, e  semelhante a um plano pré-pago de celular, o posto compra créditos para cada GRU emitida, cada crédito permite ao posto acessar o site do Cronotacógrafo e registrar os dados do serviço realizado, seja serviço de selagem ou de ensaio metrológico.

Essa alteração afetou diretamente a codificação no sistema, o código e a arquitetura que antes já eram complicados, ficou maior e mais complexo, pois as regras antigas deveriam ser mantidas sem alteração, e o sistema teve que comportar muitas regras novas, os desenvolvedores tiveram que adquirir conhecimento das novas regras de negócio e que algumas vezes ao serem implementadas se confundiam com regras antigas.

Afim de auxiliar a comunicação entre os analistas e o cliente, o sistema e suas funcionalidades são apresentados conforme figura 5.


\begin{figure}[ht]
\centering
\includegraphics[width=1\textwidth, height=0.5\textheight]{imagens/diagram-use-case.png}
\caption{Padrões para auxiliar a modelagem de objetos}
\label{fig:diagram-use-case}
\end{figure}

%\clearpage

\begin{table}[ht]
\centering
\caption{Documentação do Caso Emitir Gru de Selagem}
\label{my-label}
\begin{tabular}{|p{7cm}|p{7cm}|}
\hline
\begin{tabular}[c]{@{}l@{}}Nome do caso de Uso\end{tabular} & Emitir Gru de Selagem  \\ \hline
Caso de Uso Geral & Emitir GRU                                                                                                               \\ \hline
Ator Principal& Posto                                                                                                                    \\ \hline
Atores Secundários                                                                                   & -                                                                                                                        \\ \hline
Resumo                                                                                               & Este caso de uso descreve as etapas percorridas por um usuário para emitir uma GRU de selagem.                           \\ \hline
Pré­-condições                                                                                       & Usuário autenticado \\ \hline
Pós-condições                                                                                        & Realizar o pagamento da GRU                                                                                                                          \\ \hline
\multicolumn{2}{|c|}{Fluxo Principal}                                                                                                                                                                                           \\ \hline
\multicolumn{1}{|c|}{Ações do Ator} & \multicolumn{1}{|c|}{Ações do Sistema}\\ \hline
\begin{tabular}[c]{@{}l@{}}1. Informar a quantidade de créditos para \\ cada GRU emitida\end{tabular} & \begin{tabular}[c]{@{}l@{}}2. Calcular o valor a ser pago\end{tabular}                                                 \\ \hline
Restrições/Validações                                                                                & \begin{tabular}[c]{@{}l@{}}1. Usuário autenticado deve ser um posto \\ de Selagem ou PAC\end{tabular} \\ \hline
\end{tabular}
\end{table}

\begin{table}[ht]
\centering
\caption{Documentação do Caso de Uso Informar Selagem}
\label{my-label}
\begin{tabular}{|p{7cm}|p{7cm}|}
\hline
\begin{tabular}[c]{@{}l@{}}Nome do caso de Uso\end{tabular} & Informar Selagem  \\ \hline
Caso de Uso Geral & Emitir GRU                                                                                                               \\ \hline
Ator Principal& Posto                                                                                                                    \\ \hline
Atores Secundários                                                                                   & -                                                                                                                        \\ \hline
Resumo                                                                                               & Este caso de uso descreve as etapas percorridas por um usuário para informar selagem.                           \\ \hline
Pré­-condições                                                                                       & Usuário autenticado; Gru Paga \\ \hline
Pós-condições                                                                                        & Informar dados da selagem                                                                                                                          \\ \hline
\multicolumn{2}{|c|}{Fluxo Principal}                                                                                                                                                                                           \\ \hline
\multicolumn{1}{|c|}{Ações do Ator} & \multicolumn{1}{|c|}{Ações do Sistema}\\ \hline
\begin{tabular}[c]{@{}l@{}}1. Informar a GRU \\ 2. Informar  o veículo \end{tabular} & \begin{tabular}[c]{@{}l@{}}3. Informar os dados da selagem\end{tabular}                                                 \\ \hline
Restrições/Validações                                                                                & \begin{tabular}[c]{@{}l@{}}1. Usuário autenticado deve ser um posto \\ de Selagem ou PAC \\ 2. Validar veículo \\ 3. Validar GRU \end{tabular} 

\\ \hline
\end{tabular}
\end{table}

\begin{table}[ht]
\centering
\caption{Documentação do Caso Informar Substituição de Selos}
\label{my-label}
\begin{tabular}{|p{7cm}|p{7cm}|}
\hline
\begin{tabular}[c]{@{}l@{}}Nome do caso de Uso\end{tabular} & Informar Subsituição de Selos \\ \hline
Caso de Uso Geral & Emitir GRU                                                                                                               \\ \hline
Ator Principal& Posto                                                                                                                    \\ \hline
Atores Secundários                                                                                   & -                                                                                                                        \\ \hline
Resumo                                                                                               & Este caso de uso descreve as etapas percorridas por um usuário para informar Subsituição de selos.                           \\ \hline
Pré­-condições                                                                                       & Usuário autenticado; Gru Paga; Deve existir uma selagem realizada \\ \hline
Pós-condições                                                                                        & Informar dados da selagem                                                                                                                          \\ \hline
\multicolumn{2}{|c|}{Fluxo Principal}                                                                                                                                                                                           \\ \hline
\multicolumn{1}{|c|}{Ações do Ator} & \multicolumn{1}{|c|}{Ações do Sistema}\\ \hline
\begin{tabular}[c]{@{}l@{}}1. Informar a GRU \\ 2. Informar  o veículo \end{tabular} & \begin{tabular}[c]{@{}l@{}}3. Informar os dados da selagem\end{tabular}                                                 \\ \hline
Restrições/Validações                                                                                & \begin{tabular}[c]{@{}l@{}}1. Usuário autenticado deve ser um posto \\ de Selagem ou PAC \\ 2. Validar veículo \\ 3. Validar GRU \end{tabular} 

\\ \hline
\end{tabular}
\end{table}

\begin{table}[ht]
\centering
\caption{Documentação do Caso de Uso Informar Ensaio}
\label{my-label}
\begin{tabular}{|p{7cm}|p{7cm}|}
\hline
\begin{tabular}[c]{@{}l@{}}Nome do caso de Uso\end{tabular} & Informar Ensaio \\ \hline
Caso de Uso Geral & Emitir GRU                                                                                                               \\ \hline
Ator Principal& Posto                                                                                                                    \\ \hline
Atores Secundários                                                                                   & -                                                                                                                        \\ \hline
Resumo                                                                                               & Este caso de uso descreve as etapas percorridas por um usuário para informar ensaio com GRU emitida a partir de 2016.                           \\ \hline
Pré­-condições                                                                                       & Usuário autenticado; Nº de protocolo gerado na selagem\\ \hline
Pós-condições                                                                                        & Informar dados da selagem                                                                                                                          \\ \hline
\multicolumn{2}{|c|}{Fluxo Principal}                                                                                                                                                                                           \\ \hline
\multicolumn{1}{|c|}{Ações do Ator} & \multicolumn{1}{|c|}{Ações do Sistema}\\ \hline
\begin{tabular}[c]{@{}l@{}}1. Informar o nº do protocolo\end{tabular} & \begin{tabular}[c]{@{}l@{}}2. Gerar GRU\end{tabular}                                                 \\ \hline
Restrições/Validações                                                                                & \begin{tabular}[c]{@{}l@{}}1. Usuário autenticado deve ser um \\ posto PAC \\ 3. Validar GRU \end{tabular} 

\\ \hline
\end{tabular}
\end{table}

%\clearpage

\begin{table}[ht]
\centering
\caption{Documentação do Caso de Uso Cancelar GRU}
\label{my-label}
\begin{tabular}{|p{7.1cm}|p{7.1cm}|}
\hline
\begin{tabular}[c]{@{}l@{}}Nome do caso de Uso\end{tabular} & Cancelar GRU \\ \hline
Caso de Uso Geral & Emitir GRU                                                                                                               \\ \hline
Ator Principal& Posto                                                                                                                    \\ \hline
Atores Secundários                                                                                   & -                                                                                                                        \\ \hline
Resumo                                                                                               & Este caso de  \\ \hline
Pré­-condições                                                                                       & Usuário autenticado \\ \hline
Pós-condições                                                                                        & Informar o motivo do cancelamento \\ \hline
\multicolumn{2}{|c|}{Fluxo Principal}                                                                                                                                                                                           \\ \hline
\multicolumn{1}{|c|}{Ações do Ator} & \multicolumn{1}{|c|}{Ações do Sistema}\\ \hline
\begin{tabular}[c]{@{}l@{}}1. Consultar a GRU\end{tabular} \\ 2. Informar o motivo do cancelamento & \begin{tabular}[c]{@{}l@{}}3. Cancelar a GRU\end{tabular}                                                \\ \hline
Restrições/Validações                                                                                & \begin{tabular}[c]{@{}l@{}}1. Usuário autenticado deve ser SURRS \\ 2. Se possui ensaio/selagem não pode ser \\ cancelada. \end{tabular} \\ \hline
\end{tabular}
\end{table}

%\clearpage

\begin{table}[ht]
\centering
\caption{Documentação do Caso de Uso Cancelar Pagamento}
\label{my-label}
\begin{tabular}{|p{7.1cm}|p{7.1cm}|}
\hline
\begin{tabular}[c]{@{}l@{}}Nome do caso de Uso\end{tabular} & Cancelar GRU \\ \hline
Caso de Uso Geral & Emitir GRU                                                                                                               \\ \hline
Ator Principal& Posto                                                                                                                    \\ \hline
Atores Secundários                                                                                   & -                                                                                                                        \\ \hline
Resumo                                                                                               & Este caso de  \\ \hline
Pré­-condições                                                                                       & Usuário autenticado \\ \hline
Pós-condições                                                                                        & Informar o motivo do cancelamento  \\ \hline
\multicolumn{2}{|c|}{Fluxo Principal}                                                                                                                                                                                           \\ \hline
\multicolumn{1}{|c|}{Ações do Ator} & \multicolumn{1}{|c|}{Ações do Sistema}\\ \hline
\begin{tabular}[c]{@{}l@{}}1. Consultar a GRU\end{tabular} \\ 2. Informar o motivo do cancelamento & \begin{tabular}[c]{@{}l@{}}3. Cancelar o pagamento\end{tabular}                                                 \\ \hline
Restrições/Validações                                                                                & \begin{tabular}[c]{@{}l@{}}1. Usuário autenticado deve ser SURRS \\ 2. Identificar pagamento duplicado \\ 3. Identificar pagamento inferior ao \\ contratado na GRU\end{tabular} \\ \hline
\end{tabular}
\end{table}

\clearpage
\newpage
\subsection{Mapa de Contexto}

A figura 5 representa uma visão geral do domínio GRU e em quais outros subdomínios o domínio GRU também é utilizado.

\begin{figure}[ht]
\centering
\includegraphics[width=1\textwidth, height=0.65\textheight]{imagens/context-mapping.png}
\caption{Padrões para auxiliar a modelagem de objetos}
\label{fig:diagram-use-case}
\end{figure}

\newpage

\subsection{Arquitetura da Aplicação}

A figura 6 representa através do diagrama de pacotes a estrutura hierarquica dentro da aplicação segundo os conceitos do \textit{Domain-Driven design}.

Todas as camandas tem como dependência a camada \textit{Domain}, com foco no domínio do negócio como é proposto pelo \textit{Domain-Driven design}, as outras camandas não conseguem agir sem o domínio do negócio. A interface precisa acessar coisas do domínio e se comunicar com a aplicação e a infraestrutura para ser montada. A Aplicação precisa da infraestrutura e da intereface. A aplicação tem por responsabilidade capturar as requsiçãoes e conectar a interface com o restante da aplicação.

Mais externo ao contexto do sistema tem-se o \textit{Database} que representa a fonte de dados do sistema. Também torna-se evidente a relevância maior do domínio e a necessidade de tirar o banco de dados do centro da aplicação.

\begin{figure}[ht]
\centering
\includegraphics[width=1\textwidth, height=0.5\textheight]{imagens/pck-diagram-system.png}
\caption{Representação resumida da arquitetura através do diagrama de pacotes}
\label{fig:diagram-use-case}
\end{figure}

A figura 7 representa através do diagrama de pacotes a mesma estrutra apresentada na figura 6 mas de forma detalhada. É possível entender como está organizada a aplicação e a responsabilidade de cada camada. Nesse nível de detalhamento é visível notar a redução do acoplamento, aonde na camada de dominio concentra-se todo o conceito de \textit{Domain-Driven design}

Destaca-se a camada \textit{Domain} que comportará repositórios, fábricas, serviços, agregados e entidades. Na infraestrutura tem-se acesso a dados, configuração de serviço da aplicação, e de bibliotecas de terceiros.

\begin{figure}[ht]
\centering
\includegraphics[width=1\textwidth, height=0.6\textheight]{imagens/pck-diagram-detail.png}
\caption{Representação detalhada de cada camada}
\label{fig:diagram-use-case}
\end{figure}

\clearpage

\subsection{Repositórios}

A figura 8 representa o diagrama de classes relacionando classes que tem como responsabilidades acessar dados externos a aplicação. E isso permite maior flexibilidades quando se precisa trabalhar com mais de uma fonte de dados diferentes, como criar repositórios específicos para fonte de dados específicos. Poderia a aplicação possuir um repositório específico para OracleRepository, MongoDBRepository, SqlServerRepository e nelas conter implementações específicas de acesso a dados.

\begin{figure}[ht]
\centering
\includegraphics[width=0.9\textwidth, height=0.6\textheight]{imagens/repository-crono.png}
\caption{Representação de repositórios no diagrama de classes}
\label{fig:diagram-use-case}
\end{figure}

\newpage

\subsection{Módulos}

A figura 9 apresenta a organização do sistema na camada do domínio, foi organizado dentro dela além de entidades quem tem maior afinidade com o contexto, também repositórios, interfaces, objetos de valor e fábricas.

\begin{figure}[ht]
\centering
\includegraphics[width=0.6\textwidth, height=0.72\textheight]{imagens/modulos-crono.png}
\caption{Representação da camada \textit{Domain} baseada em módulos}
\label{fig:diagram-use-case}
\end{figure}

\newpage

\section{Limitações}

Segundo \cite{mauricioaniche} não é o \textit{framework} que vai fazer o software parar, nem ele que será mantido no futuro, são as classes que mantém as regras de negócio que precisam de atenção. 

Essa afirmação se reflete por inteiro no sistema do Cronotacógrafo, não somente pela utilização do \textit{framework}, não somente pelas implementações do código que apesar de possuir classes e métodos, é visível que a codificação fica longe do paradigma de orientação à objetos, existe também uma má tradução das regras de negócio quando transformadas em código. Mas o sistema consegue atingir o objetivo, que é entregar valor ao cliente segundo as regras de negócio definidas. O problema realmente é quando começam a exisitr exceções a regra e as classes já estão tão acopladas que é difícil identificar e separar responsabilidades, ainda mais quando o desenvolvedor que dará manutenção não é o mesmo que criou a funcionalidade, e assim acontece no Cronotacógrafo, os desenvolvedores não são responsáveis apenas por um módulo, assim como o módulo poderá ter vários responsáveis diferentes.

O amadurecimento da equipe também é muito importante para tentar aplicar \textit{Domain-Driven design}, e concerteza o não entendimento dos conceitos descritos por \cite{Evans:2003:DDT:861502} causará confusão nos membros da equipe, e no caso deste artigo, tão difícil quanto compreender os conceitos de \textit{Domain-Driven design} é tomar decisões com relação a quais contextos pertencem os objetos de domínio. Pois como em qualquer sistema as regras de negócio podem variar bastante, e talvez os objetos que antes faziam sentido dentro de um contexto podem não se encaixar no mesmo contexto a medida que as regras de negócio evoluem.

Atualmente o sistema do Cronotacógrafo utiliza o banco de dados da Oracle, e todas as classes tem uma implementação direta referenciando o banco de dados Oracle, não existe nenhuma classe intermediaria que permita abstrair as chamadas ao banco. Dessa maneira surgiu a necessidade da utilização de repositórios para chegar nos objetos de conhecimento do domínio. Passando então a fazer parte da linguagem ubíqua, uma vez que não deveria ser utilizado somente como algo interno ao código, estando presente também nas conversas com os especialistas do domínio e por consequencia no modelo do domínio. Mantendo-se o princípio da linguagem ubíqua não existe problema ao trazer termos técnicos se todos entendem o conceito, e se no contexto do domínio GRU existisse outro nome que fizesse mais sentido do que o nome repositório esse novo nome seria utilizado, mesmo os desenvolvedores sabendo que no fundo aquilo é um repositório.

O problema das pessoas é que utilizando \textit{Domain-Driven design} acreditam que nele contem toda a essência das coisas. O \textit{Domain-Driven design} não é uma descrição de padrões de projeto, embora tenha alguns, ele auxilia o time de desenvolvedores a ficar atento em alguns pontos-chave para conseguir um melhor \textit{design}, mas não ensinará um \textit{design} melhor para o problema específico de gerenciamento de GRU.

Abri-se mão de classes coesas e flexíveis para ganhar os benefícios do \textit{framework} e classes difíceis de serem testadas e mantidas são escritas pela simples questão da produtividade \cite{mauricioaniche}.



\section{Conclusão}

Este artigo demonstrou através de um problema real a aplicação de alguns conceitos de \textit{Domain-Driven design} na solução do problema de gerenciamento de GRU de Cronotacógrafo, e a partir dele é possível considerar vários fatores que podem levar ao sucesso ou ao fracasso do projeto mesmo seguindo todas as etapas do \textit{Domain-Driven design}.

Tão ou mais importante do que aplicar \textit{Domain-Driven design} é necessário que todos os desenvolvedores da equipe tenham o domínio de orientação a objetos juntamente com SOLID e GRASP por exemplo, e que são importantíssimos para ajudar a pensar no \textit{design} do software, em como as classes serão relacionadas e estruturadas. Conhecer ferramentas de testes unitários, ser capaz de trabalhar com desenvolvimento guiado por testes, entender sobre a importância da integração contínua, automatização de rotinas, boas práticas de desenvolvimento de software e tudo mais que puder ser relevante para ajudar a construir software confiável e manutenível de forma rápida e com ritmo e qualidade sustentável.

Quando se fala em orientação a objetos pensa-se logo em classes, heranças, polimorfismo, encapsulamento. Mas a essência da orientação a objetos também tem coisas como: alinhamento do código com o negócio, favorecer a reutilização e baixo acoplamento. \textit{Domain-Driven design} poderia ser visto como uma evolução da orientação a objetos, mas ele não foca em tecnologia, mas sim em entender as regras de negócio e como elas devem estar refletidas no código e no modelo de domínio. 

O \textit{Domain-Driven design} permite realmente alinhar o conhecimento dos desenvolvedores e dos especialistas do domínio produzindo software mais coerente com o negócio e reduzindo as chances de que o conhecimento sobre o modelo do domínio fique nas mãos de poucas ou de uma única pessoa.

O grande desafio ao propor o desenvolvimento de software utilizando \textit{Domain-Driven design} é manter a equipe comprometida desde o início com os novos conceitos, fazendo-os entender dos benefícios, pois cada um teve experiências anteriores com outros projetos complexos que não se utilizou da aplicação de conceitos mais evoluídos sugeridos pelo \textit{Domain-Driven design} e mesmo assim o software entregou valor ao cliente. A equipe também terá dificuldades senão conhecer muito bem o \textit{framework}, no caso deste artigo o \textit{CAKEPHP}, que pela versão utilizada já pode ser considerado ultrapassado e que tornaria mais trabalhoso e custoso para o cliente aplicar \textit{Domain-Driven design}.

Independente do framework e aplicando-se muito bem os conceitos de orientação a objetos é possível chegar bem próximo de alguns conceitos apresentados pelo \textit{Domain-Driven design}. Pode-se afirmar que \textit{Domain-Driven design} é programar utilizando orientação a objetos com responsabilidade e qualidade.

\newpage

\section{Referencias}

\bibliographystyle{sbc}
\bibliography{sbc-template}

\end{document}
