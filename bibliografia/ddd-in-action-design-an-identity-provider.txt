
Da dissertação de mestrado do Departamento de Ciência da Computação da
Universidade de Copenhaga, primavera de 2009
Supervisor: Jyrki Katajainen
design orientado por domínio de acção na
concepção de um provedor de identidades
Klaus Byskov Ho mann




iii
Resumo. Em muitos scienti c disciplinas complexidade é um dos mais emocionantes
temas atuais, como pesquisadores tentam atacar reproduzem a do mundo real. um desenvolvedor de software tem que a mesma perspectiva quando se está de frente para um domínio complicado que
nunca foi formalizado.
Nesta tese os princípios de projeto orientado de domínio são usados para um modelo de negócio do mundo real- problema, nomeadamente um quadro para um provedor de identidade extensível.
Uma especi cação para o software é apresentado e com base nesta especi cação de um com- pleta modelo é criado usando os princípios de design orientado para o domínio que também são apresentadas. A tese também inclui uma implementação de um domínio genérico projeto orientado ao quadro que utiliza mapas objeto-relacional. É então mostrou como este quadro pode ser utilizado para implementar o modelo projetado. Por último, a regulamentaço ̃ es e exaustividade do modelo é validado através de uma série de comentários e
entrevistas.
O trabalho mostra que a aplicação dos princípios de projeto orientado de domínio é uma boa
abordagem para a modelagem de um negócio complexo domínio.


Capítulo
Prefácio
esta tese de mestrado conclui a minha cand. scient grau em Ciência da Computação na Universidade de Copenhaga. A tese foi escrito no período compreendido entre
1 de Setembro de 2008 a 29 de Maio de 2009.

Introdução
a coisa que determina como o complexo problema que pode ser resolvido por um pedaço de software não é como muitos programadores você contratar para código ela mas quão bem você design. Se o design não é pensado desde o início, e todos os envolvidos na programação soluciona as suas tarefas a partir de uma variação de compreensão do problema domínio, então as chances são de que você vai acabar com uma base de código confuso que é difícil de compreender, manter e alargar. Instalações de design orientado para o domínio são que cada projeto de software deve ser baseada em um modelo e que o foco deve ser o domínio e a lógica de domínio em vez de na tecnologia que está sendo usada. Quando a focagem no modelo é mais fácil atingir uma terminologia partilhada entre os especialistas em domínio e os programadores, quebrando assim as barreiras linguísticas que muitas vezes existem entre eles. Design orientado para o domínio não é uma tec- nologia ou um método, mas uma mente e um conjunto de prioridades. Orientado por domínio designdeals com a escolha de um conjunto de princípios de design, padrões de projeto e práticas recomendadas a fim de alcançar um desenvolvimento mais rápido de software lidar com um negócio complexo domínio, enquanto ao mesmo tempo obtendo uma base de código que
é demorada e extensível.
A fim de discutir como projeto orientado de domínio pode ser usado para projetar com- plex software, é importante para mim que a discussão é baseada em um problema da vida real, e não apenas sobre ctitious exemplos. Por conseguinte, esta tese é baseado em um projeto que eu estou trabalhando com meu empregador atual, uma empresa chamada Safewhere. Sobre este projecto, somente eu sou responsável pelo desenvolvimento do software, que torna o projeto bem adequado para esta tese de um homem.
O projecto tem evidentemente de outras partes interessadas, tais como o
diretor técnico e o CEO da Safewhere.
1




2
o projeto à mão diz respeito ao desenvolvimento de um quadro necessário para implementar um provedor de identidade multi-protocolo, conforme descrito no capítulo 2. A tese de não incluir uma versão totalmente funcional do produto, mas não
incluem um design completo e implementação da funcionalidade central.
Para ter a certeza de que eu tenho conseguido fazer uma fácil manutenção e modelo extensível pedi a alguns dos meus colegas para rever o modelo. Tenho entrevistados cada pessoa e lhes tinha de avaliar a qualidade do design e a bene ts de domínio usando o projeto orientado em geral.

Visão geral do capítulo
A rst três capítulos contêm uma introdução geral ao domínio do problema e ao design orientado por domínio. Assim, estes capítulos principalmente conter material de livros e papéis e a minha contribuição para o conteúdo encontrado aqui é apenas de transmitir o conhecimento em um formato mais compacto e adequado.
Os últimos seis capítulos contêm a minha principal contribuição, onde eu tomar a teoria
da rst capítulos e pôr em prática.
Provedor de identidade: Este capítulo explica em termos gerais, o que um provedor de identi- dade (PDI).
Especifi cação: Este capítulo contém o recurso especi cação do soft-
ware que vai ser desenvolvido.
Design orientado para o domínio: Este capítulo contém uma introdução ao domínio-
projeto orientado e os conceitos que utiliza.
Modelo: Este capítulo contém o modelo de design de software usando domínio-
projeto orientado.
Objeto-relacional mapas: No presente capítulo I discutir como objeto-relacional
mapas podem ser aproveitados em design orientado por domínio.
Um domínio neutro componente: No presente capítulo I irá apresentar a implementaçäao
de um domínio neutro componente que implementa a funcionalidade de um lote de base que é útil para a implementação de um sistema baseado no
design orientado por domínio.
Aplicação: No presente capítulo I irá mostrar o código fonte de alguns
dos mais interessantes partes da implementação do sistema.
Validação do projeto: Este capítulo é baseado em entrevistas com alguns dos meus
colegas e a sua finalidade é para me deixar de avaliar a qualidade do modelo e
o software aqui apresentados.




3
CONCLUSÃO: Este capítulo contém uma conclusão sobre o que foi aprendido a
partir trabalhando com design orientado para o domínio.
Dicas para o leitor
essa tese é escrito em inglês britânico. A tese é destinado a ser lido do início ao fim, uma vez que a maioria dos capítulos construir sobre teoria explicada
nos capítulos anteriores.
O leitor deve estar familiarizado com a programação orientada a objetos e de assinar. Todas as amostras de código neste relatório estão em C#, uma língua da
família Microsoft TM .NET. Um exemplo de código poderá ter esta aparência:
Um exemplo de código
1 public void DoNothing(int i, int j)
2 {
3 //Não fazer nada com os dados de entrada e de retorno
4 retorno;
5 }
se você não estiver familiarizado com C# você pode consultar o Apêndice A, que
contém uma breve introdução ao idioma.
O código desenvolvido pode ser encontrada no disco. Tendo em Microsoft Visual Studio 2008 instalado é uma condição prévia para a abertura a solução le,
todavia cada código le pode ser inspecionado em qualquer editor de texto.




Capítulo
reconhecimentos
em primeiro lugar gostaria de agradecer ao meu supervisor, professor Jyrki Katajainen o seu apoio e dedicação ao projecto completo. Gostaria também de agradecer ao diretor técnico em Safewhere, Pedro Haastrup, para o seu sincero interesse no projeto, para blindagem de mim a partir de coisas que eu não tinha necessidade de chateado com e para manter incentivando-me ao longo de todo o processo. Gostaria também de agradecer o CEO em Safewhere, Niels Flensted-Jensen, por me deixar escrever minha tese em colaboração com a empresa e a marca Seemann, Mikkel Christensen e Peter Haastrup para tirar um tempo para rever o modelo e participar em entrevistas. Por último gostaria de agradecer à minha bela esposa Gitte Byskov Ho mann para o rolamento com a mim no final de noites e finais de semana onde uma parte substancial do meu tempo foi dedicado a estudar para e por escrito sobre
esta tese.
4




Capítulo
1
provedor de identidade
um provedor de identidade (PDI) é um serviço de identidade centralizado cuja principal responsabilidade é a identificação de um usuário e informando algo sobre esse usuário, tais como o nome do usuário de e-mail, ou número de RCP. O IdP identifi es do usuário com base nas credenciais de alguns e as declarações que faz sobre o usuário são conhecidos como créditos. A figura 1 mostra o trabalho primário de uma identidade
Figura 1. Um provedor de identidades.
provedor. Em termos gerais pode ser dito que um IdP executa a função
f( ) = ζ ζ :∈φ onde está um determinado conjunto de credenciais andζ é um conjunto de reivindicações
da setφ completa de créditos que podem ser emitidos pelo IdP. Em toda
esta tese vou consultar a f( ) como token emissão. Ζ será referida como
token, será referido como as credenciais do usuário e nitivamente vou consultar φ
como pedidos do provedor de identidade
1.1. O caso de uso do IdP exemplo
o advento de um leque de novas tecnologias tais como serviços web SOAP, Ajax, novo navegador recursos e maior largura de banda da Internet tornou intro- ble para ISVS para fornecer software que está hospedado na nuvem. Este tipo de software é chamado de software como um serviço. Comprar o software como um serviço está se tornando mais e mais popular para um número de razões. Principalmente porque o custo total de propriedade do software como um serviço versus auto-software hospedado tende a ser menor. De facto, segundo a Daarbak [2008], a ana- ides de empresa Gartner prevê que 30% de todos os sistemas de CRM será executado no modelo de software como um serviço no ano 2012. As soluções de software como um serviço estão hospedados em grandes centros de dados e fornecer a capacidade
5




6
para escala rapidamente a aplicação para um determinado cliente deve surgir necessidade.
Este extra é outro ponto de venda a exibilidade para software como um serviço solu Äoes. Isvs que vender as soluções de software como um serviço pode escolher utilizar créditos de controle de acesso baseado em seus aplicativos. A figura 2 abaixo mostra um ctitious
empresa que utiliza dois aplicativos de SaaS na nuvem.
Figura 2. O caso de uso do IdP.
O equipamento para empresa de vendas usa um aplicativo de envio e um aplicativo de contabilidade na nuvem. A contabilidade aplicação utiliza o protocolo e a identidade SAML2.0 aplicação de envio usa o protocolo OpenId.
Quando o usuário 1 quer para efetuar login no aplicativo de contabilidade, ele é convidado a ir e obter um token de segurança a partir de um provedor de identidade que é considerado confiável pelo aplicativo de contabilidade. O provedor de identidade questões agora um token de segurança contendo uma alegação de que o titular é um vendedor . Uma vez que esta é a reivindicação exigida pelo aplicativo de contabilidade, Usuário 1 agora está autorizado a utilizar os seus recursos. Quando o usuário 1 mais tarde quer ir e usar o aplicativo de envio, acontece a mesma coisa. A única referência é que o di aplicação de envio usa outro protocolo de identidade, nomeadamente OpenId. Esta configuração tem vários bene ts.
Primeiro de tudo, o usuário 1 tem apenas para efetuar login em uma vez dentro de uma sessão, uma vez que o provedor de identidade vai se lembrar dele. Em segundo lugar, o equipamento para empresa de vendas tem um único




7
lugar onde pode gerenciar seus usuários e os pedidos que são emitidos sobre eles. Isto significa que seria possível revogar o acesso do usuário 1 tanto para o aplicativo de envio e de escrituração através da revogação do seu vendedor alegação no IdP. Por último, o IdP permite que a peneira empresa de vendas para integrar facilmente com o software como serviço de produtos que usam protocolos de identidade entravarão um di.
Por favor note que o IdP mostrado aqui é realmente um software como um serviço próprio produto, embora conceitualmente poderia muito bem ser um
aplicativo autônomo em empresa de vendas da sapata.
É o projeto e a implementação de um provedor de identidades como a
mostrada na Figura 2 que é o objectivo desta tese.




Capítulo
2
Especi cação
Este capítulo inclui o recurso especi cação do provedor de identidade soft- ware que vai ser projetada e implementada. O capítulo irá conter requisitos tanto para o software e a plataforma na qual é executado o software . O foco principal da presente tese é naturalmente o software, no entanto, con- temente sobre a plataforma são importantes para uma compreensão completa
do sistema e por conseguinte não são aqui incluídos para integralidade.
Antes de entrar na especi c detalhes, gostaria de propor o seguinte texto, tomadas a partir de uma brochura de marketing feitas pelo Safewhere, para vos dar uma ideia do que se trata o projeto, a partir de uma perspectiva de negócios. No texto a seguir
o produto é referido como Safewhere*Identificar, um termo que não vou utilizar
todo o restante da tese.
Safewhere*identificar é um novo tipo de usuário identifi cação solução pro- veýculos de desdobramento para os tubos sem costura e autenticação heterogêneos em toda a cadeia de fornecimento de aplicativos da Web e serviços da web. Com Cofre- onde*identificar uma organização pode manipular o usuário identifi cação cen- trally e fora de todos os aplicativos da Web e serviços da web. Cofre- onde*identificar suporta qualquer tipo de autenticação incluindo tra- ponde métodos tais como nome de usuário/senha e X.509 bem como vários mecanismos de federação de identidade. Bene ts e
vantagens selecionados incluem:
eternização de autenticação. Os aplicativos e serviços de
autenticação para mover todos os Safewhere*identificar identidade bro- ker , que por sua vez se integra com qualquer e todos os
mecanismos de autenticação de
identidades federadas. Identidades de usuário são perfeitamente e
transferidas com segurança a partir de sua origem o lugar onde o usuário rst conectado à sua infra-estrutura, eliminando assim a necessidade de funcionamento e administração de um banco de dados de usuário local extranet
tradicional a autenticação do usuário. Para usuários externos não está pronto
para a autenticação federada Safewhere*identificar fornece primor- dial para bancos de dados de usuário local, permitindo assim que a alavanca para perfeita-
idade dos seus investimentos existentes em diretórios de usuário.
8




9
Figura 3. Identidade lógico de usuários da web ow aplicações
usuário delegado administração. Dãos Safewhere*identificar-
camente disposições de um banco de dados de usuário por organização para fins de Inner Authen- auten ticação Radius e manutenção de outros atributos de usuário.
Cada banco de dados pertence e é administrado por um orga-
nização.
Provedor de serviços de integração. À medida que mais e mais do seu ap
licativos utilizam a nova solução de identidade, Safewhere*identificar fornece conversão/mapeamento de identidade para conseguir transferir
identidades entre aplicativos
fornecidos como um serviço e como tradicionais de software local.
Devido à arquitetura única e em conformidade com as normas e padrões de comunicação, Safewhere*identificar pode igualmente ser aproveitado como um serviço externo (Software como serviço) ou como software instalado na sua própria infra-estrutura. Seja qual for o
escolhido não tem e a ECT em conjunto de recursos ou de segurança.
Safewhere*identificar fornece um rico conjunto de recursos com o objectivo de remover totalmente qualquer necessidade de administração local e autenticação




10
de usuários. Os principais recursos incluem:
Federação baseada em navegador. Safewhere*identificar implementa um núme-
ro de protocolos de federação incluindo SAML 2.0 e WS-russa
para autenticação baseada em navegador
autenticação federada para serviços Web aka. "ACTIVO"
russa através de WS-confiança e possivelmente WS-russa
uma instância do provedor de identidade por organização (por exemplo, cada um de
seus parceiros de extranet) prevendo a separação completa dos dados.
Os pools de aplicativos do IIS separado sob di entravarão um contas de serviço para cada instância garantir segurança muito apertada ao redor de cada orga- bial dados todos o caminho para o banco de dados e sistema de le
asserções em nível de mapeamento. Aplicativos aproveitando Safewhere*
esper- identificar todos precisamos di entravarão um tipos de atributos do usuário, ou reclamações, e muitas vezes com um pouco di entravarão um nomes e formatação. (por exemplo um papel a um aplicativo é um grupo para outro). Safewhere*identificar fornece administração delegada de mapeamentos de Atributo para trans- de maneira transparente e corretamente a identidade de transferência entre aplicações.
O autoregistro de organizações e usuários. Trabalho ows apoio
a assinatura de novas organizações por exemplo novos parceiros comerciais bem como das novas utilizações de cada organização. A rst requer a revisão e a aprovação de você considerando que este último aproveita a natureza distribuída do User Administration e deixa a
organização inicial do usuário.
2.1. IdP
o principal di erência entre este IdP e implementações padrão de IdP é que ela deve oferecer suporte a mais de uma instância . Um exemplo é um iso- culada IdP que funciona lado a lado no mesmo servidor como outras instâncias, mas sem ser acoplado a outras instâncias de qualquer outra maneira de compartilhamento de armazenamento de dados. Os sistemas host que várias instâncias do mesmo software para di er- ent os clientes são freqüentemente chamados de sistemas multitenant. Projetar um sistema para vários usuários requer considerações sobre armazenamento de dados extra layout e segurança de dados. Outra importante característica do IdP é que ela deve ser extensível de uma forma que ele pode suportar mais de um protocolo de troca de identidade e mais
de um mecanismo de autenticação.




11
2.2. Requisitos técnicos
do IdP devem ser desenvolvidos em C# e Asp.NET. Reconfiguração de dados será armazenado em SqlServer 2008. O IdP será executado no Windows Server
2003/2008 no IIS 7.
2.3. Termos
Este capítulo faz uso dos seguintes termos:
Cliente: Uma organização que tenha comprado uma instância do IdP.
Administrador: uma pessoa que administra uma única instância do IdP.
Usuário: um usuário final que usa uma instância do IdP para identificar a si mesmo com um
provedor de serviços.
2.4. Visão geral a
figura 4 mostra uma visão geral do SaaS IdP.
O gure mostra os seguintes conceitos:
IdP instâncias: o SaaS IdP contém um número de instâncias do IdP. Cada
instância do IdP pertence a um cliente, excepto para uma instância, a instância do sistema. Não há execução di erência entre o sistema IdP instância do cliente e do IdP instâncias. O sistema IdP instância é usado para autenticar os administradores quando eles efetuarem login no para administrar a
sua própria instância do IdP através do web admin.
Site Admin: o site admin atua como um provedor de serviços contra o
sistema IdP e depende de um conjunto de créditos emitidos pelo sistema IdP para determinar qual instância do IdP o administrador pertence. Sobre o site admin um administrador deve ser capaz de con gure a sua instância do IdP em um número de maneiras que será discutida mais detalhadamente a
seguir.
Website de registo: o website de registo é onde os clientes novos
podem se inscrever para os serviços prestados pelo SaaS IdP.
Armazenamento de dados pessoais: Todas as alterações feitas às configurações IdP con através do
site admin são escritos para o armazenamento de dados pessoais. Cada instância do IdP




12
Figura 4. Visão geral do IdP.
utiliza o armazenamento de dados pessoais para ler é con figuração, recuperar créditos, autenticar usuários etc o armazenamento de dados pessoais é um
banco de dados separado ou um esquema de banco de dados separado.
2.5. IdP instância
Esta seção contém as especifi cação de que dispõe de uma única instância do IdP contém. Uma instância do IdP é impulsionado por uma reconfiguração. A con figuração
principalmente especi es a seguinte ve coisas:
Credenciais: Quais tipos de credenciais são aceites.
Protocolos: quais protocolos o IdP suporte.




13
Créditos (atributos): que afirma o IdP problema.
Certifi cados de certifi cados: Qual o IdP não utilizar para assinatura e decryp Ño
e que SP certifi cados são confiáveis.
Provedores de Serviço: Quais provedores de serviço é o IdP conectado.
Figura 5. IdP instância.
A figura 5 mostra uma única instância do IdP. O IdP instância podem ser configurados para aceitar uma biela grande variedade de di entravarão um credenciais. Inicialmente, a exigir apenas- mento é apoiar o nome de usuário/senha e SAML2.0 credenciais, mas é importante que a verificação é feita na forma de credenciais tais que outros tipos de credenciais podem ser adicionadas posteriormente. A mesma exigência de ser conectável se aplica aos protocolos que o IdP suporta. O único requisito inicial é apoiar o protocolo SAML2.0, no entanto isso deve ser feito de uma forma que não impeça o futuro suporte para outros protocolos como o OpenId ou WSFederation. Como mostra a Figura 2, o IdP também podem ser configurados para emitir uma biela conjunto de di alegações entravarão um Todos os di entravarão um con figuração opções são salvas no armazenamento de dados pessoais. A maioria dos protocolos de identidade usar certifi cados para criptografia e assinatura de mensagens. Portanto a con figuração deve conter informa Òes sobre a qual estão a ser certifi cados utilizados para este efeito. O certifi cados de si devem ser armazenados em um certi pessoais cate store no Windows Server. No Windows, um certi cate store está vinculada a uma conta do sistema, a fim de conseguir ter um certifi cate armazenar para cada instância do IdP, cada
instância deve ser executado sob uma conta de usuário separada.




14
2.6. Hospedagem
Figura 6. IdP instância hospedagem.
A figura 6 mostra como uma instância do IdP devem ser implantados no IIS (Inter- net Serviços de Informações). O IdP é executado na sua própria instância do site do IIS.
Trabalhar no seu próprio Web site significa que pode ter o seu próprio nome de domínio exclusivo, por exemplo somecustomeridp.saasidp.com. A alternativa seria a de que cada instância do IdP executar em um diretório virtual do IIS e acedendo à mesma através www.saasidp.com/somecustomeridp. No entanto, a fim de ser capaz de con- gure di certifi cados entravarão um SSL para cada instância do IdP é importante que o IdP instância tem o seu próprio nome de domínio exclusivo. Um certi SSL cate sempre é vinculado diretamente a um nome de domínio. Se as instâncias foram executados em um diretório virtual, todas as instâncias seria usando o mesmo SSL certifi cate, nomeadamente a questão relativa ao www.saasidp.com. Para fazer solicitações SOAP sobre SSL para uma instância do IdP em execução em um diretório virtual exigiria confiando o SSL certifi cate pertencentes ao www.saasidp.com. No entanto, ao fazê-lo, uma relação de confiança seria implicitamente feitas para todas as instâncias do IdP no servidor. Para evitar esta situação, cada IdP instância deve ser executado em seu próprio Web site IIS e ter um nome de domínio exclusivo e portanto também um exclusivo SSL certifi cate.
Isto implicaria explicitamente confiando cada SSL certifi cate para cada instância do IdP. Outro bene t de sites IIS separado é a capacidade de vincular um site para um pool de aplicativos. Um pool de aplicativos permite-nos de ne o sistema conta sob a qual o site é executado. Se cada instância do IdP executado sob uma conta de sistema entravarão um di, podemos alcançar tendo em certi pessoais cate armazena




15
para cada instância do IdP. Por pessoais certifi cate armazena o sistema operacional garante que certifi cados no armazenamento pessoal só pode ser acessado pelo usuário para o qual a loja pertence. Além disso, pessoal certifi cate lojas oferecem uma maneira de con guring di certifi cados entravarão um trusted, algo que é importante quando da importação de certifi cados a partir de parceiros de federação. Tendo em personal certifi cate lojas exige a criação de uma nova conta de sistema para cada instância do IdP. Essa conta deve ser criada como parte da instalação de cada instância do IdP. A senha para a conta de sistema especí c deve ser gerada aleatoriamente e esquecida. Quando con guring o pool de aplicativos no IIS, a senha deve ser digitado e o recurso de lembrar a senha deve ser usada. Fazendo isso, ninguém jamais será capaz de usar essa conta para algo diferente de executar a instância do IdP e a conta será difícil de compromisso. Usando a estrutura de implementação mostrada na Figura 3, uma clara separação das instâncias do IdP é alcançado quando se trata de certifi cados e certifi cate - confiança. Este é considerado muito importante uma vez que a maioria dos
protocolos de identidade dependem de certi cate confiança mútua.
2.7. IdP instância administração
Figura 7. IdP instância administração.
A figura 7 mostra a forma como um administrador pode administrar sua instância do IdP através do site de administração. O site de administração atua como um provedor de serviços para o sistema IdP instância, na qual todos os administradores de




16
todos os cliente IdP instâncias tem uma conta. O sistema IdP emite um conjunto de reivindicações sobre as especi c administrador, a mais importante reivindicação sendo um consulte. Baseado no site de administração, consulte sabe que os dados para obter a partir do armazenamento de dados e permite que o administrador edite-los. Quando são feitas alterações, estas são guardadas de volta para o armazenamento de dados compartilhado. Os clientes que executam o IdP instância usa os dados do armazenamento de dados pessoais para buscar a
reconfiguração.
2.8. Alegação de nição de
um administrador deve ser capazes de ne um conjunto de reivindicações para o seu IdP. A
de nição de uma reivindicação contém as seguintes propriedades:
Descrição da Propriedade ClaimType o tipo de alegação, por exemplo e-mail . Existe
um conjunto de tipos de reclamação, prede nida e tipos de reclamação são
normalmente em forma de URI. Por exemplo:
dk:gov:atributo SAML::CvrNumberIdenti er
ClaimValue esta propriedade contém um valor c para a especi
reclamação. Ele é usado quando os usuários não são autorizados a ignorar o valor e quando apenas um valor c para a especi alegação faz
sentido.
DefaultValue algumas reclamações podem ter um valor padrão. Esta
propriedade permite que o administrador especifique um valor padrão
para a solicitação.
UserEditable esta propriedade especi es se ou não o
usuário será capaz de editar o valor desta alegação.
ValidationRule o administrador deve ser capaz de adicionar algum
tipo de regra de validação para o valor de uma reclamação. Isso é especialmente útil quando os valores são digitados no pedido pelos utilizadores. O IdP deve especificar um conjunto de regras prede nida, mas seria provavelmente também será útil se o administrador foi capaz de tipo em uma expressão regular atendem às
necessidades de validação especi c.




17
Figura 8. Atributo do usuário e gerenciamento.
2.9. Administração de atributos do usuário e a
Figura 8 mostra uma visão geral de usuário e gerenciamento de atributo. O gure enfoca principalmente o nome de usuário e senha caso, onde os usuários são criados no armazenamento de dados. Uma organização pode ter várias centenas ou milhares de usuários, tantos que seria inviável para um único administrador para criar todos eles. Este facto chama a funcionalidade de importação para alguns. Se partirmos do princípio de que uma empresa tem de ned reivindicações FirstName , LastName e Email . O administrador deve ser capaz de importar uma lista de endereços de correio electrónico e o IdP devem enviar automaticamente uma mensagem de correio electrónico para cada endereço, pedindo o destinatário para ir para uma página de autoregistro onde ele ou ela pode inserir um nome de usuário desejado, uma senha e o valor para as alegações de ned para a instância do IdP, neste caso FirstName e LastName . O Email reclamação será xada fora antecipadamente porque ela já é conhecida. Quando o usuário tiver xada o argumento de valores, cada usuário precisa ser aprovado pelo administrador. Ele deve naturalmente ser também possível para o administrador para criar usuários manualmente, mas isso é considerado um caso especial. Deve ser possível para um usuário para alterar o valor da sua créditos, que leva à necessidade de uma atualização página mostrada no gure como o atributo do usuário Atualizar página . Para acessar a página, o usuário apresenta suas credenciais e é apresentada uma lista dos seus créditos. Deve ser possível para o administrador de ne que as reclamações podem ser editados




18
pelos usuários e quais não podem. Esta propriedade deve ser de ned quando o pedido é de Ned. Como o gure mostra, tanto a página de registro e a página de atualização de atributo deve ser personalizável com diz respeito a olhar e a sentir que é possível para o cliente para tornar a aparência dos seus
sites corporativos.
2.10.
Grupo de grupos de créditos não são di entravarão um a partir de qualquer outro tipo de créditos. No entanto o IdP deve tornar fácil para adicionar e remover usuários de grupos. Considere um pedido de grupo com os gerentes de valor . Nos bastidores, esta alegação é apenas outro pedido no token de segurança do usuário, no entanto a administração de páginas para uma instância do IdP deve fornecer a capacidade para trabalhar com grupos em uma forma familiar. Isso envolve a listagem de todos os grupos, listando todos os usuários em um grupo e uma maneira fácil de adicionar e remover usuários de grupos. Uma vez que o grupo alegações são apenas expressos como reclamações e pedidos não têm estrutura hierárquica, grupos não são hierárquicas. Isso é importante para a nota, pois em alguns grupos de sistemas têm uma estrutura hierárquica onde um grupo pode ser um membro de outro
grupo. Este não é o caso neste sistema.
2.11. Mapeamento de sinistros
quando uma conexão com um provedor de serviços é criado, o provedor de serviço poderá especificar que requer algumas especi camente chamado reclamação. Figura 2 mostrou dois prestadores de serviço que ambos necessários um vendedor reclamação. Suponhamos que o vendedor a alegação foi um pedido de grupo com o valor vendedor .
Em alguns especi c a organização do cliente podem ter um grupo chamado SalesManager reivindicação , que é conceptualmente idêntico ao vendedor, a reclamação.
O IdP deverá permitir um mapeamento simples de sinistros de tal forma que quando um usuário que tenha o SalesManager alegação é a conexão com o provedor de serviço que exige que o vendedor alegação, a SalesManager alegação é automaticamente mapeada para o vendedor reclamação. A figura 9 mostra a ordem em que este
mapeamento de sinistros é executada.




19
Figura 9. Mapeamento de créditos gasoduto.
2.12. Registo de clientes
do IdP devem conter uma página de registro do cliente que é o ponto de entrada para o trabalho ow mostrado no gure 7. Quando um cliente quer comprar a- nizaço fornecida pelo IdP, o cliente vai para a página de registro e entra no seu dados, tais como o nome de um contato, e-mail, endereço... este dados são guardados e um representante de vendas é alertado. O representante de vendas depois contatos o usuário con rm a sua identidade e a sua intenção de comprar. Um contrato é então enviada para o cliente e quando o contato é devolvido a ordem é con- deduz do cliente e do IdP instância é criada automaticamente. Assim, o IdP deve apoiar a criação automática de novas instâncias do IdP. Este
processo automático inclui:
Criando o administrador no sistema IdP instância.
Con guring website e pool de aplicativos no IIS.
Criação SSL Certifi cado e con guring SSL no IIS.
Criação de certifi cados para criptografia e assinatura.
Enviar os detalhes de login de administrador.
2.13. Conclusão
o suporte para multi-tenancy é uma importante preocupação comercial para este sistema. No entanto, como vimos neste capítulo, o multi-tenancy aspecto pode ser resolvido pela plataforma sozinho. Arrendatário isolamento é alcançada através de um sistema de conta por usuário executar cada instância de inquilinos. Tendo em per- arrendatário conta do sistema permite que o isolamento de banco de dados por meio de separar




20
Figura 10. Mapeamento de créditos gasoduto.
bancos de dados ou esquemas de banco de dados separado, para que apenas o sistema que conta tem acesso. O mesmo vale para a certifi cate store, que, como mencionado, é também isolado em uma base por usuário. Por conseguinte, o design do software apresentado nesta tese será totalmente multi-tenancy agnóstico, sem comprometer a
procura comercial para multilocação.




Capítulo
3
Domínio de projetos orientados por
este capítulo serve como uma introdução ao design orientado por domínio. O material aqui discutida é largamente baseada no livro design orientado por domínio: abordar a complexidade no coração do software por Evans [2004]. O capítulo é no entanto não apenas um resumo do livro, mas também irá conter o meu próprio perspectivas e a exposição de exemplos fornecidos aqui será baseado no problema
à mão sempre que possível.
Antes de entrarmos nos detalhes do design orientado por domínio, vamos começar com um trecho de uma entrevista com Eric Evans, o autor do livro Domain Design orientado- (Evans [2004]). A entrevista foi interposto em
tempos de Desenvolvimento de Software (prático [2009]) em 12 de Março de 2009.
Quais são os principais aspectos do design orientado por domínio?
Eu poderia ferver em duas ou três coisas básicas. A RST é o idioma onipresente. Na maioria dos projectos, você teria di entravarão um povo a falar em línguas entravarão um di. O seu pessoal técnico irá discutir o sistema com um determinado idioma. Eles vão descrever o funcionamento efectivo do sistema da mesma forma. Eles terão palavras para as entidades que estão funcionais di das palavras utilizadas entravarão um pelas pessoas de negócios. Alguns saberão o idioma que os homens de negócios uso para atuarem como intérpretes para as pessoas da equipe técnica que não sabem que a língua. Você tem um processo dividido em partes.
As pessoas de negócios estão conversando com pessoas técnicas na coleta de requisitos e então é escrito e entregue o neste outro tipo de idioma para implementação. Isso significa que você pode nunca ter uma conversa sobre como o sistema funciona realmente. O software no interior é realmente nada como o que os homens de negócios estão
imaginando que seja.
Isso leva a problemas de usabilidade. Tradução nunca é uma coisa perfeita. Ele também dói estimativas. A forma como as estimativas trabalho é que a pessoa técnica diz, "Tenho dispõem de um recurso e B, portanto parece-me que apresentam C é uma extensão natural de A e B." a pessoa de negócios diz "Não, não, não, que é uma coisa totalmente di entravarão um e terá uma enorme quantidade de tempo." Quando de facto para o
21




22
pessoas técnicas, não é totalmente di entravarão um a partir de um
ponto de vista de implementação.
Não há nenhuma comunicação. Não há nenhuma maneira para uma pessoa não técnica para antecipar aquilo que pode ser fácil ou pode ser difícil.
Também pessoas de negócios nunca propor ideias que possam ter sido fácil
porque não é evidente que seria fácil.
Isso significa que algo tão simples como nomear suas bibliotecas e classes após o negócio tabelas eles represen-
enviados? No nível mais básico, é naming as coisas da maneira como
seria de esperar. Existem aspectos mais subtis. Com o próprio modelo de execu Ño, é um sistema de nomes e relacionamentos entre as coisas. Partilhamos desta, e quando falamos sobre isso, usamos que con- maça ̃o idioma. Quando construímos o sistema, nós permanecer fiel a esta.
Se o sistema não é construída de que forma, estamos a falar apenas de alguns c- mento. Não me refiro a esta coisa que as pessoas dizem que tomar a linguagem empresarial e a concepção e apenas fazer software re ects
.
Quais são os outros dois aspectos importantes do domínio
design orientado-? O segundo elemento é que você tem de conseguir
uma colaboração criativa entre o domínio de peritos e os peritos técnicos. É muito estreitamente relacionados e muito mais fácil de dizer do que de fazer. Você tem de começar com uma intenção de fazê-lo. Algumas pessoas são boas em ti e alguns não são. Uma das chaves para isso é no recrutamento. Você precisará contratar o tipo de pessoas que são bons, que são bons para se chegar em uma conversa proveitosa com um
domínio especializado.
O terceiro aspecto é o que eu chamo uma consciência de contexto. Aqui é uma das áreas onde eu tipo de tinha de inventar um sistema porque ninguém tinha realmente sistematizados. Dentro de um dado projecto há diversos modelos em jogo. Não estou a falar do tipo de modelos eu já falei de. Nesse subsistema falamos desta maneira e em [que] subsistema falamos dessa forma. Este não podemos eliminar. As pessoas têm tentado, e os resultados são muito pior. É
um daqueles casos em que a cura é pior do que a doença.
Em vez disso, devemos tentar compreendê-los e mapa-los. Quais são as fronteiras que de ne onde cada um se aplica? Se você dizer pot- ay e digo pot-ah-a, ne, enquanto nós sabemos onde pot-ay-a é usado e onde pot-ah-a é usado. Os projectos que
foram bem sucedidas geralmente realizados este.




23
Tendo em um idioma para descrever este e de uma terminologia e de um sistema
serve para tornar mais reprodutível.
3.1. A filosofia de design orientado para o domínio
mais projetos de software, se não todas, endereço um problema especí c. Resolver este problema também é importante para tornar o software, e por conseguinte o negócio, bem sucedida e pro tabela. A principal filosofia do design orientado por domínio é de que o principal foco de qualquer projeto de software deve ser sobre o domínio e o domínio lógica, ou seja a lógica de negócios. Isso pode soar como o senso comum, colocar em prática o livro argumenta, muitos projetos de software são demasiado centrada sobre tecnologia quando projetar seu software. Por conseguinte, o design modelos produzidos são confundidas com aspectos de somenos importância que chamam a atenção de distância a
partir de, ou ocultar totalmente a lógica de domínio, o núcleo.
Design orientado para o domínio não é um método de desenvolvimento per se, nem é ligada a qualquer método específico. No entanto, é orientada para o desenvolvimento ágil como veremos mais adiante, e inspira-se também no bem estabelecido padrões de projeto de software. Um dos principais conceitos de design orientado para o domínio é o
chamado modelo de domínio. O modelo de domínio representa uma grande quantidade de
conhecimentos contribuiu por todos os envolvidos no projecto e re ects um profundo conhecimento sobre o domínio na mão. O modelo de domínio não é um diagrama especial ou um documento ou desenho em um quadro de comunicações e é de nitely não apenas um esquema de dados. Isto não significa que a tais esquemas, documentos ou desenhos não poderia existir e eles provavelmente deve, mas eles não são o modelo de domínio como tal. O modelo de domínio é a ideia de que a combinação desses diagramas e documentos pretendem transmitir. O modelo de domínio é uma abstração de todo o conhecimento sobre o domínio, cuidadosamente organizada de uma forma que ela transmite esse conhecimento na forma mais expressiva possível, ou
como o livro coloca-o, o modelo é destilada conhecimento. Por conseguinte, o modelo
também é a espinha dorsal da língua falada por todos os membros da equipe: aos promo-, especialistas em domínio e usuários de software e testadores. Especialistas em domínio e desenvolvedores podem ter um di vista do problema entravarão um domínio. A vista do desenvolvedor muitas vezes não é tão completo como o perito de domínio e assim o modelo produzido pelo dono da obra não é tão rica e comunicativas como que do domínio do perito. É por isso da maior importância que os desenvolvedores e especialistas em domínio colaborar intensamente sobre a criação e a manutenção
do modelo. O livro se refere a esta disciplina como conhecimento avassalador.




24
conhecimento avassalador é conseguido através de brainstorming e experimentação, contínuo falar, diagramas e esboços, envolvendo experiências de sistemas atuais ou sistemas herdados e elaboração do conhecimento de especialistas em domínio e usuários atuais... Isso é importante porque a profunda e expres- siva modelos raramente mentir sobre a superfície. É portanto um conhecimento avassalador exploração extensiva do domínio e uma experiência de aprendizagem contínua.
Destilação a maior quantidade de conhecimento possível no modelo é importante porque o vazamento natural de conhecimentos a partir da maioria dos projetos de software. Profissionais qualificados e experientes programadores obter promovido, e as equipes são freqüentemente reorganizados e quando essas coisas acontecem o conhecimento é essencialmente perdidos. Mas quando uma profunda e existe um modelo expressivo, a maior parte do conhecimento é em grande medida preservados no projecto. Usando este método de modelagem também tem vários bene ts sobre métodos tais como o método de cachoeira. No método de cachoeira, o conhecimento é geralmente transmitida de especialistas em domínio de analistas e de analistas para programadores. Mas o método de cachoeira tem várias shortcom- sões, tal como alegado no [Evans 2004]. Primeiro de tudo, o método carece de feedback e o
conhecimento é potencialmente perdidos através da cadeia de informação.
3.2. Onipresente linguagem
um modelo deve ser baseado em um serviço de utilidade pública onipresente (universalmente presentes) Idioma.
Geralmente, especialistas em domínio e utilizar o jargão de negócios e equipe técnica- cêuticas usar outra, talvez mais jargão técnico. Mas o custo de overhead de tradução, para já não falar do risco de mal-entendido torna o uso de di jargões entravarão um perigoso. Assim, os princípios de projeto orientado ao domínio do estado que uma consciente e ort devem ser feitas para encorajar uma lan comum linguístico e que o modelo deve ser baseado na linguagem onipresente. Este modelo com base linguagem não deveria apenas descrever artefatos mas também tarefas e
funcionalidade e como tal vai muito mais longe do que altera os substantivos, uma
prática generalizada na modelagem. A linguagem ubíqua deve ser utilizado tanto em comunicação oral e escrita dentro da equipe e o modelo e lan- guagem são muito fortemente acoplado. Este e tornam significa que qualquer alteração para o idioma é também uma mudança para o modelo e vice-versa. Tendo em uma linguagem comum elimina a confusão que ocorre frequentemente quando especialistas em domínio e desenvolvedores usam di entravarão um termos para descrever a mesma coisa. Em [Evans 2004], Evans afirma que ele encontrou muitos desenvolvedores que inicialmente não gosta da idéia de uma língua comum porque pensam que os peritos do domínio nd
seus termos demasiado abstractas ou não irá compreender objetos mas argumenta:




25
Se sofisticado especialistas em domínio não compreender o modelo,
provavelmente há algo errado com o modelo.
Eu realmente de acordo sobre este ponto. Especialmente porque o foco do modelo deve estar no domínio comercial e não sobre os detalhes técnicos. Se um domínio perito não reconhecer o seu próprio negócio em que é suposto ser um modelo da
mesma empresa, então o modelo é por de nição não direita.
3.3. Relação entre o modelo e o código
se o onipresente linguagem é uma representação do modelo Domínio, então o código é de outra representação do que nitely mesmo modelo. É ra- guable que o código é o mais representação correcta do modelo, mas uma coisa é certa; o código é sempre o mais representação detalhada do modelo. O vital detalhes do modelo estão no código. Diagramas e documentos podem ser usados para clarificar a intenção de design ou decisões, mas eles devem representar os esqueletos de ideias e não deve ser excessivamente detalhadas. Sendo detalhado é algo que o código não particularmente bem. Acoplamento do modelo e a implementação de um início precoce através de prototipagem é muito valo- rizar. Fazer isso irá revelar inviável facetas do modelo cedo e é também uma parte importante de conseguir os desenvolvedores envolvidos no processo de design. Ao tomar parte no processo de modelagem com especialistas em domínio aos promo- melhorará a sua modelização habilidades e domínio de conhecimentos, mas especi c o mais importante a se sinta responsável para o modelo. E isso é muito importante porque os desenvolvedores devem perceber que alterando o código também alterar o modelo. Se eles não percebem isso, qualquer futuro refatoração do código irá enfraquecer o modelo em vez de a reforçar. O código deve ser escrito para restabelecer a ect o modelo de domínio em uma forma bem literal e deve utilizar a mesma terminologia na linguagem onipresente. É óbvio que cada aplicativo tem um lote da tubulação em causa com interfaces gráficas do usuário e do banco de dados e o acesso à rede e outras coisas que não são de modo algum relacionado com o domínio. Assim, a fim de alcançar o acoplamento entre o modelo e o código e para evitar que o código, uma arquitetura em camadas como
mostrado na figura 11 deve ser usado.
A Figura 11 mostra as camadas que compõem a arquitetura em camadas.
Design orientado- domínio incide exclusivamente sobre a camada de domínio, e esta é a camada
que deve conter todos os domain logic. É importante notar que os componentes de cada camada interagir apenas com outros componentes no mesmo




26
Figura 11. Uma arquitetura em camadas. A
camada ou em camadas abaixo deles. A interface de utilizador (UI) camada contém código para
interação com o usuário, a camada de aplicação contém
código c especi, tais como a gestão de longa execução de transações ou trabalho ows e nitivamente a camada da infra-estrutura contém código relacionadas ao acesso a dados, acesso à rede, registro, etc. domínio quando o código relacionado é espalhado em toda a UI, camada de infra-estrutura, etc, torna-se muito difícil de ver a lógica e a razão de domínio sobre ele. Para alterar uma regra de negócios podem exigir alterações de código em muitos di entravarão um partes do código e isso pode ser muito propensa a erros. Assim o valor de usar uma arquitetura em camadas é que cada camada pode ser especializados para gerenciar
di entravarão um aspectos do programa de computador.
Desde o design orientado por domínio trata fortemente com a atribuição de responsabilidades para a direita coloca no código, ela se torna bem para
linguagens de programação orientadas a objetos.
3.4. Blocos de construção do modelo de
projeto orientado ao domínio especi es um conjunto de objetos conceituais que devem ser usados em código para criar o modelo de domínio. Evans refere-se ao acto de concepção-
ing código componentes que compõem o modelo como modelo projeto orientado.




27
Figura 12 mostra uma visão geral desses conceitos, que serão discutidas em
pormenor no próximo.
Figura 12. Os blocos de construção de design orientado por domínio.
3.4.1 entidades
entidades são objetos que são de Ned por sua identidade em vez de pelos
valores de suas propriedades. O tempo de vida de objetos de entidade é geralmente de longa, e os valores de suas propriedades pode alterar muitas vezes ao longo do tempo considerando que a identidade
não muda. Um exemplo de uma entidade objeto pode ser um objeto de usuário.
Considere um objeto de usuário com propriedades ID, Nome de usuário e
UserAttributes CreatedDate como mostrado abaixo.
1 public class User{
2 3 Guid _id;
4 privado de string _lastName;
5 privados DateTime _createdDate;
6 privados IEnumerable <Attribute>_userAttributes;
7 8 usuário público(Guid id,




28
9 string lastName,
10 createdDate DateTime){
11._ID = ID;
12._lastName = lastName;
13._createdDate = createdDate;
14 }
15 16 Guid público UserId{
17 obtenha retorno userId;}{
18 }
19 20 seqüência pública LastName{
21 obtenha{retorno _lastName;}
22{_lastName = valor;}
23 }
24 25 público DateTime CreatedDate{
26 obtenha{retorno _createdDate;}
27 }
28 29 IEnumerable público <Attribute>UserAttributes{
30 obtenha{retorno _userAttributes;}
{_userAttributes 31 set = valor;}
32 }
33 34 substituições público bool é igual a outro usuário){(
35 voltar este.UserId == Outros.UserId;
36 }
37 }
embora dois objetos de usuário têm o mesmo sobrenome, eles só são
idênticos se a ID do usuário é a mesma. Dois objetos pode mesmo representar o
mesmo usuário independentemente que LastName não são idênticos enquanto o UserId é
o mesmo, por exemplo, se o usuário alterou seu sobrenome. Assim, aquando da implementação de objetos de entidade, é importante implementar funções de igualdade de tal forma que a igualdade de dois objetos é baseada na comparação de identidade em vez de comparar as propriedades individuais do objeto, uma vez que estes
podem e provavelmente irá mudar ao longo do tempo. TheEquals método acima é um
exemplo de uma implementação. A identidade do Estadosbene uma entidade objeto é muitas vezes gerado automaticamente como seria o caso no exemplo
do objeto de usuário. A identidade po (UserId) nem sempre é importante para
o usuário do sistema, mas poderia ser, por exemplo se o id foi um
número de segurança social ou o número de rastreamento de pacotes.




29
3.4.2 os objetos de valor dos
objetos de valor, ao contrário dos objetos de entidade, são objetos que não têm um
ID exclusivo Objetos de valor são freqüentemente usados para descrever as entidades e nos preocupamos
com eles apenas para aquilo que eles não são quem eles são. Um bom exemplo de um objeto de valor pode ser um objeto de dinheiro como o abaixo. Depois de todas as dez dólares
são dez dólares não importa o quê. Normalmente não se preocupam com a identidade dos dez dólares (a menos que naturalmente estamos procurando dinheiro roubado) mas apenas
o valor que eles representam.
1 classe pública dinheiro{
2 3 int quantidade;
4 moeda Moeda privada;
5 6 dinheiro público(int Montante, moeda moeda){
7 este.montante = montante;
8.currency = moeda;
9 }
10 11 público int Quantidade{
12 e obtenha retorno montante;}{
13 }
14 15 Moeda Moeda pública{
16 obtenha retorno moeda;}{
17 }
18 19 dinheiro público Add(Dinheiro outros){
20 // certifique-se de moeda é o mesmo
21 // Adicionar montantes
22 // retorno de dinheiro novo objeto
23 ...
24 }
25 }
Note que os objetos de valor, tais como o dinheiro classe são por de nição
imutável, o que significa que após a criação das propriedades do objeto não pode
ser alterado. Quando a adição de dinheiro objetos, novos objetos são criados em vez de
alterar qualquer um dos objetos sendo adicionados. Isso mantém a imutabilidade
dos objetos.
3.4.3 Serviços Os
serviços são as classes que implementam lógica de domínio que não ser naturalmente ao
longo de uma entidade ou um objeto de valor. A interface do serviço deve ser de nida no




30
termos de outros elementos do modelo de domínio e nomes de seu funcionamento deve ser parte da onipresente linguagem. Classes que implementar serviços devem ser apátrida. Na prática, os apátridas classes são freqüentemente composto por static meth- ods que não precisam de uma instância da classe para ser invocado. Um
exemplo de um serviço em nosso domínio do problema pode ser um CertificateService
com operações como CreateCertificate e RevokeCertificate. Uma vez que
a noção de um serviço é amplamente utilizado em ciência da computação em geral eu sinto que é importante esclarecer que um serviço em termos de design orientado para o domínio não deve ser confundido com um serviço como serviço na web. Isso não significa que um sistema construído com design orientado para o domínio não deve expor para serviços de web, no entanto, quando utiliza o design orientado por domínio e camadas de ar- chitecture, um serviço web seria parte da camada de aplicação e não fazem parte
do domínio camada. Em termos de CertificateService mencionado acima,
um serviço web poderia ser criada na aplicação e a única responsabilidade da web-serviço seria para digerir a entrada XML e delegar a chamada
para o CertificateService no domínio camada.
3.4.4 Agregados
agregados são clusters de objetos associados que são trabalhadas como uma
unidade quando se trata de alterações de dados.
Figura 13. Um agregado.




31
Figura 13 mostra um agregado composto de um objeto de usuário com vários
objetos de atributo. Objetos de atributo só são interessantes para modificar no contexto de um usuário e não fazem sentido fora do contexto de um usuário. Neste
exemplo, o objeto de usuário é dito ser o agregado raiz, o que significa que
é o ponto de entrada principal ao acessar os objetos que compõem o agregado. Agregados podem ter apenas uma raiz agregada, mas o valor agregado em
si pode ser muito mais complexo do que o mostrado aqui.
3.4.5 repositórios
a finalidade de um repositório é buscar e salvar as entidades e objetos de valor a
partir de um armazenamento de dados. O repositório deve ocultar todos os código de banco de dados e dar a ilusão de que todos os objetos estão na RAM. O seguinte é o esqueleto de um
repositório:
1 classe pública : IUserRepository UserRepository {
2 3 usuário público este[Guid userId] {obtenha{ ... }}
IEnumerable público 4 5 <User>FindByLastName(string lastName) ...
6 7 IEnumerable público <User>FindRecentlyCreated() ...
8 9 IEnumerable público <User>FindAllUsers() ...
10 11 public void AddUser(User newUser) ...
12 13 ...
14 }
o repositório acima nos permite buscar objeto aUser por uma ID exclusiva, altera todos
os usuários com alguns sobrenome e ele também nos permite adicionar novos utilizadores. Todos esses métodos realmente implementar algum tipo de lógica de domínio no que respeita aos usuários.
O FindRecentlyCreated método poderia ser usando uma instrução SQL como
selecionar firstname, lastname de usuários onde createdDate &gt; :createdDateThreshold
(onde :createdDateThreshold seria um parâmetro). Mas esse
comando SQL exprime a lógica de domínio a fim de se não ter um lugar central para colocar esta função, instrução SQL que poderiam potencialmente ser duplicado muitos lugares no código, tornando mais difícil a mudança da lógica de altera os usuários criados recentemente, se por algum motivo a de nição de recentemente criados teriam de mudar. Outro bene t de repositórios utilizando é que elas podem ser feitas inter-
mutável. Implementando theIUserRepository e referenciar con-
creta instância apenas por meio de sua interface, separar especi c- penhar




32
ções do repositório pode ser facilmente trocados. Isto é especialmente uso- guma para teste. Um sistema live normalmente obtém seus dados a partir de grandes bancos de dados e replicar esses bancos de dados para um servidor de desenvolvimento pode ser tanto consome muito tempo e às vezes até mesmo impossível. Especificando a classe concreta que implementa o repositório em alguns con figuração externo le pode tornar fácil para alternar entre o ambiente ao vivo e um desenvolvedor ou
ambiente de testes 1 . No nosso exemplo atual poderíamos imaginar uma alternativa im-
R ealização do IUserRepository, chamado InMemoryUserRepository, que
poderia ser usado para buscar o detonador inerte instâncias da classe de usuário, assim facilitat-
ing meios de testar vários aspectos do código sem ter que acessar o banco de dados de produção. No entanto, quando usando essa abordagem, é importante que os desenvolvedores a compreender a implementação do repositório a ser utilizado.
Por exemplo, se alguém foi para escrever um método para contagem de todos os usuários no
sistema a função FindAllUsers poderiam ser utilizados e o método de contagem do
IEnumerable <User>Poderia ser usada para retornar o número de usuários. Isso
provavelmente executar muito bem com um detonador inerte repositório otratadoexigequeadefiniçãoeaexecuçãodetodasas retornar apenas um número limitado de utilizadores. No entanto, quando usando um repositório real aplicação que acessa o banco de dados de produção e de realizar a contagem de ect desta forma seria que todos os usuários no banco de dados serão carregados na memória apenas para a contagem das mesmas. Seria muito provável que execute o mal, sublinhando, assim, por que razão é importante que
os desenvolvedores a compreender a execução de funções de repositório.
No capítulo 5 I irá discutir a forma de mapas ou pode ser aproveitado para criar
repositórios muito facilmente mesmo para banco de dados complexo esquemas.
3.4.6 Especi cações
Specificationsprovide um meio de encapsulamento e mais importante nam-
ing aquelas pequenas expressões Booleanas que tendem a aparecer na maioria dos programas mas cuja finalidade e ou significado com relação à lógica de negócios pode ser difícil gure. Uma especi cação é uma classe com apenas um método chamado |IsSatis edBy|. O método tem um tipo de retorno booleano e o argumento do método depende do tipo de objeto é uma especi cação. Se continuarmos a
nossa classe de usuário do exemplo acima, poderíamos imaginar a necessidade para
determinar se uma determinada instância de classe está documentadono foi criado recentemente. O termo
recentemente é escolhida de propósito porque é unspeci c e de nitely contém
1 Este conceito é na verdade um padrão de projeto bem estabelecido, muitas vezes referido como estratégia
ou política. Ver [Gamma et al . 1995]




33 a
lógica de negócios com relação ao nosso exemplo corrente. Suponhamos que a de nição de um recentemente criado é que ela foi criada nos últimos dez
dias.
1 usuário u = ...
2 Se(u.CreatedDate &gt; DateTime.Now.AddDays(-10)){
3 ...
4 }
o trecho de código acima mostra uma maneira de determinar se aUser foi criado
recentemente. No entanto, su ers a partir de dois graves inconvenientes. Primeiro de tudo o que não é muito expressivo, o que significa que sem código observações não transmitir ao leitor que a regra de negócio é verificar. Além disso, se a mesma verificação foi necessária em outro lugar, o código teria de ser duplicado, levando
a manutenção extra se o critério nunca mudou.
1 //especificações de classe que determina se um usuário tiver
2 //sido recentemente criadas
3 4 public class RecentlyCreatedSpecification{
5 estáticos públicos bool IsSatisfiedBy(u){
6 usuário retornar u.CreatedDate &gt; DateTime.Now.AddDays(-10);
7 }
8 }
o trecho de código acima é uma classe que implementa o recentemente criado a lógica de negócios. Agora se fosse para utilizar esta especi cação no código ela poderia procurar
algo como o seguinte:
1 usuário u = ...
2 Se(RecentlyCreatedSpecification.IsSatisfiedBy(u){
3 ...
4 }
o código acima exemplo mostra como o código resultante é muito mais ex- desequilibro em termos do que regra comercial é marcada, e além disso temos criado um único espaço reservado para a lógica de negócios, tornando fácil de manter.
Poderia ser argumentado que o que é realizado pela especi cação neste exemplo
poderia muito bem ter sido colocado em uma função na classe de usuário. Esta
observação é provavelmente certo para este exemplo muito simples. No entanto, uma classe
com um lote de infracções principais funções como IsRecentlyCreated facilmente se torna muito
grande. Além disso, um poderia facilmente imaginar casos em que o próprio objeto
não contém todas as informações necessárias para verificar o estado.




34
3.4.7 Fábricas
o design de fábrica padrão é amplamente utilizado em um projeto orientado a objetos. A
analogia do objeto de fábrica é que às vezes a construção de um objeto é demasiado complexo para o próprio objeto para executar e precisa de ser criado em uma fábrica. Um importante bene t de usando fábricas em oposição a con- structors é que os métodos das fábricas podem ter tipos de retorno de resumo ou devolver alguns implementação de uma interface. Desta forma, o utilizador do método de fábrica não precisa para fazer referência ao tipo de concreto do objeto que é retornado, o que torna a mudança ou substituir esses objetos- minados transparente para o chamador. As fábricas não devem ser utilizados para tudo. Objectos simples que não implemente uma interface comum ou utilize polimorfismo provavelmente não deve usar as fábricas de sua construção.
Tenho visto exemplos de pacotes de software de fonte aberta (como OpenSAML OpenSAML [2009]) onde até mesmo o mais simples dos objetos tinham que ser criado através de uma fábrica. A utilização excessiva de fábricas pode realmente obscuro simples ob- rejeita e fazer o usuário pensar que o objeto é mais complexa do que ele realmente é. A propriedade mais importante dos métodos de fábrica é que eles devem ser atomic. Isto significa que tudo o que é necessário para construir o objeto deve ser passado para a fábrica de modo a que a construção pode ter lugar em uma única interação com a fábrica. Além disso, é importante que a fábrica garante que todos os invariante para o objeto que está sendo criado são satisfeitas. Isso não significa que a lógica que verifica estas invariantes devem ser movidos para fora do objeto que está sendo criado, mas não significa que a fábrica deve certificar-se de invocar esta lógica antes de retornar a instância do objeto em questão. Fábricas utilizadas para construção de objetos de entidade devem comportar di erently ao criar novas instâncias de um objeto em vez de criar uma instância do objeto reconstituído. O mais importante de fábricas não deve atribuir automaticamente novos ids para objetos de entidade quando eles são reconstituídos, porque se fizeram, a continuidade do que determinado objeto seriam quebradas.
3.4.8 Módulos
o conceito de módulos é utilizada para agrupar conceitos relacionados a partir do modelo,
por exemplo todas as classes de usuário contendo relacionados lógica, em pacotes conceitual. Um
2 módulo pode ser uma dll ou simplesmente um namespace dentro de uma DLL. Como com
tudo o resto no modelo de domínio, nomes de módulo devem fazer sentido em
2 ou .jar, .lib ou qualquer equivalente é o considerado pela tecnologia usada.




35
termos da onipresente linguagem. Determinar se a utilização da dll individuais ou apenas namespaces dentro que a dll provavelmente deverá ser baseada no número de classes envolvidas embora não detalhes são o rido no [Evans 2004].
3.5. Refatoração
quando partimos para escrever software nunca sabemos tudo sobre o principal. Por isso é importante para tornar o projeto aberto a refatoração e alterar essas de que novos conhecimentos podem ser facilmente incorporados no design quando for detectado. Um sistema que não tem um bom design não incentivar os desenvolvedores a aproveitar o código existente quando refatoração, conduzindo assim a remeta- cate código. Da mesma forma, o Monolithic Design elementos também impedir a reutilização do código, apenas como elementos de design com confusa ou equivocada nomes podem conduzir a utilizados de modo incoerente por di entravarão um desenvolvedores. De facto, a falta de um bom projeto pode parar completamente refatoração e iterativa re nement desde os desenvolvedores terão pavor ao mesmo olhar o código existente e eles vão ter medo de fazer alterações, visto que uma alteração à actual confusão pode quebrar alguns imprevistos de dependência ou apenas agravar a confusão, Evans argumenta. No orientado por domínio de assinar um projeto que se torna bem a refatoração e iterativa re nement
é chamado um design flexível. Não existem fórmulas exatas para alcançar um
design flexível, mas Evans o ers um conjunto de padrões que poderiam levar a ele. Esses padrões
são mostrados na Figura 14, e será discutido em pormenor na presente secção.
3.5.1 Intenção-interfaces revelando
a palavra interface na intenção de revelar interfacesshould não pode ser confundido
com o keywordinterface como conhecidos a partir de muitos linguagem de programação. Neste
contexto, a palavra interface refere a nomeação de todos os elementos de um artefato de software. Por conseguinte, classes, operações e nomes de argumento deve ser chamado de uma forma que revela a ect e com finalidade e Os nomes devem no entanto não contêm qualquer informação sobre a forma como a ect é alcançado. e Um ex-
amplo de uma intenção revelando método poderia ser theAddUser(User newUser) da
função de UserRepository discutido na Seção 3.4.5 na página 31. O
nome do método revela que o método adiciona um usuário e que o argumento deve ser um novo usuário (em oposição a um já existente). Deveria ser óbvio que a nomeação de este método e o parâmetro mutila Ño mais
reveladoras do que por exemplo Criar usuário(u). Por serem explícitos sobre




36
Figura 14. Padrões que contribuem para um design flexível.
o que o método faz e o que seus parâmetros são o risco de alguns de- veloper involuntariamente usando o método para algo mais do que a sua intenção é minimizada. Em [Evans 2004], Evans dá o seguinte exemplo de um motivo de
intenção revelando interfaces são importante:
Se um desenvolvedor deve considerar a implementação de um componente para usar, o valor de encapsulamento é perdida. Se alguém que não o desenvolvedor original deve inferir a finalidade de um Objeto ou operação com base na sua implementação, que novo revelador pode inferir uma finalidade que a operação ou classe ful lls apenas por acaso.
Se isso não era a intenção, o código pode trabalhar para o momento, mas a base conceitual do projeto irá ter sido corrompido, e os
dois desenvolvedores será o trabalho com efeito.
3.5.2 de lado e ect livres de
um lado e a ECT normalmente significa alguma consequência involuntária, mas no con- texto da ciência da computação em geral e design orientado por domínio especi camente, uma lateral e a ECT significa uma alteração no estado de um sistema. Evans afirma que geralmente existem dois tipos de funções entravarão um di em um sistema. As funções que o sistema de consulta de dados e funções que alteram o estado do sistema. Evidentemente,




37
alterações de estado do sistema não pode nem deve ser evitada por si. No entanto,
consoante o lado de efeito de padrão de funções livre, estes dois tipos de ser-
haviors não devem ser misturados. Isto significa que os dados de retorno de funções que não deve alterar o estado do sistema em qualquer modo observáveis. Da mesma forma,
funções que alteram o estado do sistema não deve retornar dados.
3.5.3 afirmações
como a que acabamos de discutir na seção anterior, lateral e ects pode ser
evitado. O padrão de afirmações em conjunto com intenção revelando
interfaces torna ainda mais explícito aquilo que o lado e a ECT uma função.
Isto é conseguido através de um conjunto de pré e pós-condições que deve sempre ser satis ed antes e depois da invocação de uma função. Ele nem sempre fazem sentido para o código o pré e o pós-condições como parte do programa devido a sobrecarga de desempenho ou falta de apoio na linguagem de programação, assim se for esse o caso, as afirmações devem ser incluídas na unidade de testes automatizados
e na documentação do programa.
3.5.4 Os contornos conceituais
contourspattern conceitual se esforça para obter uma granularidade
de funções, classes e interfaces do modelo. Evans afirma que nenhuma granularidade irá t tudo no nosso modelo de domínio, em vez de usar uma abordagem ingénua onde cada função ou classe é limitada a um xo número de linhas de código ou similares, a granularidade deve ser baseada no que a função ou objeto conceitualmente alcança. Assim, segundo o padrão de contornos conceituais, cada objeto deve ser um todo o conceito, nada mais e nada menos. Da mesma forma, cada função deve realizar algo significativo por direito próprio, mas que não deve abranger várias operações conceituais. Como
exemplo deste último, Evans afirma que no botãoadicionar () função não deve ser dividida
em duas funções separadas. Da mesma forma no botãoadicionar() e subtraia()
funções não devem ser combinados em um único. É evidente que não existe uma receita simples para alcançar os contornos conceituais, e portanto a decomposição dos elementos de design em unidades coesa é algo que deve ser baseada na intuição e o que deve ser esperado para ser submetida a muitas mudanças ao longo do tempo
até que uma boa granularidade foi alcançado.




38
3.5.5 classes autônomo
o padrão chamado classes independente gira em torno da redução de acoplamento
entre objetos. O objetivo desse padrão é o acoplamento para alcançar baixas sempre que possível porque torna o modelo mais fácil de compreender. Evans defende que cada dependência que uma classe tem torna a classe mais complexa e a relação entre a classe e suas dependências têm que ser entendidas para compreender totalmente a classe. Por conseguinte, classes com acoplamento de baixa são mais fáceis de compreender. É evidente que o padrão de classes independente ao extremo nos deixa com um (inútil) modelo onde tudo é reduzido a um primitivo. No entanto, é importante para reduzir o número de interdependências entre as classes, especialmente aqueles que não são essenciais para
o conceito.
3.5.6 Encerramento das operações
o nome de fecho operationscomes da matemática. Em matemática,
a operação de adição é fechado sob o conjunto de números inteiros, por exemplo 1+2 = 3. A
adição de dois números inteiros rendimentos outro número inteiro. Esta propriedade pode ser usado ao se projetar um bom modelo, uma vez que não introduz novos conceitos e é mais fácil de compreender. Em geral, o encerramento das operações padrão é utilizado principalmente para tipos de valor e não tão frequentemente para entidades. Porque o ciclo de vida de uma entidade não é natural que uma função em uma entidade iria retornar outro exemplo dessa entidade. No entanto, tipos de valor pode muitas vezes têm funções que s er encerramento das operações. Um exemplo de um tipo de valor que
tem uma função com o encerramento das operações é o dinheiro classe apresentados na
Secção 3.4.2 na página 29. Sua função adicionar é fechada nas instâncias da
classe de dinheiro.
3.6. Integridade do modelo
construir grandes sistemas frequentemente envolve várias equipes de desenvolvedores que de desenvolver cada um a sua parte do sistema. É de extrema importância que estas equipas têm uma compreensão partilhada do modelo de tal forma que a média de cada conceito no modelo é o mesmo para todas as equipes. Se não for este o caso, classes que representam um conceito para uma equipe poderia potencialmente represen- enviou um di entravarão um conceito para outra equipe, conduzindo assim a utilização abusiva dessa classe




39
e no final talvez o comportamento com defeito no sistema. No âmbito desta tese, o sistema que está sendo desenvolvido é desenvolvido apenas por este autor, nev- ertheless, os padrões de projeto orientado ao domínio que a integridade do modelo de endereço ainda são interessantes para descrever, não menos porque o futuro a manutenção do sistema sendo projetado pode ter de ser executadas por mais do que um por- filho ou equipe, mas também porque alguns desses padrões são úteis para modelagem em geral. Os padrões usados para manter a integridade do modelo, conforme descrito
pelo projeto orientado de domínio são mostrados na figura 15.
Figura 15. Padrões de integridade do modelo.
3.6.1 delimitada contexto
em grandes projectos com várias equipes trabalhando no mesmo sistema pode se tornar claro se ou não as equipes estão trabalhando no mesmo modelo.
As equipas podem ter a intenção de trabalhar no mesmo modelo e partilham o código. Mas por vezes os sistemas são demasiado grandes para um único modelo de existir uni ed, especialmente quando a comunicação entre equipes não é tão boa quanto poderia ser.
Tendo em uma grande uni ed modelo requer uma boa comunicação e processos para detectar con icting interpretações do modelo. A fim de superar este





problema 40, Evans argumenta que por vezes pode ser bene ciais para dividir o código
e modelo em vários contextos delimitada. Um contexto delimitada é um explícito
de nição de um contexto em que um determinado modelo se aplica. Uma vez que um número de contextos têm sido delimitadas de ned, as fronteiras destes contextos pode ser explicitamente de ned em termos de utilização dentro do aplicativo, código base etc., assim sendo capaz de alcançar um modelo puro dentro do contexto delimitada. Usando delimitada contextos torna explícita para os desenvolvedores que estão trabalhando em di e modelos entravarão um é elimina o risco de que di entravarão um equipes vão pensar que eles estão trabalhando em um modelo uni ed quando na verdade eles estão
trabalhando em conceitualmente modelos divergentes.
3.6.2 Integração contínua
integração contínua é uma prática bem conhecida que visa acelerar os
tempos de entrega e diminuir o tempo de integração no desenvolvimento de software.
Design orientado por domínio leva o conceito de integração contínua mais um passo, nomeadamente por não somente focando a integração contínua do código, mas também sobre a integração contínua de alterações de modelo. Como oposição à integração contínua do código, a integração contínua de um modelo não é algo para o qual um conjunto de processos automatizados existe. Por conseguinte, integração contínua do modelo é algo que deve ser alcançado por discutir o modelo e continuamente incansavelmente o exercício da linguagem onipresente a fim de reforçar a visão compartilhada do modelo e para evitar que os conceitos evoluem di erently na cabeça dos desenvolvedores. Integração contínua do código é evidentemente algo que deve ter lugar em paralelo com a integração contínua do modelo. Isso deve acontecer através de compilações automatizadas e testes automatizados. Um bom conjunto de testes automatizados devem tornar mais confortável para os desenvolvedores Refatorar código existente porque executando os testes automatizados, eles saberá instantaneamente se algo está quebrado ou não
pela mudança que fizeram.
3.6.3 Contexto mapa
quando trabalhar com um número de contextos delimitada, um contexto mapa serve
o objectivo de criação de uma visão global de todo o sistema e de ning a relação entre o di entravarão um delimitada contextos. A relação ser- tween delimitada contextos muitas vezes envolve algum tipo de mecanismo para traduzir os dados entre delimitada contextos. Contexto mapa pode ser um diagrama ou um





documento de texto 41 ou ambos, e é importante que todos os envolvidos no desenvolvimento do sistema conhecer e compreender o contexto mapa e que os nomes de cada vinculado contexto descrito no contexto mapa introduza o
idioma onipresente.
3.6.4 kernel compartilhado
um kernel compartilhado é essencialmente uma parte do modelo que é usado em mais
de um contexto delimitada. O óbvio bene t de ter um kernel compartilhado é que a reutilização do código entre as equipes podem ser maximizadas. O kernel compartilhado muitas vezes representa o núcleo do sistema de domínio e/ou um conjunto genérico de subdomínios, mas pode ser qualquer parte do modelo que é necessário fazer por todas ou algumas equipas.
Fazer alterações ao kernel compartilhada exige a consulta com todos os seus usuários de
tal forma que o modelo de integridade do kernel compartilhada não está quebrado.
3.6.5 As equipes de desenvolvimento de cliente/fornecedor
o cliente/fornecedor padrão de equipes de desenvolvimento sugere que quando
existe um relacionamento entre duas equipas onde uma equipe gera o código que a outra equipe está dependente, em seguida cada equipe deve trabalhar dentro de seu próprio contexto delimitada. Isso torna mais fácil de ne responsa- bilidades e resultados e o desenvolvimento conjunto de testes de aceitação irá
validar se estas tiverem sido respeitadas.
3.6.6 conformista e
por vezes um dos contextos delimitada em um sistema é um componente de prateleira o -com uma grande interface. Quando for este o caso, Evans argumenta que um padrão
chamado o conformista padrão deve ser usado. O Conformista padrões diz
que para estar em conformidade com o modelo representado pelo contexto delimitada represen- tantes o -prateleira componente. O raciocínio que está por trás disto é que se existe uma necessidade real de um elemento externo, então esse componente provavelmente rep-
3 se ressente conhecimentos valiosos e provavelmente tem um modelo bem pensado .
Por conseguinte, em conformidade com o modelo do componente é normalmente uma boa ideia
3 Evans argumenta também que se este não for o caso da utilização de que o componente deve ser
seriamente questionada.




42
Porque menos tradução entre conceitos é necessário e porque a pos- sibilidade de serem arrastadas para uma melhor concepção existe. O Conformista padrão
é mais importante quando a interface com o componente é grande.
3.6.7 Camada de
interface com a anticorrupção sistemas legados é muitas vezes uma necessidade por uma ou outra razão.
O sistema antigo pode estar fraco modelo ou um modelo que não t o
projeto atual. Quando este for o caso, o padrão de camada anticorrupção pode
ser usado. Uma camada de anticorrupção é uma técnica onde os sistemas herdados são isolados através de classes e funções que honra o modelo atual e oculta qualquer conversão e tradução lógica do modelo atual para o modelo do sistema herdado. Uma camada de anticorrupção muitas vezes é composta de um número de serviços que têm responsabilidades em termos do modelo atual e
use a fachada e internamente os padrões de adaptador conforme descrito em [Gamma et
al . 1995]. A fachada é uma interface que simpli es acesso para o cliente, tornando assim o subsistema mais fácil de usar e um adaptador é um wrapper que é utilizado
para transformar as mensagens a partir de um protocolo para outro.
3.6.8 formas distintas
por vezes o bene t de integração de contextos delimitada é pequena, e portanto
não pode ser útil. Os padrões de formas distintas podem ser usados quando
é esse o caso, permitindo assim que os desenvolvedores a nd simples e soluções especializadas
dentro de um pequeno âmbito.
3.6.9 Abrir serviço de acolhimento
às vezes um subsistema tem de ser usada por muitos contextos delimitada, e mak- ing personalizadas tradutores entre todos os subsistemas e todos os contextos delimitada pode ser demorado e difícil de manter ao longo do tempo. Assim em vez
de fazê-lo, o open host padrão do serviço pode ser utilizado. O open host suário-
vice-padrão é cerca de ning um protocolo que dá acesso ao subsistema e que podem ser utilizados de forma uniforme por todos os contextos delimitadas usando o subsistema.




43
3.6.10 publicado
por último, a publicação idioma língua leva o open host padrão de serviço para o
próximo nível de de ning um procedimento formal de linguagem comum para o serviço. Um exemplo
de um idioma publicados neste contexto podem ser SQL ou XML.




Capítulo
4
De ning o modelo
neste capítulo I vai de ne um modelo do software que foi especi ed no capítulo (2). Projeto orientado no domínio do modelo é constituído tanto o código e todos os documentos que descrevem o que o sistema faz e que partes do sistema são responsáveis por fazer o que. No entanto, orientado por domínio design também salienta que o modelo deve ser entendida pela (normalmente) não técnicos especialistas em domínio. Portanto, o objetivo deste capítulo é apresentar o modelo a partir de um ponto de vista que não é excessivamente execução especi c. Vou usar termos como classes, interfaces e funções, mas omontantedereferênciafinanceiraparaaexecução detalhes serão deixados para os seguintes capítulos (5, 6 e 7). Para além de apresentar o modelo, o objectivo das seções a seguir é também para ilustrar o processo iterativo envolvidos no projeto orientado ao domínio. Por conseguinte algumas sec Òes podem incluir uma refatoração sub-seção. Você pode argumentar que em vez de ter uma refatoração sub-secção I poderia ter realizado a refatoração imediatamente. Este não é contudo ilustram o processo iterativo que é uma das pedras angulares da designas orientado por domínio bem e por isso escolhi
o sub-seção abordagem.
Na seguinte vou consultar o software como um todo como o IdP , e a pessoa que administra o IdP o administrador (ou um administrador desde que pode haver vários). É importante notar que neste contexto o administrador é um cliente de software, administrando uma única
instância do IdP.
4.1. Figura notation
qualquer modelo é fortemente acoplada ao os dados que ele representa e para a maioria das aplicações e este em particular, em que os dados são armazenados em um banco de dados.
Por conseguinte, parece natural para apresentar o esquema de dados juntamente com o modelo. Uma vez que tenho grande foco no idioma onipresente vou nomear meu tabelas da base de dados e as classes que encapsulam a cada linha em uma tabela determinada
entidade (ou seja a objetos) o mesmo.
A Figura 16 mostra um modelo conceito chamado SomeConcept imaginária que
44




45
Figura 16. Figura explicação
tem atributos chamado SomeConceptAttribute. O esquema mostra mostra
todas as propriedades dos dados de cada um desses dois conceitos. Ela também mostra o pri- chave de Maria, que é indicado por um símbolo de chave pequena ao lado da propriedade.
Exibição de Esquema também mostra os relacionamentos entre as classes. Por exemplo,
a seta no gure indica que um SomeConceptAttribute é acoplado a um
SomeConcept. Na verdade, o SomeConceptId é uma referência para o OID de alguns em
posição de SomeConcept-. Eu uso um rigoroso convenção de nomenclatura para estas referências,
tais que é sempre deve ser fácil de inferir quais as referências de propriedade
da outra classe theOID. Eu uso o OID (curto para id de objeto) como uma chave primária para todos en-
lação de objetos. Além de ser a convenção de nomenclatura que seja fácil de lembrar e fáceis de reconhecer, usando esta convenção de nomes é útil na execu-




46
cação como veremos no Capítulo 5. Por favor note que eu não quis mostrar todas as relações de uma determinada tabela em schema view. Por exemplo, quando no- troducing um novo conceito não vou mostrar relacionamentos com as coisas que ainda não foram introduzidos. Da mesma forma, quando da introdução de novos conceitos que expandir algo que já foi mostrado, não vou mostrar relações que já foram explicadas. Eu geralmente explicar o tipo e o significado de todas as propriedades a menos que sejam auto-explicativa são idênticas às anteriormente explicado propriedades. O modo de exibição de classe por outro lado mostra funções adicionais, se houver, das classes. Vou explicar todos os métodos e os seus parâmetros de- dores onde eu o considerem necessário para a compreensão de sua finalidade. Modo de exibição de classe também mostra o tipo de classe de cada classe é em termos de design orientado por domínio. Isso é indicado em itálico acima de cada classe. Na classe de exibição, você pode presumir que todas as propriedades que existiam no esquema visualizar ainda lá estão, mas eles não são mostradas em ordem a manter a gure mais simples. Podem por vezes ser propriedades no modo de exibição de classe de classes, mas se houver, estas propriedades serão denotar algum tomografia propriedade que não é uma parte do esquema de dados. Note também que algumas classes não são parte do esquema de dados em todos os, e portanto elas podem ter propriedades não-tomografia. Você também pode assumir que as relações indicadas por setas na exibição de esquema ainda existem no modo de exibição de classe. Como uma
questão de facto, Figura 16 você pode presumir que eachSomeConcept classe possui
uma (possivelmente vazia) lista de instâncias SomeConceptAttribute (tecnicamente estas
são referências a instâncias), e que cada instância SomeConceptAttribute
tem uma instância (referência a uma instância de uma classe SomeConcept). Finalmente,
pode haver setas azuis entre as classes no modo de exibição de classe que denota algum tipo de relacionamento entre as classes. Esta natureza da relação é explicada com algum texto abaixo ou acima da seta, como exemplificando no ed no
gure.
A Figura 17 mostra a convenção para as interfaces e classes abstratas em modo de
exibição de classe. Por exemplo, ISomeInterface representa uma interface (nota a
cor verde), enquanto, SomeClass é uma classe que implementa essa interface, denotado
pelo círculo e o nome da interface acima da classe. Uma classe abstrata, tais como
SomeAbstractClass tem linha pontilhada ao redor dela e a classe
que herda SomeAbstractClass SomeOtherClass, tem uma seta para a classe e uma pequena seta
com o nome da classe base próximo a ele.
Tenho agora introduzida a notação gure que vai ser utilizada em todo o presente capítulo, e é tempo de olhar para os principais conceitos do
modelo, que são:




47
Figura 17. Figura explicação
Plug-ins con figuração certifi cados de usuários fornecedores de credenciais Protocolos Ligações alega o runtime eventos
por favor note que escolhi para introduzir relato de eventos como uma das últimas coisas, desde como um conceito que não é tão central como os outros. Eventos neste contexto é o registro de erros e de outras atividades no sistema. Vou consultar o registro e o rastreamento antes de introduzirem realmente a parte do modelo
que descreve-los, que você pode nd na secção 4.12.




48
4.2. Um sistema extensível de
uma das mais importantes propriedades do sistema é que ele deve ser exten- gações em duas áreas, nomeadamente na forma como um usuário apresenta suas credenciais e nos protocolos suportados pelo sistema. Essa questão será tratada através do conceito de plug-ins. Visões de desenvolvimento actual para o IdP não incluem qualquer plug-ins, no entanto, deixar o sistema ser extensível assim seria o de permitir esta nitely no futuro. Outro importante bene t de usando uma estrutura de plug-in é de que as extensões para o sistema pode ser facilmente
implantada para instalações existentes, sem a necessidade de recompilação.
4.2.1 Plug-ins de
um plug-in é uma extensão para os deslocados internos. O núcleo IdP quadro propriamente dito não implementar quaisquer plug-ins, apenas de nes como um plug-in deve se comportar. Um
plug-in é criada pela codificação de uma classe que implementa a interface IPlugin,
e assim o IdP não ter cuidado sobre a como o plug-in é execu- tado, mas apenas que satis es o contrato de nida pela interface. Esta técnica é comumente usados e visado pelo [Gamma et al . 1995] com o lema "Programa para uma interface e não uma implementação". A Figura 18 mostra
duas interfaces importantes usados para criar plug-ins.
Figura 18. Modo de exibição de classe: IPlugin e interfaces IEndpoint
tanto o IPlugin e interfaces IEndpoint especificar que as propriedades chamado
Nome e Descrição. Estas propriedades são apenas strings descritivo.




49
ProvidedLoggingSources propriedade da interface IPlugin retorna uma lista de
nomes que a fonte de log dado plug-in utiliza quando (ou se) cria entradas de registro. Durante a instalação de um plug-in, o sistema deve portanto criar
fontes de registro usando o LoggingSourceRepository. No entanto, o
repositório de finição fonte de log que vimos anteriormente não têm
função anAdd, a fim de que precisa ser adicionado. A função de nida GetEndpoints
pela interface IPlugin deve retornar uma lista de implementações IEndpoint.
Conceitualmente, um endpoint de nes um sítio web (absoluto) caminho e alguns classe
que sabe como lidar com quaisquer pedidos para esse caminho. Traseira Domanuseador propriedade
deve retornar uma instância de uma classe que pode lidar com as solicitações de web. Cada quadro de desenvolvimento da web modernos tem pontos de extensibilidade para essas classes e no .Net framework que seria simplesmente uma implementação da
interface IHttpHandler.
O plug-in do conceito de nosso modelo é na verdade uma abstração geral que será a mais especializada especi credencial c plug-in e o plug-in de protocolo como
veremos mais adiante.
Cada plug-in de implementação será delimitada contexto em termos de design orientado por domínio. O delimitada contexto formado por cada plug-in terá uma visão conformista relação com o IdP desde o plug-in deve respeitar o modelo
de ned no IdP.
4.3. Utilizadores
um dos conceitos fundamentais do IdP é o usuário. Um usuário representa uma pessoa
que é conhecida pelo IdP e que, por de nição, sabe algo sobre.
A Figura 19 mostra as propriedades de um utilizador. Para além de um ID exclusivo (
OID), o usuário contém um nome de usuário e uma LastLogin um DateCreated asso-
ciados. Estas um bastante auto-explicativa. Por último, aUser tem uma senha e uma
propriedade PasswordSalt. Aparece o é um hash computado do usuário
senha de texto simples e é aleatória thePasswordSalt alguns valor utilizado pela
função hash- ing como entropia. Dado o usuário senha de texto simples, o hash função irá retornar apenas o mesmo hash computado como os armazenados no
objeto do usuário se o mesmo valor de sal é usado. De modo a verificar se a senha de um usuário, tudo o
que precisa ser feito é para calcular o hash da senha digitada pelo usuário, usando o valor de sal, e original comparar o resultado com o valor




50
Figura 19. Exibição de Esquema: utilizador
guardado no objeto do usuário. Usando esta abordagem não permite a qualquer pessoa com acesso
ao banco de dados para ver qualquer uma das senhas dos usuários. Note que a classe Usuário
mostrado na Figura 20 tem uma função VerifyPassword, que faz exatamente isso.
4.3.1 Criação de Usuário
o administrador deve ser capaz de criar manualmente os usuários. Para alcançar este objectivo,
as classes mostrado na Figura 20 são necessários. A classe UserFactory
revelada tem um método que leva a dois argumentos, nomeadamente um nome de usuário e
clearTextPassword. Quando chamado, o revelada método calcula o
hash com a senha e a senha de sal, define a data de criação e outras
euratomdoconselho e retorna uma instância do usuário. O usuário pode então ser instância persistiu
por passagem como um parâmetro para a função do UserRepository no botãoadicionar classe.
Note que o ExistsByName UserRepository também tem uma função. Este- nerador
tem um nome de usuário e retornará TRUE se um usuário com esse nome já existe e o falso outros o contrário. O IdP não permite mais de usuário tenha o mesmo nome de usuário, e é por isso que é importante usar a
função ExistsByName para verificar que nenhum usuário com esse nome já existe.
A função volta ExistsByName usa uma especi cação (ExactUserName
especi cação) para comparar o nome do usuário fornecido com o de usuários existentes.
Agora você pode pensar que isto é parvo. Comparando os nomes é apenas uma questão de comparação de caracteres à direita? A resposta é não. O IdP tem uma regra que diz
que os nomes de usuário diferenciam maiúsculas de minúsculas e o ExactUserName especi cação im-
limitaço ̃ es lógica que compara nomes caso insensibilidade foram.




51
Figura 20. Modo de exibição de classe de criação de Usuário:
4.3.2 exibindo os usuários existentes
o administrador terá de ser capaz de exibir uma lista de todos os usuários existentes.
Para atender a essa necessidade, theUserRepository precisará ter um FindAll- nerador
. Pode também precisam ter a função aFindByFirstLetter facilmente buscar
todos os usuários cujo nome de usuário começa com alguns especi c carta.
Funções de pesquisa de facto, será provavelmente necessário em todos os repositórios. No capítulo 6 Eu vou discutir como isso pode ser feito de uma forma genérica. Até então, você pode
presumir que todos os repositórios de ter pelo menos uma função FindAll.
4.3.3 Convidando usuários
como você pode lembrar do Capítulo 2 uma característica importante do sistema é que deve ser possível convidar usuários para registrar no IdP. Você pode pensar que esta como uma maneira fácil para o administrador para criar usuários no IdP, porque em vez de ter de digitar todas as informações sobre cada





usuário 52, o convite mecanismo delegados este trabalho para cada usuário. O acto de convidar um usuário apenas requer o envio de um e-mail para alguns endereço de e-mail com um código de permuta catiónica veri. A veri cação de código é simplesmente um código gerado automaticamente que o IdP links o endereço de correio electrónico para o qual ela foi enviada.
Apresentando o seu endereço de email e o código correto de veri cação, o usuário pode provar que ele foi efectivamente convidados. O usuário escolhe um nome de usuário e tipos em quaisquer informações adicionais (por exemplo valores para suas reclamações como veremos na secção 4.10) e ele então é ativado no sistema sem
maior envolvimento do administrador.
Figura 21. Exibição de Esquema do usuário: convite a
Figura 21 mostra o esquema envolvidos inuser convites. TheUserInvitation
classe contém o e-mail e VerficationKey apenas como explicado. Além disso,
cada UserInvitation tem um número de UserInvitationStatusHistory acordocomoquadrodecorrespondênciaconstantedapartea
, cada um dos quais aUserInvitationStatus referência. TheUserInvitationStatus
é usado para de ne estados, como email enviado , código veri ed e usuário cre- ados . A tabela de histórico apenas links de um estatuto para um convite usando a
propriedade StatusDateTime para registrar a data e a hora do determinado status.
Quando o usuário é criado como um actualUser no sistema, anInvitationToUser
objeto é criado a fim de ser capaz de controlar os convites que correspondem aos
quais os usuários.
A Figura 22 mostra as entidades da Figura 21 na classe, juntamente com todas as outras classes necessárias para o usuário convites. A classe que orches-
trados mais coisas relacionadas a convites de usuário é o UserInvitationService




53
Figura 22. Modo de exibição de classe de usuário: convite
classe. O método IniviteUser toma um único parâmetro, um e-mail ad-
vestido, e executa as seguintes etapas; primeiro que chama o método
do UserInvitationFactory revelada, passando o endereço de e-mail como o único pa-
rameter o método para criar uma nova instância da
classe UserInvitation. O método de fábrica gera o VerificationKey internamente para a
instância UserInvitation, e também gera uma instância ofUserInvitationStatusHistory
casais que a instância UserInvitation. Em seguida, o UserInvitation
instância é persistiu chamando no botãoadicionar método de theUserInvitationRepository.
Por último, uma mensagem de correio, incluindo a veri cação chave é composta, e o
método do EmailService SendEmail é chamado para enviar a mensagem de e-mail.
O método do UserInvitationService InviteUsers toma uma vírgula sep-
arated lista de endereços de correio electrónico e chama o método InviteUser uma vez para cada
endereço de e-mail. O método CreateUserFromInvitation leva um email ad-
vestido, uma veri cação chave, um nome de usuário e uma senha como parâmetros. Ele então
nds o UserInvitation instância correspondente ao endereço de e-mail e
veri es que a veri cação chave está correcta ligando theVerifyKey método
nessa instância. O VerifyKey método leva o veri cação chave fornecida
pelo o usuário e a compara com o que ele detém internamente. Se cada- coisa é ok, o convite a história é atualizado através da criação de objetos adequada
e chamar os repositórios adequada. Finalmente um novo objeto de usuário é criado e
persistiram e nitivamente InvitationToUser uma instância é criada e persistiu.




54
e conclui que o usuário o convite e o usuário está agora pronto para iniciar a sessão
com o IdP.
4.3.4 Self Registration
uma outra forma de criação de usuário é através de auto-registro. O autoregistro
tem muitas semelhanças com o usuário convites, mas di ers em que o utilizador e não o administrador inicia o processo de criação. Além disso,
qualquer registo devem ser aprovadas por um administrador.
Figura 23. Exibição de Esquema: auto-registro a
Figura 23 mostra o esquema a exibição de classes necessária para o suporte de auto-registro. Provavelmente você pode reconhecer a maioria dos conceitos do
usuário convites. A principal di erência aqui é que o SelfRegisteredUser
classe contém todas as propriedades necessárias para a criação de um objeto de usuário, como a
senha, PasswordSalt... o SelfRegisteredUser classe contém
uma propriedade chamada RequestedUserName. A razão para isto é que no momento
do autoregistro um determinado nome de usuário podem estar disponíveis, mas no momento da
criação do usuário, o nome pode ter sido tomadas por alguém.
A Figura 24 mostra as classes para o autoregistro no modo de exibição de classe. As aulas são semelhantes às do usuário convite, e por isso não vou explicar em pormenor. É importante que a nota que existem muitos mais Estados envolvidos no registo de auto existem convites para o usuário. Registrado




55
Figura 24. Modo de exibição de classe: auto-registro
é o status de usuários recentemente matriculados. Após o registo é enviado um e-mail para o endereço de correio electrónico fornecido para verificar o endereço. Quando o usuário con rms do endereço de e-mail, o status é alterado para Veri ed . Quando o endereço é veri ed um administrador deve ter algum tipo de ação. O administrador pode aprovar o registo, que resulta na alteração do status de usuário criado e um e-mail que está sendo enviada para o usuário, con rmar o seu registo. Este e-mail irá conter o nome real do usuário, que pode ter sido alterada a partir de o que o usuário quis, como descrito anteriormente. O administrador também pode optar por negar o registro, que resulta em um estado de recusa de , e um e-mail que está sendo enviada para o usuário. Finalmente o administrador pode optar por ignorar o registo, o que resulta em um status de Ignorados , mas nenhum e-mail
é enviado. O UserRegistrationService é a classe que fornece todas essas
mudanças de status. Observe também que o UserFactory foi estendido para
incluir um método chamado CreateFromRegistration que leva a uma instância
de um SelfRegisteredUser opcional e um novo nome de usuário e retorna uma
instância de um usuário.
4.3.5 Refatoração
do modelo assim longe contém alguns conceitos implícitos sobre o envio de emails para os usuários. Permite ver como o modelo poderia bene t de ter estes conceitos
mais explícita. Em vez de ter os serviços, tais asUserInvitationService,
UserService UserRegistrationService e compor mensagens de email inter-
namente e enviá-las por meio da EmailService, estas
mensagens de correio electrónico entravarão um di deve ser explicitada conceitos no modelo.
A Figura 25 mostra as classes envolvidas no envio estas mensagens de correio electrónico.
Primeiro de tudo, a interface IEmailMessage de nes três propriedades, Assunto,




56
Figura 25. Classe: e-mails
Mensagem e o destinatário. Estas são as propriedades que são necessárias pelo
método da classe SendEmail theEmailService. De modo que a assinatura deste método
é alterado para ter uma instância de anIEmailMessage como um parâmetro. Agora, o
BaseEmailMessage implementa a interface IEmailMessage, mas tem todas as
4 propriedades da interface como um resumo membros . Além disso,BaseEmailMessage
implementa um (não abstracta) método chamado Enviar. Este método chama o
método SendEmail EmailService's, passando a si próprio como o parâmetro. Isso
nos permite de ne as mensagens de e-mail explícita como as mostradas no
gure. Por exemplo, InvitationEmailMessage é uma classe que herda o
BaseEmailMessage, e toma uma instância de um UserInvitation no seu con-
structor. Ele implementa o resumo propertiesSubject,andRecipient mensagem
da classe base (e que originam IEmailMessage). O tema
é simplesmente uma String estática dizendo algo como você foi convidado a
ingressar em um provedor de identidades . A propriedade da mensagem contém o
corpo da mensagem, incluindo a veri cação chave (disponível através da
propriedade do UserInvitation theVerificationKey instância passadas para o construtor) e um
link para a página de catiões veri. Por último, a propriedade de e-mail também é lido a partir de
UserInvitation instância. Você pode se perguntar como o endereço correto para a
veri cação página é obtido. Este endereço, e uma série de outros parâmetros sobre o IdP será disponibilizado a todos os componentes de uma forma ex-
des francesas explicaram na secção 4.11.
Uma última preocupação é se o EmailService ficou obsoleta. Poderia o
4 o que significa que eles devem ser implementados por qualquer herdar classes




57
logic implementado pelo método do EmailService SendEmail muito bem ter sido colocada no método de envio de BaseEmailMessage? Ele
poderia ter de nitely, mas eu não acho que é uma boa idéia. A principal finalidade da
EmailService é saber sobre qual servidor SMTP para usar e que cre-
dentials (se houver) para apresentar ao servidor SMTP. Além disso, se mais tarde
eu quis implementar um método chamado CheckServerConnection, seria
de nitely ser mais lógico ter esse método anEmailService
classe do que por uma classe BaseEmailMessage.
4.4. Reconfiguração
do IdP con figuração é essencial de muitas maneiras. Primeiro de tudo, reconfiguração do IdP em si deve ser possível. Além disso, cada plug-in irá dependem da capacidade de ser con configurados para funcionar corretamente. Este é também o caso para conexões, que são descritos posteriormente neste capítulo. Por conseguinte um quadro con figuração é chamado para. O quadro con figuração de nes
três tipos básicos de dados; texto elemento de configuração que mantenha dados string de
configuração do certificado elementswhich, mantenha referências a certifi cados e
lista os valores de configuração que também mantenha dados string, mas que são agrupadas logicamente em listas tabelas (ou).
A Figura 26 mostra o esquema vista da reconfiguração elementos. Comum
para todos os elementos de con figuração é que eles são identificados por um NameSpace
e ed um nomeelemento. O namespace é uma cadeia de caracteres identifi er do proprietário do
elemento de con figuração. O namespace pode ser algo como o idp.core para todos os elementos pertencentes ao próprio IdP, ou protocolo.2 para uma saml alguns da implementação do protocolo e protocolo de nitivamente.saml2.Connection1 para alguma ligação. De um modo geral, o namespace é utilizado apenas para o grupo con- guração elementos pertencentes a alguma parte do sistema. Por conseguinte, o namespace usado por qualquer parte do sistema deve ser exclusivo. O
TextConfigurationElement tem valor domínio que contém o valor real.
O valor é sempre armazenada como uma string, mas dotipo domínio é usado para indicar
o tipo de dados da cadeia de caracteres. O tipo, por exemplo, poderia ser Booleano ,
e indicar assim indicar que apenas os valores verdadeiro e falso seria
válida. O CertificateConfigurationElement contém referências a certifi
cados de -. As informações contidas no CertificateConfigurationElement
é em certa medida especi c para a forma como certifi cados são armazenados em máquinas executar- ning Windows. Isso não faz o modelo de implementação especi c, mas




58
Figura 26. Exibição de Esquema: elementos con figuração
apenas indica que o contexto delimitada que o modelo compreende, age
como uma visão conformista para o ambiente onde é finalmente indo para executar.
O ListConfigurationElement é usado para de ne reconfiguração de elementos
que têm uma natureza tabular e onde zero ou mais linhas de dados pode ser chamado
para. A Figura 27 mostra como um ListConfigurationElement poderia ser apresentado.
Geralmente, uma única linha de dados contém vários valores e o significado
é de nida por uma coluna. Portanto uma ListValue está vinculado a uma linha e uma coluna,
conforme mostrado no gure.
As características mais importantes de con figuração são elementos que devem ser apresentável para o administrador tais que possam ser lidos e editados.
Além disso, deve haver um mecanismo para validar os valores digitados pelo administrador. Outra preocupação importante é que em alguns casos só determinados valores fazem sentido para um determinado elemento de con figuração. O plug-in, ou parte do sistema, que depende de um dado elemento con figuração deve ser capaz
de fornecer uma lista de valores válidos para um determinado elemento, caso exista uma tal lista.




59
Figura 27. Listas de con figuração
Figura 28. Modo de exibição de classe: con figuração elementos
Figura 28 mostra a con figuração os elementos e os seus repositórios no modo de
exibição de classe. A coisa importante a comunicação aqui é o INamespaceElement inter-
face, que é implementado por todos os três entidades. A interface simples
de nes que uma única propriedade chamada Namespace. Uma vez que todas as três entidades




60
têm essa propriedade já, eles podem implementar a interface sem mais delongas. Isso é útil porque agora podemos de ne uma especi cação chamado
NamespaceMatchesSpecification, cujo método IsSatisfiedBy faz uma
postura de um INamespaceElement-. Desta forma, todos os três repositórios podem usar a
mesma especi cação de nd os elementos do respectivo tipo que corresponda a um determinado namespace, tornando assim simples de nd con figuração todos os elementos pertencentes a um determinado componente (identifi ed pelo seu namespace, evidentemente
). Observe também que o CertificateConfigurationElement de nes
calledLoadCertificate um método que carrega o certi cate do real cer-
ti cate store. Isso é útil porque o
próprio CertificateConfigurationElement apenas contém informações sobre onde o certifi cate é armazenado. O
método retorna uma instância da classe de quadro chamado Certificado X5092.
Qualquer parte do sistema que depende de valores de con figuração, seja ele o
próprio núcleo do IdP ou qualquer plug-in ou conexão, vamos chamar um configurável com- ponentes. Um con podem ser configuradas componente fornece a seguinte funcionalidade: Ele
pode fornecer um conjunto de valores padrão para todos os seus elementos con figuração. Ele pode fornecer uma estrutura que logicamente grupos sua con figuração valores tais que podem ser exibidas para um administrador de uma forma que faz sentido no contexto do significado dos elementos de con figuração. Ele pode validar os valores de todos os elementos de con figuração como um todo e o valor de um único elemento de con figuração individualmente. Para fornecer essa funcionalidade um número
de classes e interfaces são chamados para.
Figura 29. Modo de exibição de classe: Con componente podem ser configuradas na
Figura 29 mostra alguns dos conceitos necessários para o suporte a componentes podem ser configuradas em con vista classe. Um con é representada pelo componente podem ser configuradas a
interface IConfigurableComponent. A interface de nes que namespace




61
os elementos do componente tem, através da propriedade theElementNamespace.
Além disso, a interface de nes um conjunto de funções;GetDefaultValues é uma
função que retorna uma instância de um ConfigurationSet. Esta função é
denominada durante a instalação de um componente podem ser configuradas e con a sua principal finalidade é retornar todas as con figuração elementos tais que podem ser criadas na base de
dados do . Um ConfigurationSet é apenas um recipiente para a con figuração el-
ements do di entravarão um tipos explicado anteriormente. TheGetDisplayConfigurationSet
retorna uma instância de um DisplayConfigurationSet, uma classe que apresenta
a reconfiguração de elementos em uma forma adequada para mostrando em um usuário inter-
face. A classe DisplayConfigurationSet será explicado com maior de-
caudas mais tarde. O ValidateConfigurationSet é um método que uma instância de um
ConfigurationSet como um parâmetro e retorna uma instância de aDisplayConfigurationSet
(que contêm informações sobre os erros potenciais). Por último, theValidateElement
método, é um método sobrecarregado que leva a um dos três tipos de elemento de con figuração como um parâmetro e valida seu valor (ou valores, se se trata de um
ListConfigurationElement). Retorna uma cadeia de caracteres contendo um erro mes-
sage se o valor não for válido ou nulo se a validação for bem sucedida.
A principal finalidade da DisplayConfigurationSet é exibir uma con g-
uration definido em alguns UI, tais como a apresentada na gure 30.
Figura 30. Visual conceituação de reconfiguração
Figura 31 mostra as classes envolvidas no elemento de con figuração visor. O
DisplayConfigurationSet é o agregado raiz de todas as classes e como você
pode ter percebido algumas propriedades adicionais foram adicionados desde a classe
foi introduzida na figura 29. Essas propriedades são a propriedade Caption,
que é uma cadeia de caracteres contendo uma legenda ou posição se você gosta da PT-




62
Figura 31. Modo de exibição de classe: Exibir elementos con figuração
Afixação dos pneus con figuração definida. Uma legenda valor poderia por exemplo ser identi- dade con figuração provedor ou protocolo con figuração SAML 2.0 . A última
propriedade de Esta classe é a propriedade de guias. Esta propriedade retorna uma lista
de instâncias DisplayConfigurationTab. Um
recipiente DisplayConfigurationTab é um agrupamento, destinados a ser exibido como um único guia em uma guia controle.
Uma guia de controle é uma interface de usuário comum controlo encontrado na maioria das aplicações.
O DisplayConfigurationTab classe também tem uma propriedade Caption, e o mais
importante é que tem uma propriedade de grupos. Os grupos propriedade retorna uma lista
de instâncias DisplayConfigurationGroup. Um DisplayConfigurationGroup é
ainda um outro recipiente de agrupamento, usado para logicamente e agrupar visualmente con g-
uration elementos. Além da propriedade tem anElements theCaption
proprie-, que retorna uma lista de instâncias do abstractBaseDisplayConfigurationElement.
A classe BaseDisplayConfigurationElement serve o propósito único de
ser uma classe base comum para os três elementos de con figuração de exibição.
Isso é útil para a ordem de que os elementos são exibidos. A
classe base contém uma única propriedade namelyReadOnly, que é a única propriedade
três con figuração exibir elementos têm em comum. A
propriedade ReadOnly indica se um determinado elemento con figuração visor é editável.
DisplayTextConfigurationElement tem as seguintes propriedades;ConfigurationElement
é do tipo TextConfigurationElement e representam a con figuração elé-




63
mento que está sendo exibido. A propriedade de erro é uma cadeia de caracteres contendo uma
possível mensagem de erro para o elemento. Por último, thePossibleValues é uma lista
de valores possíveis. O PossibleValues pode ser nulo, caso em que o ad-
ministrator pode digitar qualquer valor. No entanto, se thePossibleValues não é
nula, a valores de string que contém será processado como uma lista suspensa, de onde um valor pode ser escolhido. Os outros dois elementos con figuração
são semelhantes. Eles di er no tipo retornado pela ConfigurationElement.
Além disso, DisplayCertificateConfigurationElement di ers em que sua
PossibleValues não retornar uma lista de valores de string, mas uma lista de Dex509Certificado2
instâncias, a partir da qual o administrador pode escolher. TheDisplayListConfigurationElement
di ers em que seus erros propriedade é uma matriz de mensagens de erro, correspondem-
ing cada ListValue dentro do ListConfigurationElement devolvido pela
propriedade ConfigurationElement. Por último, thePossibleColumnValues é sim-
ilar ao PossibleValues propriedade do outros dois elementos de exibição, como
sempre que contém uma lista de listas, onde cada lista corresponde a
valores possíveis para uma coluna de ListConfigurationElement.
4.4.1 Refatoração
não precisa ser de alguma forma de comunicar o significado de um elemento de con figuração para o administrador. Às vezes o nome de uma reconfiguração elé- mento pode não ser suficiente fazer explicar o que é um elemento de con figuração. Por
conseguinte uma descrição é chamado de propriedade. Agora, a
propriedade Description deve ser sobre o elemento de con figuração, ou sobre a sua contrapartida de exibição?
Uma vez que é sobretudo uma coisa relacionadas com o visor, escolhi para estender o
BaseDisplayConfigurationElement com uma descrição propriedade.
4.5. Certifi cados
se você conhecer um pouco sobre o X.509 certifi cados, você sabe que a maioria dos certifi cados de exportação são emitidos por outros certifi cados. Desses certifi cados que não são emitidos por outro certifi cate são disse a ser auto-emitidos e são muitas vezes referidos como
os certificados de raiz. Para que um aplicativo considerem alguns certifi cate para ser
válido, deve, entre outras coisas, a confiança a raiz certifi cate que emitiu essa certifi cate. Algumas empresas em todo o mundo vivem com a emissão de certifi cados. Tais empresas são chamados de certifi cate competentes (CA), e eles usam muito bem guardada certi cate a questão raiz certifi cados que




64
outras empresas ou as pessoas podem comprar. A raiz certifi cados de estes são da CA Confiável por padrão por todos os computadores em todo o mundo, porque eles são fornecidos com o sistema operacional. Às vezes quando você não quiser pagar para um certi cate que você vai usar para fins de teste, você pode criar a sua própria raiz certifi cate e usar isso para emitir outros certifi cados. Isto irá funcionar ne sobre seus próprios sistemas, porque você pode optar por confiar que a raiz do Certifi cado.
No entanto outros sistemas não confie a sua raiz certifi cate, mas que realmente não importa enquanto você estiver utilizando-o apenas para fins de teste ou se você pode
convencer os seus parceiros de negócio para confiar a sua raiz certifi cate.
Já vimos como certifi cados podem ser usados em reconfiguração do sistema. No entanto, certifi cate con figuração elementos eram apenas as referências às certifi cados no certifi cate store. O administrador precisa de alguns meios de inspeção (procurando) certifi cados no certifi cate store, criando
novas certifi cados de certifi cados existentes, exclusão e assim por diante.
Figura 32. Modo de exibição de classe: certifi cados de
Figura 32 mostra as classes envolvidas na manutenção de certifi cados. O mais
importante é a classe theCertificateService classe. TheCreateRootCertificate
método pode ser usado para criar uma raiz certifi cate como explicado acima. O único parâmetro para o método é chamado o nome diferenciado de um
valor de cadeia de caracteres que é usado para identificar o certifi cate mais tarde. O CreateCertificate




65
é usado para criar um certi cate. Como um parâmetro também leva um nome distinto, mas além disso, tem uma raiz certifi cate que é utilizado para emitir certifi cate. A raiz certifi cate parâmetro é passado para o método como uma
atitude de- X509Certificado quadro2 classe. O DeleteCertificate é
utilizado para excluir um certi cate, e leva a uma instância de um certificado X5092
classe seu único parâmetro. O método ExportCertificate toma como parâmetro de somente uma instância do X509Certificado2 classe e retorna uma
matriz de 5 byte que representa a certifi cate sua chave pública em um formato comum . O
ExportCertificateWithPK exportações um certi cate incluindo sua chave privada. Este
método leva uma instância de um certificado X5092 classe, juntamente com uma
senha para usar para proteger o Certifi cado. Ele também retorna uma matriz de bytes, este tempo correspondente tanto para o sector público e a chave privada do cer-
6 ti cate e também em um formato comum . O método ImportCertificate
é um método sobrecarregado. A rst sobrecarga leva apenas uma matriz de bytes (no formato CER) e as importações um certi cate a chave pública certifi cate store.
A outra sobrecarga, toma uma matriz de bytes (no formato PKCS12) e um passe - word, e importações Certifi cado de chave pública e privada para a certifi cate
store. O método FindCertificates leva uma lista de certi cate especi ca Ño
instâncias, e retorna todos os certifi cados que correspondem às especi ca- ções. Todos os certifi cate especi cações no gure tomar uma instância do
X509Certificado2 em seus respectivos métodos IsSatisfiedBy. As especifi -
cações são; CertificateByDistinguishedName que compara um certi cate
ao nome diferenciado parâmetro string dado na especi cação con-
structor. O CertificateIsValid verifica se um certi cate é válida, eg. emitidos
por uma AC de raiz fidedigna certifi cate e não expirou. O CertificateIsInvalid
faz o oposto, e nitivamente, theCertificateMatches compara um certi -
cate para outro. O FindRootCertificates faz exactamente o mesmo que o
método FindCertificates, só ele procura no certifi cados de raiz confiável armazenar
em vez de no local padrão.
4.5.1 Refatoração
quando eliminar um certi cate, seria útil dispor de um recurso que poderia
verificar se a certifi cate está sendo usado pela aCertificateConfigurationElement
e alerta o administrador se foi esse o caso.
5 Um formato comum é a regras de codificação canónica (CER) formato que é suportado na
maioria das plataformas.
6 Um formato comum para a exportação de certifi cados com chave privada é o formato PKCS12.
PKCS significa Public-Key Cryptography Standards e 12 é um número de versão.




66
Figura 33. Modo de exibição de classe: Refatoração certifi cate con figuração repositório de elemento
Figura 33 mostra que a CertificateConfigurationElementRepository
foi estendido para incluir um método chamado FindByCertificate. Ele toma
uma instância da ANS509Certificado2 e retorna uma lista ofCertificateConfigurationElements
que atualmente são os dependendo de que determinado certifi cate. Se a lista estiver vazia, é seguro para excluir o Certifi cado. Se a lista de não estiver vazia, o administrador pode ser dito que certifi cate con figuração elementos dependem que certi - cate e possivelmente mudar aqueles elementos de referência con figuração outro
Certifi cado antes de excluí-la.
4.6. Fornecedores de credenciais
credencial providersare plug-ins especializados que facilitar os logins de usuário. O
IdP vai s er vários provedores de credencial entravarão um di, mas é o administrador que escolhe quais fornecedores de credenciais são habilitados para o seu IdP. Um provedor de credenciais concretas de implementação plug-in está contida dentro de um módulo (DLL) no servidor do IdP e registadas na base de dados, de forma que o administrador
pode activar.
Figura 34. Exibição de Esquema: fornecedores de credenciais




67
Figura 34 mostra o que os conceitos principais envolvidos na criação de
fornecedores de credenciais. Um CredentialProviderDefinition de nes um provedor de credenciais
que podem ser usadas para fazer logon de usuários em. Ele tem um nome e uma descrição e o
mais importante tem um CredentialProviderType, que é uma cadeia de caracteres que
contém um nome de tipo totalmente quali ed, que pode ser usado para criar uma posição do dado fornecedor de credenciais usando a secção. O tipo de nome deve representar um tipo que implementa uma interface c, que especi vou
explicar em pormenor abaixo. O ConfiguredCredentialProvider é apenas um
ponteiro para um CredentialProviderDefinition, e indica que o dado
CredentialProviderDefinition foi con configurados (está em uso).
Como mencionado no capítulo 2, o IdP deve ser capaz de acomodar creden- repercussäoes sobre tanto na forma de nome de usuário/senha e através da federação 2.0 SAML.
A credencial mecanismos são realmente muito di entravarão um, em que o nome de usuário/senha variante valida usuários através do banco de dados local, enquanto a variante SAML utiliza a federação com outro provedor de identidade para coletar as credenciais do usuário. O modelo permite apenas uma instância de cada creden- pondentes provedor para ser con configurados. Isto funciona bem para o cenário de usuário/senha, como há apenas um banco de dados de usuário local de qualquer forma. Mas o que sobre a federação SAML cenário. Aqui, tem de ser possível configurar diversas federações com vários outros deslocados internos. E este é de facto vai ser possível, porém não por con guring mais de uma instância do provedor de credenciais,
mas pelo conceito de conexões, explicado na secção 4.8.
A Figura 35 mostra a interface que deve ser implementada pelo plug-ins que
são fornecedores de credenciais. A interface
IPlugIn ICredentialProvider estende a interface e adiciona duas novas propriedades. SupportsConnections é
um booleano que indica se o fornecedor de credenciais ou não suporta conexões. Isso é útil para exibir uma interface de usuário para o administrador onde ele pode con gure as ligações para um determinado provedor de credenciais que
suporta conexões. O DefaultEndpoint é uma propriedade que retorna uma
instância de um IEndpoint (veja a Figura 18 na página 48). O padrão de terminação é
o endpoint que inicia a sessão por um determinado usuário. Um provedor de credenciais podem ter mais endpoints para vários fins, pelo que é importante que o IdP sabe qual é o padrão de terminação, tais que pode iniciar a
sequência de início de sessão corretamente.




68
Figura 35. Modo de exibição de classe de interface do provedor de Credencial:
4.7. Protocolos
Protocolo plug-ins são plug-ins especializados que fornecem a execução de algumas Protocolo para troca de informações relacionadas com a segurança. Tais protocolos
incluem SAML, WS-russa, OpenID e muitos mais.
A Figura 36 mostra o esquema a exibição de classes para de ning e con gur- ing protocolos no IdP. Não existe nenhuma verdadeira di erência da forma como fornecedores de credenciais onde de ned e configurados, con não vou entrar numa longa- siderem aqui. Aviso no entanto que existem repositórios para ambos os conceitos
(ProtocolDefinition e ConfiguredProtocol) mesmo que eles não são
mostrados aqui.




69
Figura 36. Exibição de Esquema: Protocolos a
figura 37. Modo de exibição de classe de plug-in de protocolo: interfaces




70
Muitos, mas não necessariamente todas contam com protocolos o intercâmbio de meta-dados a fim de estabelecer uma relação de confiança entre um provedor de identidades
7 e um provedor de serviços . Nosso IdP não tem maneira de saber o
formato de metadados usados em di protocolos, portanto o entravarão um a responsabilidade de criar os metadados devem ser delegadas para o plug-in de protocolo de aplicação-
auto. Por conseguinte, a propriedade da IPotocolPlugIn HasMetadata pode ser
usado pelo executante de um protocolo especí c Indique se quer ou não a implementação fornece (ou) metadados. Quando é esse o caso, a
implementação de GetMetadata é suposto para retornar uma cadeia de caracteres representando o nome de
metadados para a implementação. Se HasMetadata retorna falso, o
método GetMetadata não será chamado. No entanto ainda necessidade de execu-
tado, porque caso contrário a interface não será implementado. Deite- ing uma excepção na implementação do método será aceitável. A
propriedade SupportsConnections é idêntico ao de fornecedores de credenciais.
Isto indica que a propriedade poderia ser transferido para a interface comum
IPlugIn, algo que eu endereço abaixo. O IProtocolEndpoint em-
terface é uma extensão da interface IEndpoint, que adiciona uma
propriedade importante,RequiresAuthentication. Esta propriedade indica se um determinado ponto de
extremidade do protocolo requer que o usuário ser autenticado antes de delegar o controle para o endpoint. Este é o caso para todos os pontos de extremidade de protocolo de envio de identidade do usuário para um provedor de serviços. O IdPwill verificar qualquer ponto de extremidade do protocolo para esta propriedade, e certifique-se de autenticar o usuário (através de um dos provedores de credenciais configuradas con) antes de delegar o controle de ponto de
terminação. Vou explicar esta questão mais em pormenor na secção 4.11.
4.7.1 Refatoração
Como mencionado antes, a propriedade SupportsConnections existe tanto na
ICredentialProviderPlugIn IProtocolPlugIn e interfaces. Portanto ele
pode ser movido para theIPlugIn interface. Além disso, alguns fornecedores de credenciais
também necessidade de exportar metadados. Isto significa que a propriedade HasMetadata
e o método GetMetadata também podem ser movidos. Isso deixa a questão
de saber se as duas interfaces deveriam estar. No entanto Eu gosto da idéia de ter os dois. Eles são bons para ter para o bem da possibilidade de que as duas podem divergir no futuro. Tendo em ambas também tornar mais explícito como conceitos, o que é importante em termos de
design orientado por domínio.
7 operadora de serviço também é por vezes referido como parte confiante .




71
4.8. As conexões
conforme já mencionado, é normal para um provedor de identidades para exigir uma con- configurados conexão antes que ela deseja se comunicar com um provedor de serviços.
Uma conexão é apenas algumas informações sobre a outra parte. Esta formação- geralmente inclui certifi cados e um conjunto de valores de string descrevendo vários aspectos do caminho de comunicação entre as duas partes é efectuada. Em outras palavras, uma conexão é um conjunto de con figuração especializados. Tendo em conta o facto de que os dados (a con figuração set) que descreve uma conexão é especi c para um determinado protocolo (língua as duas partes falar ), deve ser responsabilidade da implementação de um protocolo para fornecer o padrão con g- uration definir valores e o visor con figuração definida. Um provedor de credenciais também pode precisar con gure ligações, por exemplo no caso de SAML2.0 federados login. Neste caso o fornecedor de credenciais atua como um provedor de serviços
para alguns outros IdP.
Figura 38. Exibição de Esquema: Ligações a
Figura 38 mostra a exibição de esquema de algumas das classes necessárias para as
conexões do modelo. Um ConfiguredConnection representa alguns con-
tenção totalmente configurados. Além de ter um objeto identifi er, um con conexão configuradas tem um nome, uma descrição e um namespace, representada pelas propriedades




72
ConnectionName, ConnectionDescription e ConnectionNamespace. O
ConnectionNamespace é usado para mapear uma conexão totalmente configurados para aConfigurationSet con.
Como o gure mostra também, uma con conexão configuradas pertence a um protocolo
ou um fornecedor de credenciais. Esse mapeamento é conseguida através de theProtocolConnection
CredentialProviderConnection e classes, que mapeiam um con representaraâ totalmente configurados
para uma conexão totalmente configurados ou con con protocolo totalmente configurados. Por favor note
que o ConfiguredCredentialProvider ConfiguredProtocol e classes
não são mostrados no gure.
Figura 39. Modo de exibição de classe de ligações:
Agora, a fim de apoiar a trabalhar com as classes de dados mostrado na Fig impossibil- 38 um conjunto de serviços e repositórios são chamados para. Estes são apresentados
no modo de exibição de classe na figura 39. Um serviço de ligação é um serviço que fa-
cilitates criação, atualização e busca de con configurados ligações. O
IConnectionService de nes essas funções. O método CreateConnection
tem três parâmetros, nomeadamente os parâmetros necessários para criar uma nova
postura de theConfiguredConnection- classe. Estes areConnectionName,ConnectionDescription
e ConnectionNamespace. O método GetConnection tem um único param nanó-, OwnerId e retorna uma instância de ConfiguredConnection. A
OwnerId refere-se à id de quer aConfiguredProtocol ou aConfiguredCredentialProvider.
Por último, SaveConnection tem dois parâmetros; a rst é uma instância de
ConfiguredConnection, e a segunda é uma instância de aConfigurationSet.
Existem duas classes que implementam a interface IConnectionService,
namelyProtocolConnectionService andCredentialProviderConnectionService.




73
Ambas as classes herdam theBaseConnectionService. TheBaseConnectionService
é uma classe abstrata que contém a implementação para SaveConnection,
pois este método deve fazer a mesma coisa no contexto do protocolo- cuito
provedor de credenciais e ligações. O método SaveConnection até-
datas (salva) a instância ofConfiguredConnection através theConfiguredConnectionRepository
(não mostrado no gure), e da mesma forma ele economiza a instância ofConfigurationSet
através do seu serviço de correspondente (ConfigurationService mostrado no g
impossibil-). A implementação do GetConnection e CreateConnection é di er-
ent para theProtocolConnectionService andCredentialProviderConnectionService
classes. Isto é devido ao fato de que eles interagem com instâncias do
ProtocolConnection andCredentialProviderConnection respectivamente (mostrado
na Figura 38). No caso de o método CreateConnection, é o de responsa-
bilidade dos respectivos a implementação de serviço para criar uma instância da
classe de conexão correto (eitherProtocolConnection orCredentialProviderConnection)
para associar a ligação com um protocolo ou um
fornecedor de credenciais. Da mesma forma, para o método GetConnection, é a responsabilidade
da implementação concreta para usar theOwnerId parâmetro para buscar a cor-
rect instância de eitherProtocolConnection orCredentialProviderConnection
(usando o repositório apropriado, novamente, não mostrado no gure para abreviar).
Foi também necessário para expandir a interface IPlugIn com uma propriedade
calledConnectionConfigurator. Esta propriedade é de typeIConfigurableComponent,
e é usado para validar os valores no con figuração definido para um pro- conexão de protocolo ou credencial ligação do fornecedor de serviços. O concreto implementaçäao
do IConfigurableComponent deve obviamente ser fornecido pela
aplicação de um protocolo ou provedor de credenciais, porque apenas estes im-
plementations pode saber que os valores válidos são em sua especi c caso.
4.9. Instalação do plug-in
desde o sistema plug-in é baseado, é importante que a instalação de novos plug-ins é suportado pelo sistema. Mais importante ainda, a instalação de um novo plug-in não deve levar a múltiplos pontos de terminação que pega o mesmo caminho.
É também importante para testar se o novo plug-in implementa a interface correta e de que não há pontos de terminação no plug-in que pega o
mesmo caminho.
A Figura 40 mostra as classes necessárias para a instalação do plug-in. O central
é a classe PluginInstallationService que tem dois métodos; um para em-




74
Figura 40. Modo de exibição de classe de instalação do Plug-in:
paragem do protocolo plug-ins e um fornecedor de credenciais para a instalação de plug-ins.
8 Cada método tem dois parâmetros, designadamente o tipo string , e o conjunto
que contém o plug-in, como uma matriz de bytes. Os dois métodos executam
ações semelhantes:
Etapa 1 Carregar o conjunto e instanciar a classe dado no tipo string
através da reutilização secção.
Etapa 2 Teste que a instância implementa a interface correta (ICredentialProviderPlugin
ou IProtocolPlugin).
Etapa 3 - Criar uma instância do AllEndpointPathsAreUniqueSpecification
e certifique-se de que o método itsIsSatisfiedBy retorna Verdadeiro.
Método TheIsSatisfiedBy tem um argumento do tipo IPlugIn, e reitera que todos os pontos de terminação
retornado pelo método GetEndpoints e testes que não Dois terminais
têm idêntico caminho propriedades.
Etapa 4 Criar uma instância da
classe theNoEndpointAlreadyExistsForPathSpecification. O construtor desta classe toma a lista de caminhos que são regis- veisnovosdepassageirosaregistarpelaprimeiravezna plug-ins para aqueles que já estão instalados. A fim de tornar esta lista, os dois repositórios mostrados são usados obter todos os plug-ins instalados, que depois são instanciados e os caminhos dos seus manipuladores são anexados à
lista. Por último, theIsSatisfiedBy método é chamado para cada endpoint
8 correspondente ao theCredentialProviderType orProtocolType propriedades do
CredentialProviderDefinition ou classes ProtocolDefinition respectivamente.




75
No plug-in que vai ser instalado.
Etapa 5 Se tivermos chegado tão longe, o plug-in está pronta para ser instalada. Uma
postura de eitherCredentialProviderDefinition- orProtocolDefinition
é criado e adicionado ao repositório correspondente. O nome e a descrição de propriedades do objeto nição são tomadas a partir da con- creta instância instanciado no passo 1. Uma vez que esta instância implementa a
interface IPlugin (Verbo|ICredentialProviderPlugin| andIProtocolPlugin
são extensões de IPlugin) estas propriedades estão disponíveis na
instância do concreto.
4.10. Créditos
a capacidade de ne e trabalhar com créditos é uma das principais funcionalidades do IdP. O IdPde nes três conceptualmente di entravarão um tipos de reclamações. A rst tipo de alegação é uma reivindicação que se origina a partir de alguns Fornecedor de credenciais.
No caso simples de nome de usuário/senha de credenciais, apenas a alegação de que se origina do provedor de credenciais de usuário é uma reivindicação. No entanto, no caso de um login federados número de sinistros pode ser devolvido pela
federação parceiro. Este tipo de alegação é chamado um CredentialClaim. O
próximo tipo de alegação é uma reivindicação que é de nida no IdP em si. Este
tipo de reclamação é chamado um IdentityProviderClaim. Finalmente, o último tipo de alegação é
chamado IssuedClaim, e representa uma alegação de que é emitida pelo IdP.
Figura 41 mostra algumas das classes relacionadas a reclamações, em vista do esquema.
O IdentityProviderClaimDefinition classe é utilizada para de ne um
provedor de identidades reivindicação no sentido de que ela não fornece um valor concreto para a reclamação. No entanto de ne todos os outros aspectos da reclamação. O
DisplayName propriedade é um nome amigável do leitor usado para exibição na UI. O
nome é o nome real do crédito utilizado ao enviar o pedido de alguns se-
gurança token. O formato é usado para descrever o formato do nome.
É normal para di protocolos entravarão um de formatos de nome de ne, que um nome deve obedecer a. Um formato de nome poderia, por exemplo, especificar que o nome
deve ser uma URI bem formado. O ValueType de nes o tipo de valor que
é aceitável para a reclamação. O tipo de valor é normalmente expressa como um
tipo de xml, como xs:string ou xs:int... a descrição é apenas uma
descrição textual, utilizado principalmente na UI. O DefaultValue é utilizado para de ne um
valor padrão para a alegação, no caso de um usuário não tem valor explícito para o dado crédito, ou no caso em que todos os usuários devem obter um valor de prede nida




76
Figura 41. Exibição de Esquema: Reclamações
a reclamação. O DefaultValue é, por exemplo, utilizado para grupos de Ning. Como
especi ed no Capítulo 2, deve ser possível atribuir usuários a grupos. Adicionando um usuário a um grupo simplesmente resulta em uma alegação de que os Estados que o usuário faz parte
de algum grupo. Criando um IdentityProviderClaimDefinition com um valor padrão de administrador por exemplo e ClaimName idp:Grupo,
conceptual de um grupo pode ser criado. Quando o pedido é emitido pelo IdP
parece como qualquer outra reclamação, mas tendo o DefaultValue e
propriedades IsGroup permite que o IdP para exibir uma interface de usuário quando a administra-
tor pode trabalhar com grupos. Por último, o IsUserUpdateable boolean ques-
tões é usado para especificar se pretende ou não o valor de um pedido pode ser alterado
por um usuário. Novamente, no caso de grupos, a propriedade IsUserUpdateable
será definido como falso, considerando que para outras alegações que poderia ser definido como true. Os
casais IdentityProviderClaim IdentityProviderClaimDefinition um a um
usuário e (opcionalmente) atribui um ClaimValue para determinada reivindicação de nição
para um determinado usuário. O CredentialClaimDefinition classe é semelhante à
classe em que IdentityProviderClaimDefinition também tem DisplayName,
Nome,O NameFormat,ValueType andDescription propriedades.
Classe TheCredentialClaimDefinition não têm uma propriedade DefaultValue, porque seu valor não é tão-
assinado pelo IdP. Pela mesma razão não tem
propriedades IsUserUpdateable theIsGroup e. No entanto, possui uma
propriedade IsIdentityBearer. Esta propriedade é utilizado para de ne que um dado pedido de credencial traz a identidade do usuário e que o seu valor pode ser utilizado para um





usuário do nd 77 correspondente instância. Para este trabalho, a credencial alegação de que
é portador de identidade deve ter um valor que corresponde a um nome de usuário de
alguns determinado usuário instância. Esta solução de obras nitely teoricamente, mas
provavelmente não é muito prático e portanto, este mecanismo é um claro candidato para futuro refatoração. O Verbo|ClaimValidation| classe é utilizada para a validação de classes para o ne valor de pedidos do provedor de identidade. Se, por exemplo, algumas pessoas afirmam que a sua dita o valor deve ser um número inteiro ou
ter um comprimento ou formato especi c, um ClaimValidation pode ser acoplado à
IdentityProviderClaimDefinition. Quando um administrador ou um usuário
atribui um valor para a reclamação, o validator é instanciado e avaliados contra o valor. O mecanismo é muito semelhante ao de plug-ins no que
se refere a um tipo aClaimValidation de caracteres que pode ser usado para criar instâncias
de validação através de re secção.
Figura 42. Modo de exibição de classe: Reclamações
Figura 42 mostra os três tipos de reclamação entravarão um di. O CredentialClaim é
uma classe cuja finalidade principal é a vincular um CredentialClaimDefinition com um
valor. Instâncias da classe CredentialClaim nunca são persistiu e são
criadas por um givenCredentialProvider implementação. TheIdentityProviderClaim
classe é o mesmo que já vimos na figura 41. É mostrado aqui novamente
para salientar os dois métodos (e a classe CredentialClaim). O
método ToIssuedClaim leva sem parâmetros e retorna uma instância da
classe IssuedClaim. O IssuedClaim classe é uma classe de dados simples que contém
os valores que são necessários na resposta de um determinado protocolo exe- cução. Um determinado protocolo de implementação pode consultar o IdP para uma lista de
instâncias de IssuedClaim para o usuário atual, como veremos na seção 4.11 na página 79.




78
4.10.1 mapeamento de reclamação
como mencionado na especi cação, deve ser possível alterar várias propriedades de uma reivindicação dependendo de quem o receptor do que a alegação é. Este
conceito é chamado de mapeamento de reclamação. É importante notar que não é o
valor de uma reivindicação que é alterada, mas apenas o nome de propriedades descritivas, O
NameFormat e ValueType.
Figura 43. Exibição de Esquema: Mapeamento de reivindicação a
Figura 43 mostra a entidade classes utilizadas para o mapeamento de reclamação do modelo, em
vista do esquema. O ClaimMappingDefinition é utilizado para mapeamento de ne uma reivindicação.
O mapeamento de uma reivindicação de nição tem um nome e uma descrição a propriedade, que de-
scribe a alegação de mapeamento. O mapeamento de uma reivindicação de nição é composta de zero
ou mais CredentialClaimMappings e/ou IdentityProviderClaimMappings.
Essas duas classes de ne um certo número de valores booleanos,OverrideName,OverrideNameFormat
e OverrideValueType. A semântica do estes valores são que se eles têm
o valor true , o correspondente novo valor (NewName, NewNameFormat, ou
NewValueType) será utilizado para substituir o valor original do crédito. Por def-
r ncia, uma alegação de mapeamento pertence a um protocolo ou uma conexão, e
este fato é modelado no classesProtocolClaimMapping andConnectionClaimMapping,
que mantenha as referências ao aClaimMappingDefinition e aConfiguredProtocol
e ConfiguredConnection respectivamente.
Como com todos os outros aspectos do modelo, existem serviços e repositórios para lidar com a leitura e escrita de dados de mapeamento de reclamação. O Mapeamento real de
reclamações é feito pela theClaimMappingService, mostrado na figura 44. O serviço
tem um método, GetMappedClaimsForUser, que tem três parâmetros, um
nome de usuário e um protocolo id e id de uma ligação No capítulo 7 Eu vou mostrar a
aplicação do presente método.




79
Figura 44. Modo de exibição de classe de mapeamento de Reclamação:
4.11. O sistema de tempo de execução
durante a execução de todos os componentes do modelo são orquestrados de uma forma que faz o sistema de trabalho. A Figura 45 mostra a seqüência de eventos que
acontecem quando o IdP recebe uma solicitação para um ponto de extremidade do protocolo.
Figura 45. Seqüência de solicitação de tempo de
cada uma das etapas é descrita abaixo.
BeginRequest nesta fase do IdP inicializa o IdPContext (explicado
na secção 4.11.1) e estabelece uma sessão. Todos os parâmetros de solicitação será
salva no IdPContext.
DetermineProtocol nesta fase, o IdP usa o URI solicitado ao de-
termine que especi c da implementação do protocolo para redirecionar a pedido. O presente protocolo será referido como o "protocolo de tratamento". Se o URI solicitado não corresponde a nenhum dos URIs expostos pelo con protocolos configurados é reportado um erro e um rastreamento de entrada é criado.
Durante esta fase, ValidateRequest do IdP permite que o protocolo de manuseio de
executar a validação, por exemplo (mas não se limitando a), a sábia- ness do pedido. Se a validação falhar é reportado um erro e um rastreamento




80
entrada é criada.
AuthenticationCheck durante esta fase, o IdP irá pedir o
protocolo de manuseio se o endpoint solicitada é que requer um usuário autenticado. Se este for o caso, a próxima fase será realizada; caso contrário ele pulará para a fase ProcessRequest. Se o usuário já estiver authenti-
lhão, o IdP pulará para a fase ProcessRequest.
DetermineCredentialProvider (opcional) durante esta fase do IdP determinará
quais fornecedores de credenciais foram con configurados. Se mais de um fornecedor tenha sido con configurados, o usuário será apresentada uma lista de possíveis fornecedores para escolher. Caso contrário haverá apenas um e que um é escolhido. O provedor de credenciais que em última análise recolhe as credenciais do usuário será referido como o "manuseio cre-
sistidas provedor".
Autenticação (opcional) nesta fase o provedor de credenciais de manuseio
irá recolher as credenciais do usuário e criar o conjunto de pedidos de credencial.
A credencial reivindicações serão armazenados no IdPContext.
MapUser durante esta fase, a identidade credencial de rolamento de reivindicação será
mapeado para uma ID do usuário no armazenamento do usuário
ProcessRequest durante esta fase o tratamento o protocolo que irá processar o
pedido como especi ed mediante a sua aplicação. Opcionalmente os créditos para
o usuário atual serão extraídos.
ExtractIdPClaims (opcional) durante esta fase IdPClaims do usuário
são extraídos. Se necessário, cada solicitação é mapeado como de ned no IdP con figuração. Primeiro um protocolo de mapeamento é realizado (se existir) e então um provedor de serviço de mapeamento é realizado. Além disso, todos os
pedidos de credencial que deve ser reemitido são promovidos a IdPClaims
SendResponse durante esta fase a resposta é enviada e a sequência
termina.
4.11.1 IdPContext
o IdPContext é a interface principal do IdP para plug-ins. Ela existe para tornar
mais fácil para qualquer plug-in para acessar o PDI da funcionalidade central sem ter de conhecer muitos detalhes sobre serviços e repositórios, mas também serve
como um espaço reservado para informações de estado entre solicitações HTTP.
A Figura 46 mostra o modo de exibição de classe de classe IdPContext. A classe não
tem um construtor público e em vez disso é implementada usando o padrão único- ton (como explicado em [Gamma et al . 1995]). O singleton instância




81
Figura 46. Vista: IdPContext classe
da classe é acessada através da propriedade Atual da classe. O
AuthenticationDone método deve ser chamado por um fornecedor de credenciais, mediante
autenticação bem sucedida do usuário. O método tem um argumento cujo
tipo é uma lista de instâncias CredentialClaim. Se por algum motivo a homologa- auten ticação Radius falhar, A autenticaçãofalhou método deve ser chamado pelo cre-
sistidas provedor. O método GetClaimsForUser é o único método que um
determinado protocolo de aplicação devem chamada. Este método retorna o mapeado créditos para o usuário atual, dado um protocolo de identificação e um ID de conexão O
usuário detém a propriedade username do usuário, se a pessoa que faz
o pedido está conectado no momento (indicado pelo utilitário IsLoggedIn- nerador
). Por último, theShouldTrace e funções de Rastreamento TraceService,
e os seus homólogos de log estão sendo expostos aqui.
4.11.2 EndpointService
em geral, quando você solicitar um URI, tais ashttp://Www.example.com/index.html,
a última parte do URI, neste caso index.html, corresponde a uma le no
servidor web. No IdP, contudo, não são solicitadas. física les Em vez disso, aquilo que é pedido são virtuais de terminação que mapa para alguns implementação que sabe como responder. Isso torna mais fácil para carregar novos plug-ins, porque um plug-in pode ser apenas uma única le, nomeadamente a dll contendo sua im- R ealização. Por conseguinte, quando o IdP recebe uma solicitação, ela deve ser capaz de nd qual plug-in deve processar o pedido. Isso é feito apesar de o
EndpointService.




82
Figura 47. Modo de exibição de classe: EndpointService
Figura 47 mostra a classe EndpointService e respectivas classes. O
EndpointService de nes um único método, GetEndpointForPath que tem
um único argumento, um caminho e que retorna uma instância de IEndpoint que
sabe responder a solicitações para esse caminho. O
método utiliza internamente theConfiguredProtocolRepository GetEndpointForPath andConfiguredCredentialProviderRepository
para nd todos os pontos de terminação. Ele então usa o EndpointHandlesPathSpecification
para determinar qual o endpoint possam lidar com o caminho.
4.12. Relato de eventos
durante o tempo de execução do IdP deve relatar os acontecimentos de uma forma que os administradores de sistema podem ver o que está acontecendo em termos de erros inesperados, con- guração erros, mas também em termos das acções tomadas pelos usuários e o administrador ou administradores de si. Relatórios destes eventos será dividido em dois di entravarão um conceitos; o registro e o rastreamento. Ambas as entradas de log e




83
entradas de rastreamento deve ser salvo no banco de dados em virtude da natureza do IdP sendo uma aplicação de software como serviço. Em um aplicativo, o admin- istrator não terão acesso a les na máquina onde o aplicativo é executado e portanto por escrito essas entradas para uma le no disco não é tão bom como uma opção por escrito para uma tabela em um banco de dados. Tendo essas informações em um banco de dados permite a consulta de ricos recursos que não são o rido pelo texto simples les, algo que será bastante útil quando precisar exibir os
dados em um gráfico de interface de usuário da web
4.12.1 efetuando login
como mencionado acima, o registo tem a ver com os eventos que acontecem no sistema como parte do uso normal. O registro de tais eventos irá permitir que os administradores do sistema que fez alterações ao sistema e quando. Além disso que lhe permite ver as informações sobre a atividade do usuário. Este é, por exemplo, útil para empresas que precisam de cumprir a norma Dinamarquesa para a
segurança da informação (DS-484). Uma única unidade de registro de dados será chamada uma entrada de log
e sua classe correspondente será chamado LogEntry. Um log de entrada é sempre
acoplado a uma fonte de log. Uma fonte de log é utilizado para de ne as peças do
sistema que escrever entradas de log. Isso é útil para agrupar entradas de log e pode também ser usado para activar logging e s para di entravarão um partes do IdP. O IdP será em si mesmo de ne um conjunto de fontes de registro, mas as fontes de registro também pode ser
de nida para plug-ins como veremos abaixo na seção 4.2.1. TheLogEntry e
classes LoggingSource contém os seguintes euratomdoconselho mostrada na Figura 48.
Figura 48. Exibição de Esquema: LogEntry e LoggingSource




84
Como a Figura 48 mostra, cada entrada de log contém um carimbo de data e hora de quando
a entrada de log foi criado (EntryDateTime) e alguns mensagem (EntryText).
Ele também contém o id da fonte de log ele pertence. Note que a relação entre os dois é indicada por uma seta. Você pode ter percebido
outra seta a apontar para a classe LogEntry. Seta que representa a
relação com a classe de usuário, incorridos pelo id de propriedade. Por último,
uma entrada de log também contém um SessionId. Uma sessão é um conceito bem conhecido
quando trabalhar com aplicativos web e desde o IdP é uma aplicação de web que faz sentido para efetuar o id da sessão, de tal forma que todas as entradas de log para uma determinada sessão pode ser encontrado. Uma fonte de log também tem um ID exclusivo, um nome e uma
descrição. Por último, tem também um habilitado AG, que é usado para determinar
se o registro para uma determinada fonte está ligado ou o . Temos agora de ned que tipo de dados uma entrada de log contém, mas não é claro o modo como ela está a ser utilizado. De facto, como poderia um utilizador da classe saber o ID exclusivo para atribuir a entrada do log, qual o id do usuário atual é, ou até mesmo o que é o id exclusivo do registro de fonte. Temos de nitely necessidade de alguma forma de facilitar o registo. O que nós queremos é provavelmente uma espécie de classe de serviço com uma função que tem dois parâmetros; o nome de uma fonte de log e algum texto. A
classe LoggingService teria então a responsabilidade de criar uma nova
instância de um LogEntry e ll nos parâmetros ausentes. Mas logging
implica muitas vezes construir grandes mensagens de texto, que leva tanto tempo e memória. Então o que é que se o log foi girado o para o registro atual fonte? Neste caso, o chamador pode decidir não construir a mensagem. Por isso o nosso serviço de registo tem de ter uma função para ajudar o chamador determine se o registro detalhado
estiver ativado para uma determinada fonte de log. A Figura 49 mostra theLoggingService
classe.
Figura 49. Modo de exibição de classe de classe de serviço de Registro:
a função ShouldLog toma um único parâmetro, a saber o nome de uma
fonte de log e retorna Verdadeiro se o log está ativado para que a fonte de log.
A fim de executar a lógica correcta, o LoggingService precisa para interagir





com outros componentes de 85 o sistema. A Figura 50 mostra que outros compo-
nentes a classe LoggingService interage. Note que o Negrito Itálico texto
sobre ou abaixo de cada componente indica qual o tipo de objeto é em termos de
design orientado por domínio.
Figura 50. Modo de exibição de classe de serviço de Registro: interações
permite começar por considerar a mais simples das duas funções, designadamente a
função ShouldLog. Como mencionado esta função tem um único parâmetro,
o nome da fonte de log. Quando chamado, a chamadas de função
função theFindByName ShouldLog sobre theLoggingSourceRepository, que retorna a
instância correspondente da classe LoggingSource. A função pode agora
verificar a propriedade de theLoggingSource theEnabled instância para determinar o que
ele deve retornar. A função Log tem dois parâmetros, nomeadamente um
nome de fonte de log e uma mensagem de . Primeiro de tudo, chamadas de função ShouldLog para
determinar se o registro detalhado estiver ativado para a actual fonte de log. Se não for este o caso, a função pode retornar. Isto significa também que os chamadores não
têm para chamar a função ShouldLog, mas que podem fazê-lo, se desejarem.
Se a função determina que o log é habilitado, começa pela criação de uma nova
instância da classe LogEntry e lls no LogEntryText, e a
hora atual. Ele chama o LoggingSourceRepository para obter a correta instância da
classe LoggingSource a partir de onde ele pode recuperar o LoggingSourceId.
Finalmente ele lê a SessionId e ID de propriedades a classe IdPContext.
A classe IdPContext será explicado mais adiante, mas por agora apenas aceitar que
sabe que o id do usuário atual e o id da sessão Por último, chamadas de função
a função Adicionar LogEntryRepository sobre o que leva a uma instância de um
LogEntry como um parâmetro.




86
4.12.2
Rastreamento Rastreamento tem para com a gravação de eventos que estejam relacionados a erros e debug- nalmente o sistema. Temos de ne 4 níveis de rastreamento de erro; erro crítico, de aviso e de informação. Uma única unidade de rastreamento de dados será chamada uma entrada de rastreamento
e ter uma classe chamada TraceEntry correspondente. Entradas de rastreamento precisam ser
escritos para o banco de dados para a mesma razão que entradas de log necessário para ser gravados no banco de dados. No entanto, há um pequeno di erência aqui. Uma vez que o rastreamento é utilizado para reportar erros, qualquer traço de entradas com nível de rastreio crítica também serão escritos para a le no disco. Isto é especialmente útil quando se lida com erros que têm a ver com a falta de conectividade de banco de dados, mas o le seria obviamente apenas acessível aos mantenedores do todo o software como um serviço- solução. Deve ser possível para ativar o rastreamento em e s , especialmente para aviso e informações de rastreamento em nível de entradas. Também será possível rodar o erros, mas contudo não será possível desativar o rastreamento de erros críticos. Dados sobre se deve ou não de rastreamento é ativado para di entravarão um níveis é encapsulado em um conceito chamado de um traçado pro le. Como antes de criarmos um Ser-
vice para facilitar a adição de entradas de rastreamento. O TracingService e as classes que interage com são mostrados na figura 51.
Figura 51. Modo de exibição de classe de serviço de rastreamento: interações
Figura 51 mostra que a adição de entradas de rastreamento é em muitos aspectos semelhante à adição de
entradas de log. As coisas mais importantes para perceber é que é um
objeto de valor theTraceProfile e não uma entidade objetos. Isto é porque um traçado pro le não tem uma identidade e quaisquer duas instâncias da classe pode ser considerado
o mesmo se os seus valores são idênticos. Em segundo lugar, theTraceEntryFileWriter




87
é usado para a gravação de entradas para um rastreamento de le no disco. A função de Rastreamento do
TracingService toma como parâmetros uma mensagem e um nível de rastreio e em-
vokes NO BOTÃOADICIONAR função no TraceEntryRepository everytime e a
função Adicionar no TraceEntryFileWriter sempre que o nível de rastreio é definido para
crítico.
4.13. Idioma onipresente
o modelo descrito no presente capítulo deixou-nos com um amplo onipresente
linguagem, e pode ser resumido do seguinte modo: O IdP é um aplicativo
que une créditos aos usuários. O IdP é extensível através de plug-ins. Existem
dois tipos de plug-ins plug-ins do provedor de credenciais e protocolo plug-
ins. Um provedor de credenciais plug-in pode autenticar um usuário, e o resultado de
uma autenticação é um conjunto de pedidos de credencial. Um plug-in de protocolo envia
informações sobre um usuário e suas reclamações para algum outro partido, chamado de um provedor de serviços. Ambos os protocolos e fornecedores de credenciais pode confiar nas ligações
para descrever a forma como eles se comunicam com outros sistemas. Quando um protocolo
envia informações sobre um usuário de um provedor de serviços, ele envia um conjunto de créditos emitidos. Uma alegação emitido provém de uma reclamação de credenciais ou de um
pedido do provedor de identidade, que é uma reivindicação de ned no IdP. O conjunto de
créditos emitidos que são enviados podem ter sofrido aclaim mapeamento. Uma alegação de mapeamento
é um mecanismo que altera qualquer aspecto de um conjunto alegação, exceto o seu valor. Existem
dois tipos de reclamação di entravarão um mapeamentos, nomeadamente reclamação protocolo mapeamentos
e mapeamentos de reclamação de ligação. Os dois são conceptualmente idêntico mas
o protocolo de mapeamento de reclamação é sempre realizada rst. Os usuários são criados no
IdP através de auto-registro, importação ou convite. Cada aspecto do
IdP podem ser configurados através de conjuntos de configuração con, que contêm
elementos de configuração entravarão um di. Quando algo no IdP falhar, uma entrada é
criada no traçado, e quando ocorre um evento importante, é criado um registo de entrada.




Capítulo
5
mapas objeto-relacional
mais modernos sistemas de TI dependem de bancos de dados para armazenar dados do aplicativo e o esquema de banco de dados utilizado é de facto uma parte importante do modelo Domínio.
Como vimos no Capítulo 3, a de nição de um modelo é um modelo flexível que pode ser facilmente alterado. No entanto, quando usando um tradicional camada de acesso aos dados, alterar o esquema do banco de dados que potencialmente requerem muitas alterações nos dados de classes de acesso e domínio de objetos. Vamos considerar o seguinte
exemplo simples, onde temos aUser tabela, uma classe de domínio de usuário, um
repositório UserRepository classe e um classe de fábrica UserFactory. A tabela de nição talvez algo parecido com isto:
Usuário Tabela
1 -- O usuário tabela
2 Criar Tabela [idp].[usuário](
3 OID INT IDENTIDADE(1,1) NÃO NULO,
4 UserName nvarchar(128) NÃO NULO,
5 DateCreated DateTime NÃO NULO PADRÃO GetDate(),
6 [Password] nvarchar(128) NÃO NULO,
7 PasswordSalt nvarchar(128) NÃO NULO,
8 CONSTRANGIMENTO [PK_User] Chave Primária em cluster ([OID])
9 )
uma classe de domínio de usuário poderia ter esta aparência:
domínio de usuário Classe
1 usando o sistema;
2 3 namespace IdP
4 {
5 public class User
6 {
7 int público OID { GET; definir;}
8 seqüência pública UserName { GET; definir; }
9 público Senha string { GET; definir; }
10 seqüência pública PasswordSalt { GET; definir; }
11 DateTime DateCreated { GET; definir;}
12 13 Usuário público(int oid, string userName, DateTime dateCreated, senha String, String passwordSalt)
14 {
15 OID = oid;
16 UserName = Nome de usuário;
17 DateCreated = dateCreated;
18 Senha = senha;
19 PasswordSalt = passwordSalt;
20 }
88




89
21 }
22 }
um repositório com métodos para um determinado utilizador nd, pelo nome ou pelo id,
poderia ter a seguinte aparência:
repositório do usuário Classe
1 usando o System.Data.SqlClient;
2 3 namespace IdP
4 {
5 public class UserRepository
6 {
7 usuário público GetUserById(int oid)
8 {
9 string sql = "select OID, nome de usuário e senha de usuário PasswordSalt, DateCreated onde OID = @oid";
10 usando (SqlConnection conn = new SqlConnection("uma string de conexão válida"))
11 {
12 conn.open();
13 SqlCommand Cmd = new SqlCommand.sql, conn);
14 cmd.Parâmetros.AddWithValue("oid", OID);
15 SqlDataReader reader = cmd.ExecuteReader();
16 17 UserFactory retorno.FromReader(leitor);
18 }
19 }
20 21 Usuário público GetUserByName(string userName)
22 {
23 string sql = "select OID, nome de usuário e senha de usuário PasswordSalt, DateCreated onde UserName = @UserName";
24 usando (SqlConnection conn = new SqlConnection("uma string de conexão válida"))
25 {
26 conn.open();
27 SqlCommand cmd = new SqlCommand.sql, conn);
28 cmd.Parâmetros.AddWithValue("UserName", Usuário);
29 SqlDataReader reader = cmd.ExecuteReader();
30 31 UserFactory retorno.FromReader(leitor);
32 }
33 }
34 }
35 }
e nitivamente uma fábrica que é capaz de traduzir um registro de aSqlDataReader
para uma instância da nossa classe de domínio de usuário, poderia ter esta aparência:
Fábrica do Usuário Classe
1 usando o sistema;
2 usando System.Data.SqlClient;
3 4 namespace IdP
5 {
6 public class UserFactory




90
7 {
8 estáticos públicos FromReader usuário(SqlDataReader reader)
9 {
10 se(reader.read())
11 {
12 int oid = (int) reader["OID"];
13 string userName = reader["UserName"].ToString();
14 senha string = reader["senha"].ToString();
15 string passwordSalt = reader["PasswordSalt"].ToString();
16 DateTime dateCreated = (DATAHORA) reader["DateCreated"];
17 18 retorna o novo usuário(oid, usuário, dateCreated, senha passwordSalt);
19 }
20 21 retornar null;
22 }
23 24 }
25 }
classes anterior mostrar como podemos implementar o acesso a dados para uma
tabela Usuário usando os blocos de construção de design orientado por domínio. No entanto,
se adicionar outro domínio a tabela Usuário? Isso exigiria a
atualização da tabela, acrescentando um outro domínio para o domínio do usuário classe,
atualizando os dois comandos Select e a adição de outra linha de código para o método de fábrica. Escusado será dizer que se tivéssemos um grande banco de dados de esquema, usando esta abordagem não teria um design flexível especialmente, uma vez que mesmo pequenas alterações no modelo de lógica exigiria bastantes alterações ao código. Neste capítulo iremos ver como podemos aproveitar o poder da relação de objeto mapas para criar um design mais flexíveis e sustentáveis. Objeto-relacional mapas são ferramentas de software que mapear automaticamente os quadros de um esquema de banco de dados para classes em uma linguagem de programação completa, com consultas e métodos de atualizar e excluir. Para .Net, existem inúmeras alternativas, os dois mais recursos completos sendo NHibernate e LINQ para o SQL. LINQ para SQL é parte do .Net 3.5 framework e tem sido desenvolvida em estreita cooperação com a equipe do SQL Server para alto desempenho quando usado com um banco de dados SQL Server. Uma vez que as especifi cação me obriga a usar um banco de dados do SQL Server e eu já estou usando o .Net Framework 3.5, usando o LINQ para SQL parece uma
escolha natural.




91
5.1. LINQ
LINQ significa language-Integrated Query e fornece um conjunto de operadores de consulta padrão que pode ser usado diretamente em qualquer linguagem .Net. Consulta ex- inserida no LINQ bene t de verificação de sintaxe de tempo de compilação, estática digitando
9 e intellisense . A consulta padrão de operadores a aplicar para IEnumerable <T>
Qual é a interface implementada por cada enumerador (matriz e especial-
comunitarizem Coleções) em .Net sobre um tipo genérico T. o exemplo de código a seguir mostra a sintaxe de uma consulta LINQ padrão.
LINQ exemplo
;} 1 String[] nomes = { "Burke", "Connor", "Frank", "Everett", "Albert", "George", "Harris", " David"
IEnumerable 2 3 <string>Consulta = a partir de s em nomes
4 onde s.length == 5
5 ascendentepor endereços s
6 selecione s.ToUpper();
7 8 foreach (string item na consulta)
9 Console.WriteLine(item);
10
há várias coisas interessantes a nota sobre o código acima. Primeiro de
tudo, a ré sintaxe da consulta, tendo em ado palavra-chave no início
da expressão. Isso foi necessário para tornar o Intellisense trabalho. A coisa mais importante a comunicação, contudo, é que a sintaxe SQL como no exemplo é apenas açúcar sintático no topo de um conceito chamado de métodos de extensão. Métodos de extensão são métodos estáticos que são declarados fora de uma classe a que trabalho e o trouxe em âmbito importando o namespace onde são declaradas. O exemplo a seguir mostra como um
método de extensão para a classe de usuário poderia ser implementado.
Ramal do usuário
1 namespace IdP
2 {
3 estáticos públicos UserExtensions classe
4 {
5 int UserNameLength estáticos públicos(este usuário u)
6 {
7 volta u.UserName.Comprimento;
8 }
9 }
10 }
9 Intellisense é o recurso de auto-completar no IDE do Visual Studio




92
Nota o especial esta palavra-chave, que informa ao compilador que o método se aplica para o tipo de usuário. Importando o namespace onde o
método de extensão é de ned, agora posso chamar a função UserNameLength diretamente na
classe de usuário.
1 usuário u = UserRepository.GetByName("Klaus");
2 int len = u.UserNameLength();
assim como isso se aplica ao LINQ query mostrada acima? Bem, como homens- tivas, a sintaxe do exemplo acima é meramente sintático açúcar e contabi-
se traduz em um conjunto de métodos de extensão sobre IEnumerable <T>. Isto significa que a consulta acima poderia ser reescrito para esta:
LINQ exemplo 2
;} 1 String[] nomes = { "Burke", "Connor", "Frank", "Everett", "Albert", "George", "Harris", " David"
IEnumerable 2 3 <string>Consulta = nomes.Onde(s =&gt; s.length == 5).OrderBy do(s =&gt; s).Selecione(s =&gt; s.

ToUpper());
4 5 foreach (string item na consulta)
6 Console.WriteLine(item);
7 8 Console.ReadLine();
o exemplo mostra como métodos de extensão sobre IEnumerable <T>São usados para
expressar a consulta. Note que o resultado da aplicação de um método de extensão
para um LINQ IEnumerable <T>É em si mesmo um IEnumerable <T>, o que nos permite manter a
aplicação de métodos de extensão como o exemplo mostra. A assinatura da ex-
tensão métodos utilizados isthis IEnumerable <T>Fonte, Func <T, bool>Predicado).
O FUNC tipo é uma expressão do tipo T para bool, que é escrito como uma
expressão lambda, tais como s =&gt; s.length == 5 no exemplo. A
lista completa de operadores de consulta de Ned por LINQ pode ser visto na Tabela 5.1.
A LINQ exemplos que vimos até agora têm sido muito boas para fins illustratory, contudo eles não têm nada a ver com o LINQ para SQL. Como uma questão de facto, LINQ para SQL é uma extensão do que vimos até agora e que é chamado o LINQ para objetos. A Figura 52 mostra o di avours entravarão um de LINQ que
são o rido pelo enquadramento.
A Figura 52 mostra que existem três di entravarão um LINQ ativado fontes de dados a objetos LINQ LINQ para XML e o LINQ ativado ADO.Net. Já vimos como o LINQ para objetos funciona nos exemplos acima.
LINQ para XML oferece a consulta integrada à linguagem para documentos XML e LINQ ADO.Net permite fornece language integrated consultas para





restrição de projecção relacional 93 Onde Selecionar, SelectMany ascendentepor endereços, então ignorado por encomenda, inverta o agrupamento de agrupamento Quanti qualquer um, ers, contém o particionamento tomar, pular TakeWhile, SkipWhile
conjuntos distintos, Europeia, Interceptar, excepto
elementos primeiro, FirstOrDefault, Contagem de agregação ElementAt LongCount, Soma, Min, Max, Média,

Conversão, ToList ToArray agregada, ToDictionary, AsEnumerable,
ToLookup, prematura,
elemento fundido, FirstOrDefault Primeiro, Último, LastOrDefault, único,
SingleOrDefault, ElementAt, ElementAtOrDefault
DefaultIfEmpty,
figura 52. LINQ.
armazenamentos de dados. ADO.Net constitui o quadro para a manipulação de dados relacionais, e habilitado para o LINQ ADO.Net consiste de três tecnologias de entravarão um di




94
Figura 53. LINQ para banco de dados SQL contexto (Design view).
LINQ para datasets, o LINQ para SQL e LINQ para entidades. LINQ para datasets é uma extensão para o dataset de memória em classes do .Net framework e LINQ para entidades é o LINQ extensão da entidade .Net framework , um quadro de esquemas de dados conceitual de Ning, chamados de modelos de dados entidade.
LINQ para entidades ainda não provou ser maduro, principalmente porque carece de suporte da ferramenta no IDE, mas é dito que ele se tornará o predecessor de
LINQ para SQL.
5.2. LINQ para SQL
como com o LINQ para objetos, LINQ para SQL também suporta verificação de tipo de tempo de compilação. Isto é conseguido através do que é chamado de um contexto de dados . Um contexto de dados é uma classe que tem várias responsabilidades. Em primeiro lugar, o contexto de dados contém informações sobre qual banco de dados para se conectar ao . Além disso, contém de nições para as classes que representam as tabelas no banco de dados e ele nitivamente faixas na memória as alterações feitas para as instâncias dessas
classes.
Usando o IDE podemos criar um novo contexto de dados e arraste a tabela Usuário
na superfície de design, como mostrado na figura 53.




95
que vimos agora que podemos facilmente arrastar tabelas no nosso contexto de dados para gerar a classe correspondente. Agora vamos ver que tipo de código é gerado
nos bastidores.
Contexto dados LINQ
1 #pragma aviso desativar 1591
2 //------------------------------------------------------------------------------
3 // <auto−generated>
4 // Este código foi gerado por uma ferramenta.
5 // Versão Runtime:2.0.50727.1433
6 //
7 // Muda para este ficheiro pode causar comportamento incorrecto e serão perdidas se
8 // o código é gerado novamente.
9 // </auto−generated>
10 //------------------------------------------------------------------------------
11 12 namespace IdP
13 {
14 usando System.Data.Linq;
15 usando o System.Data.Linq.; mapeamento
16 usando o System.Data;
17 usando o System.Coleções.genéricos;
18 usando o System.Reflection;
19 usando o System.Linq;
20 usando o System.Linq.Expressões;
21 usando System.ComponentModel;
22 usando sistema;
23 24 25 [System.Data.Linq.Mapping.DatabaseAttribute(name="IdPDatabase")]
26 classe IdPDataClassesDataContext parcial público : System.Data.Linq.DataContext
27 {
28 29 estática privada System.Data.Linq.Mapping.MappingSource mappingSource = novo AttributeMappingSource();
30 31 #região Método Extensibilidade definições
32 OnCreated parcial void();
33 InsertUser parcial void(User exemplo);
34 UpdateUser parcial void(User exemplo);
35 DeleteUser parcial void(User exemplo);
36 #endregion
37 38 IdPDataClassesDataContext público() :
39 base(global::IdPTestApp.Properties.Settings.Default.

SafewhereConnectionString, mappingSource)
40 {
41 OnCreated();
42 }
43 44 IdPDataClassesDataContext pública(string de conexão) :
45(ligação, mappingSource)
46 {
47 OnCreated();
48 }
49 50 IdPDataClassesDataContext pública(System.Data.IDbConnection ligação) :




96
51(ligação, mappingSource)
52 {
53 OnCreated();
54 }
55 56 IdPDataClassesDataContext pública(string ligação, System.Data.Linq.Mapeamento.

MappingSource mappingSource) :
57(ligação, mappingSource)
58 {
59 OnCreated();
60 }
61 62 IdPDataClassesDataContext pública(System.Data.IDbConnection ligação, Sistema .Data.Linq.Mapping.MappingSource mappingSource) :
63(ligação, mappingSource)
64 {
65 OnCreated();
66 }
67
68 público System.Data.Linq.na tabela <User>Os usuários
69 {
70 obtenha
71 {
72 voltar este.GetTable <User>();
73 }
74 }
75 }
76 77 [Tabela(name="idp.[usuário]")]
78 público Utilizador de classe parcial : INotifyPropertyChanged INotifyPropertyChanging,
79 {
80 81 PropertyChangingEventArgs estática privada emptyChangingEventArgs = novo PropertyChangingEventArgs(String.Vazio);
82 83 privados int _OID;
84 85 string privado _UserName;
86 87 Sistema privado.DateTime _DateCreated;
88 89 Sistema privado.anulável <System.DateTime>_LastLogin;
90 91 string _Senha privada;
92 93 privadas string _PasswordSalt;
94 95 #região Método Extensibilidade definições
96 parcial void OnLoaded();
97 parcial void OnValidate(System.Data.Linq.ChangeAction acção);
98 OnCreated parcial void();
99 OnOIDChanging parcial void(int);
100 parcial void OnOIDChanged();
101 OnUserNameChanging parcial void(String Value);
102 parcial void OnUserNameChanged();
103 OnDateCreatedChanging parcial void(System.DateTime valor);
104 parcial void OnDateCreatedChanged();




97
105 OnLastLoginChanging parcial void(Sistema.anulável <System.DateTime>Valor);
106 OnLastLoginChanged parcial void();
107 OnPasswordChanging parcial void(String Value);
108 OnPasswordChanged parcial void();
109 OnPasswordSaltChanging parcial void(String Value);
110 parcial void OnPasswordSaltChanged();
111 #endregion
112 113 Usuário público()
114 {
115 OnCreated();
116 }
117 118 [coluna(Storage="_OID", AutoSync=AutoSync.OnInsert, DbType="Int NÃO NULO identidade", IsPrimaryKey=true, IsDbGenerated=true)]
119 público int OID
120 {
121 obtenha
122 {
123 voltar este._OID;
124 }
125 definir
126 {
127 se ((._OID != valor))
128 {
129 este.OnOIDChanging(valor);
130 este.SendPropertyChanging();
131._OID = valor;
132 este.SendPropertyChanged("OID");
133 este.OnOIDChanged();
134 }
135 }
136 }
137 138 [coluna(Storage="_UserName", DbType="NVarChar(128) NÃO NULO", CanBeNull=false )]
139 seqüência pública UserName
140 {
141 obtenha
142 {
143 voltar este._UserName;
144 }
145 definir
146 {
147 se ((._UserName != Valor))
148 {
149 este.OnUserNameChanging(valor);
150 este.SendPropertyChanging();
151._UserName = valor;
152 este.SendPropertyChanged("UserName");
153 este.OnUserNameChanged();
154 }
155 }
156 }
157 158 [coluna(Storage="_DateCreated", DbType="DateTime NÃO NULO")]
159 Sistema público.DateTime DateCreated




98
160 {
161 obtenha
162 {
163 voltar este._DateCreated;
164 }
165 definir
166 {
167 se ((._DateCreated != valor)
168 {
169 este.OnDateCreatedChanging(valor);
170 este.SendPropertyChanging();
171._DateCreated = valor;
172.SendPropertyChanged("DateCreated");
173 este.OnDateCreatedChanged();
174 }
175 }
176 }
177 178 [coluna(Storage="_LastLogin", DbType="DateTime")]
179 Sistema público.anulável <System.DateTime>LastLogin
180 {
181 obtenha
182 {
183 voltar este._LastLogin;
184 }
185 definir
186 {
187 se ((._LastLogin != valor)
188 {
189 este.OnLastLoginChanging(valor);
190 este.SendPropertyChanging();
191._LastLogin = valor;
192 este.SendPropertyChanged("LastLogin");
193 este.OnLastLoginChanged();
194 }
195 }
196 }
197 198 [coluna(Storage="_password", DbType="NVarChar(128) NÃO NULO", CanBeNull=false )]
199 público Senha string
200 {
201 obtenha
202 {
203 voltar este._password;
204 }
205 definir
206 {
207 se ((._Password != valor)
208 {
209 este.OnPasswordChanging(valor);
210 este.SendPropertyChanging();
211._Password = valor;
212 este.SendPropertyChanged("SENHA");
213 este.OnPasswordChanged();
214 }




99
215 }
216 }
217 218 [coluna(Storage="_PasswordSalt", DbType="NVarChar(128) NÃO NULO", CanBeNull= FALSE)]
219 seqüência pública PasswordSalt
220 {
221 obtenha
222 {
223 voltar este._PasswordSalt;
224 }
225 definir
226 {
227 se ((._PasswordSalt != valor))
228 {
229 este.OnPasswordSaltChanging(valor);
230 este.SendPropertyChanging();
231._PasswordSalt = valor;
232 este.SendPropertyChanged("PasswordSalt");
233 este.OnPasswordSaltChanged();
234 }
235 }
236 }
237 238 evento público PropertyChangingEventHandler PropertyChanging;
239 240 evento público PropertyChangedEventHandler PropertyChanged;
241 242 protegidos SendPropertyChanging virtual void()
243 {
244 se ((Esta.PropertyChanging != null))
245 {
246 este.PropertyChanging(esta, emptyChangingEventArgs);
247 }
248 }
249 250 protegidos SendPropertyChanged virtual void(String propertyName)
251 {
252 se ((Esta.PropertyChanged != null))
253 {
254 este.PropertyChanged(esta, novo PropertyChangedEventArgs( propertyName);
255 }
256 }
257 }
258 }
259 #pragma aviso restaurar dados de contexto
o LINQ 1591 dados principais classe do contexto começa na linha 25. Está decorado com uma
DatabaseAttribute que de nes o nome do banco de dados se conecta.
Observe também que é declarada como parcial, o que significa que ele pode estendido.
Classes parciais são especialmente úteis quando uma parte da classe parcial é gerado automaticamente por uma ferramenta, porque significa que podemos de ne outros meth-




100
ods e euratomdoconselho da mesma classe em um outro le, que não será mais- escritos se executar a geração de código de ferramenta novamente. A classe herda o
System.Data.Linq.DataContext classe, que contém a maior parte da lógica para o
rastreamento de alterações de objeto de conexão com o banco de dados confirmando alterações
etc
nas linhas 32-35 nós nd um conjunto de métodos de extensibilidade, novamente declarada
parcial. Estes métodos permitem implementar lógica extra sempre que
objetos de usuário são inseridos, atualizada ou excluída.
Linhas 38-66 contêm vários construtores sobrecarregados. Na linha 68 podemos
ver uma propriedade pública chamada Usuários. Este é o domínio que podemos usar para
executar consultas LINQ, como veremos em um exemplo em breve. O
tipo de retorno da propriedade isTable <User>. O genericTable <T>O tipo é
parte integrante do LINQ para SQL e implementa a tradução de
expressões LINQ para instruções SQL real. Essa classe implementa o
IEnumerable de tabela <T>Interface e pode assim fazer uso da extensão métodos
mencionados anteriormente. No entanto, embora possam ser utilizados, o LINQ para
objetos métodos de extensão não deve ser usado com a tabela <T>Classes. Isto é
porque o LINQ para objetos métodos de extensão são executados imediatamente na
IEnumerable subjacentes <T>Instância. Se você se lembrar o exemplo da
página 92, aplicamos três métodos de extensão para uma matriz. Se conseguirmos fazer isso com os dados a partir de uma tabela de banco de dados SQL, e tornam buscar todas as linhas na memória e não a lógica de selecção sobre a representação de dados na memória.
Tal seria potencialmente prejudicar o desempenho do aplicativo e em geral seria uma utilização abusiva dos recursos do RDBMS. Este problema tem sido superados pelos designers de LINQ para SQL. A forma como tem
sido feito, é que a tabela <T>Classe implementa outra interface, chamado
IQueryable <T>, para que todos o mesmo ramal métodos têm sido de ned,
mas com outra aplicação interna, naturalmente. Em LINQ para o SQL, qualquer
consulta sobre uma mesa <T>Não é executado até que você iterar sobre o resultado. Este
comportamento nos permite compor uma consulta complexa de várias peças menos complexas sem executar a consulta real antes de nós iterar sobre o resultado. Quando começamos a iteração do resultado, uma consulta SQL é gerado automaticamente
os bastidores e executadas contra o banco de dados.
Na linha 77 temos a de nição de classe está documentadono. A classe do usuário tiver uma
tabela atributo que inclui informações sobre o nome real da tabela no
banco de dados. Além disso, está documentadono classe implementa theINotifyPropertyChanging
INotifyPropertyChanged e interfaces que permitem o LINQ para SQL para via




101
em memória de dados alterações. Para além de que a classe Usuário tem todos os ex-
propriedades inesperado, como OID, usuário etc., e todas estas propriedades são
decorados com atributos que diga alguma coisa sobre a coluna do banco de dados, nome do banco de dados de tipo de coluna etc o exemplo abaixo mostra como podemos utilizar
os dados de contexto para consultar a tabela Usuário.
LINQ para SQL exemplo
1 usando(var ctx = novo IdPDataClassesDataContext()
2 {
3 //Localizar os usuários com um nome de usuário de comprimento 5
4 5 var resultado = a partir de u em ctx.Os utilizadores
6 onde u.UserName.length == 5
7 ascendentepor endereços u.OID
;U 8 selecione
9 10 //ou
11 12 var resultado2 = ctx.Os utilizadores.Onde(u =&gt; u.UserName.length == 5).ascendentepor endereços(u =&gt; u.OID).Selecione(u =&gt; u);
13 14 //podemos refinar ainda mais os resultados através da adição de uma cláusula especificando que extra onde OID deve ser maior que 100
15 var resultado3 = resultado2.Onde(u =&gt; u.OID &gt; 100).Selecione(u =&gt; u);
16 17 //a consulta não é executada contra o banco de dados antes de nós iterar sobre o resultado
18 foreach(var usuário no resultado3)
19 {
20 Console.WriteLine(user.Username);
21 }
22 }
Note que o var keyword é uma taquigrafia que podem ser usados onde o
compilador pode inferir o tipo examinando o tipo de o que é atribuído à
variável. Neste caso, todas as três variáveis declaradas usando thevar palavra-chave são
realmente do tipo IQueryable <User>.
Um recurso muito bom de LINQ para SQL é a sua capacidade de traduzir expressões genérico para declarações SQL. Podemos aproveitar esta capacidade de declarar o nosso orientado por domínio designspeci catiões como LINQ expressões, permitindo assim nós ter especi cações que pode ser usado tanto no código e no banco de dados.
No capítulo 3 vimos um exemplo de uma especi cação chamado pólder,
que continha a de nição de um utilizador criado recentemente. Poderíamos estender
a classe Usuário gerado pelo contexto de dados para incluir um método que
nos poderia dizer se um usuário foi criado recentemente:
estendendo a classe Usuário
1 usando o sistema;
2 3 namespace IdPTestApp




102
4 {
5 públicos Utilizador de classe parcial
6 {
7 estáticos públicos Func <User, bool>Espec = (usuário =&gt; User.DateCreated &gt; DateTime.Agora.

AddDays(-10));
8 9 público bool IsRecentlyCreated()
10 {
11 Retornar spec.invoke(esta);
12 }
13 }
14 }
Nota a variável estática chamado spec. Essa variável pode ser usada em um LINQ
para SQL Query demasiado. Se pretendemos que todos os usuários do nd recentemente criada no banco de dados, podemos reutilizar essa mesma expressão LINQ, como mostrado no
exemplo a seguir.
Usando a especificação para consultar o banco de dados
1 usando (var ctx = novo IdPDataClassesDataContext()
2 {
3 //Procurar recentemente criado utilizadores
4 5 var resultado = ctx.Os utilizadores.Onde(User.spec).Selecione(u =&gt; u);
6 7 foreach (var usuário no resultado)
8 {
9 Console.WriteLine(user.Username);
10 }
11 }
neste elegante, podemos assegurar que a nossa lógica de domínio só é de nida
em um único lugar, tornando a manutenção muito mais fácil.




Capítulo
6
um componente de domínio neutro
no Capítulo 5 vimos como LINQ para SQL obras, e neste capítulo iremos explorar como podemos aproveitar os recursos do LINQ para o SQL para criar um componente de domínio neutro que podem apoiar o desenvolvimento usando o domínio-
conduzido conceitos de design.
No capítulo 3 vimos que os repositórios devem ser usados para armazenar e recuperar objetos de entidade, criando assim a ilusão de que esses objetos são todos na memória, quando na realidade eles estão sendo recuperada a partir de alguns de armazenamento externo, como um banco de dados relacional. Dada a sua longa vida-span, objeto de uma entidade sempre tem uma identidade e em um banco de dados relacional, esta identidade geralmente se traduz em uma chave primária. Podemos de ne uma interface para objetos de entidade como mostrado abaixo.
IEntity.cs
1 namespace Safewhere.Core.Domain
2 {
3 interface pública IEntity <TPrimaryKey>
4 {
5 TPrimaryKey OID { GET; }
6 }
7 }
a interface IEntity mostrado acima é uma interface genérica com um tipo pa- rameter, TPrimaryKey, que especi es o tipo da chave primária. A
interface especi es que cada objeto que implementa a interface deve ter
uma propriedade readonly chamado OID (acrônimo de object id).
Às vezes precisamos manipular vários objetos de entidade entravarão um di di repositórios entravarão um na transação. A palavra transação é bem conhecida do mundo de bases de dados relacionais. Uma transação é um pt- capsulation de uma série de operações que são co-dependente, o que significa que se uma das operações falhar, o resultado de qualquer uma das operações não devem ser armazenados. Na comunidade de design orientado por domínio e em [McCarthy 2008] e [Harding 2008] em particular, esta transação conceito é referido como uma unidade de trabalho . Presumo que esse termo foi escolhido em vez de trans- acção porque o facto de a palavra transação é tão fortemente acoplado a uma tecnologia de armazenamento especí c nomeadamente bancos de dados relacionais. Claro está que não é da responsabilidade de um repositório para saber quando ele é usado dentro de uma unidade
103




104
do trabalho. Mas um repositório deve ter a capacidade de ser matriculados em uma unidade de trabalho. A interface para uma unidade de resumo do trabalho poderia ser de ned como segue:
IUnitOfWork.cs
1 usando o sistema;
2 3 namespace Safewhere.Core.Domain
4 {
5 interface pública IUnitOfWork : implementa IDisposable
6 {
7 T Criar <T>() onde T : IUnitOfWorkElement, novo();
8 9 void completa();
10 }
11 }
a interface IUnitOfWork de nes duas funções, criar e completas.
A interface também herda o implementa IDisposable interface, uma interface que pode
ser implementada para liberar recursos não gerenciados durante a coleta de lixo quando trabalhar em .Net. LINQ para SQL recursos não gerenciados não são , mas queremos usar algum outro armazenamento de dados no futuro, incluindo a
implementa IDisposable interface é uma escolha segura. O método completo é usado para
completar a unidade de trabalho, um equivalente para cometer quando trabalhar com
bancos de dados relacionais. A função de criar é uma função genérica que irá
criar uma instância de qualquer classe que implementa a
interface IUnitOfWorkElement e tem um construtor padrão (ex. um construtor que não tem
argumentos. Isso é indicado pelo novo() restrição sobre o tipo genérico T).
A interface IUnitOfWorkElement tem a seguinte de nição:
IUnitOfWorkElement.cs
1 namespace Safewhere.Core.Domain
2 {
3 interface pública IUnitOfWorkElement
4 {
5 IUnitOfWork UnitOfWork { definir; }
6 }
7 }
a interface IUnitOfWorkElement de nes uma propriedade de somente gravação chamado
UnitOfWork de typeIUnitOfWork. Qualquer implementor de
interface theIUnitOfWorkElement irá expor uma forma de definir o associado IUnitOfWork em
posição, e- será usada pelo método da IUnitOfWork criar, como veremos
no seguinte aplicação concreta de uma unidade de trabalho:
LinqToSqlUnitOfWork.cs
1 usando o sistema;
2 usando o System.Data.Linq;
3 usando o System.transacções;
4




105
5 namespace Safewhere.Core.Domain
6 {
7 public class LinqToSqlUnitOfWork : IUnitOfWork, IRepositoryImplementationHelper
8 {
9 DataContext _dataContext;
10 TransactionScope _txScope;
11 12 LinqToSqlUnitOfWork pública(DataContext dataContext) : Este(dataContext null){}
13 14 LinqToSqlUnitOfWork pública(DataContext dataContext, Transacção transactionToUse)
15 {
16 se (dataContext == null)
17 deite nova ArgumentNullException("dataContext");
18 _dataContext = dataContext;
19 _txScope = transactionToUse == null ? Novo TransactionScope() : Novo TransactionScope(transactionToUse);
20 }
21 22 public T Criar <T>() onde T : IUnitOfWorkElement, novo()
23 {
24 retorna o novo T {UnitOfWork = este};
25 }
26 27 public void completa()
28 {
29 _dataContext.SubmitChanges();
30 _txScope.Complete();
31 }
32 33 public void dispose()
34 {
35 _dataContext = null;
36 _txScope.dispose();
37 }
38 39 40 #região IRepositoryImplementationHelper membros
41 42 IEntityContainer <T>IRepositoryImplementationHelper.GetEntityContainer <T>()
43 {
44 retorna o novo LinqToSqlEntityContainer <T>(_dataContext);
45 }
46 47 #endregion
48 }
49 }
A classe LinqToSqlUnitOfWork tem dois construtores. A rst one leva um DataContext LINQ como discutido no capítulo anterior e solicita a
outro construtor com um valor nulo para o parâmetro transactionToUse.
O segundo construtor salva o DataContext em uma variável privada e define
a casa _txScope variável com base na carneiro castrado ou não thetransactionToUse
parâmetro é nulo. Um TransactionScope é utilizado para se alistar implicitamente um bloco de




106
código em um transacções em .Net, como descrito no [Microsoft 2007].
O método de criação de 10 é implementado por chamando o construtor padrão do tipot e definição da unidade de trabalho para a instância currentLinqToSqlUnitOfWork
instância.
Osparafusos do método é implementado por callingSubmitChanges no pri- ativar_objeto dataContext e depois na
instância theTransactionScope callingComplete. Método aDataContext TheSubmitChanges fará theDataContext
persistirem as alterações feitas na memória para o banco de dados.
Por último, a classe implementa o IRepositoryImplementationHelper em-
terface através da aplicação de método theGetEntityContainer. TheIRepositoryImplementationHelper
interface é de nida como segue:
IRepositoryImplementationHelper.cs
1 namespace Safewhere.Core.Domain
2 {
3 interface pública IRepositoryImplementationHelper
4 {
5 IEntityContainer <T>GetEntityContainer <T>() onde T : classe;
6 }
7 }
a interface IRepositoryImplementationHelper vai ser utilizado pelo
nosso repositório implementação e de nes um único método
que retorna anIEntityContainer calledGetEntityContainer, de um dado classT. O Verbo|IEntityContainer|
tem a seguinte de nição:
IEntityContainer.cs
1 usando o System.Linq;
2 3 namespace Safewhere.Core.Domain
4 {
5 interface pública IEntityContainer <T>: IQueryable <T>
6 {
7 void adiciona o elemento(T);
8 void remove o elemento(T);
9 }
10 }
IEntityContainer a interface é uma interface genérica que herda dos
genéricos na interface IQueryable incorporado. Ela de nes os dois métodos adicionar
e remover, que deve ser usado para adicionar uma entidade remover objetos de uma
10 Nota o uso do objeto o inicializador de sintaxe que é novo no .NET 3.5 e permite que você
atribua valores para propriedades públicas durante a chamada para o construtor. Ver [Microsoft 2009]
para obter uma explicação mais aprofundada.




107
recipiente. A classe a seguir é uma implementação da
interface theIEntityContainer.
LinqToSqlEntityContainer.cs
1 usando o sistema;
2 usando o System.Coleções.genéricos;
3 usando o System.Linq;
4 usando o System.Data.Linq;
5 6 namespace Safewhere.Core.Domain
7 {
8 classe LinqToSqlEntityContainer interno <T>: IEntityContainer <T>Onde T : Classe
9 {
10 Tabela <T>_mesa;
11 12 LinqToSqlEntityContainer interno(DataContext dataContext)
13 {
14 _tabela = dataContext.GetTable <T>();
15 }
16 17 #região IEntityContainer <T>Membros
18 19 public void adiciona o elemento(T)
20 {
21 _table.InsertOnSubmit(element);
22 }
23 24 public void remove o elemento(T)
25 {
26 _table.DeleteOnSubmit(element);
27 }
28 29 #endregion
30 31 #região IEnumerable <T>Membros
32 33 IEnumerator público <T>GetEnumerator()
34 {
35 retorno _table.GetEnumerator();
36 }
37 38 #endregion
39 40 #região IEnumerable membros
41 42 Sistema.Coleções.Sistema IEnumerator.Coleções.IEnumerable.GetEnumerator()
43 {
44 retorno _table.GetEnumerator();
45 }
46 47 #endregion
48 49 #região IQueryable membros
50 51 tipo de público ElementType
52 {
53 obter




108
54 {
55 var q = _tabela como IQueryable <T>;
56 Retornar q.ElementType;
57 }
58 }
59 60 Sistema público.Linq.Expressões.Expressão Expressão
61 {
62 obtenha
63 {
64 var q = _tabela como IQueryable <T>;
65 Retornar q.Expressão;
66 }
67 }
68 69 públicas provedor IQueryProvider
70 {
71 obtenha
72 {
73 var q = _tabela como IQueryable <T>;
74 Retornar q.prestador;
75 }
76 }
77 78 #endregion
79 }
80 } LinqToSqlEntityContainer.cs
a rst coisa de aviso sobre o LinqToSqlEntityContainer é que ele
está marcado como interno. Isto significa que ele pode ser usado somente a partir de dentro o
conjunto onde ele reside. A razão que esta classe é madeinternal é que
não é suposto ser utilizado directamente por qualquer cliente, mas apenas como um datastorage interno-especi c recipiente para entidades. Uma vez que esta entidade recipiente usa o
LINQ para SQL, sua aplicação interna é baseada em uma instância do AQUADRO BB,
conforme descrito anteriormente para o tipo genérico T. O construtor usa um LINQ
DataContext que utiliza para recuperar a tabela correta para o
tipo genérico T. implementa todos os métodos da interface de IEntityContainer chamando
a métodos adequados sobre a tabela exemplo _tabela.
Temos visto agora o de nição de a maior parte das aulas necessários para a nossa implementação de repositório genérico e podemos agora de ne a interface para
o repositório do seguinte modo:
IRepository.cs
1 usando o sistema;
2 usando o System.Linq;
3 usando o System.Linq.Expressões;
4 5 namespace Safewhere.Core.Domain
6
interface pública IRepository { 7 <TEntity, TPrimaryKey>




109
8 : IQueryable <TEntity>,
onde TEntity IUnitOfWorkElement 9 : IEntity <TPrimaryKey>
10 {
11 void add(TEntity elemento);
12 void remove(TEntity elemento);
13 14 TEntity este[TPrimaryKey primaryKey]; } { GET
15 16 IQueryable <TEntity>Encontrar(Expressão&lt;Func <TEntity, bool>&gt; expr);
17 IQueryable <TEntity>Encontrar(IBooleanExpressionHolder <TEntity>Spec);
18 19 TEntity FindFirst(Expressão&lt;Func <TEntity, bool>&gt; expr);
20 TEntity FindFirst(IBooleanExpressionHolder <TEntity>Spec);
21 22 IQueryable <TEntity>FindAll();
23 24 bool Existe(Expressão&lt;Func <TEntity, bool>&gt; expr);
25 bool Existe(IBooleanExpressionHolder <TEntity>Spec);
26 27 }
28 }
a interface IRepository é uma interface genérica do tipo TEntity e
TPrimaryKey, onde TEntity é o tipo da entidade objeto repos-
itory serve e TPrimaryKey é o tipo da chave primária de que
tipo de entidade. Além disso, a interface impõe a restrição de que o
tipo de theIEntity TEntity deve implementar a interface com o uso do mesmo tipo,TPrimaryKey,
como uma chave primária. O repositório também deve implementar theIQueryable em-
terface para tipo TEntity, e o interface IUnitOfWork.
A interface IRepository de nes adicionar e remover funções para adição
e remoção de objetos de entidade. Ele também de uma função de indexador nes (em linha 14) que permite que altera uma única instância de uma entidade objeto baseado no seu único
identifi er. Linhas 16-22 de ne di entravarão um nder funções. Os dois encontram a funçäoes
retornar uma coleção de objetos de entidade com base em algum critério de pesquisa. A
função toma um parâmetro rst do tipo expressão&lt;Func <TEntity, bool>&gt;
Que é o lambda expressão que foi descrita anteriormente neste
capítulo. A segunda função de encontrar leva uma IBooleanExpressionHolder, um em-
terface que iremos utilizar para encapsular os nossos especi cátions, como veremos
mais para baixo. As duas funções FindFirst tomar os mesmos parâmetros como
a encontrar as funções, mas só voltará a rst resultado em vez de retornar
uma coleção. A função FindAll retorna todos os objetos da entidade no
repositório. Por último, a interface de nes twoExists funções que deter-
minas se um ou mais objetos de entidade existe para um dado expressão lambda ou
IBooleanExpressionHolder. O IBooleanExpressionHolder interface é de-
ned como segue:




110
IBooleanExpressionHolder.cs
1 usando o sistema;
2 usando o System.Linq.Expressões;
3 4 namespace Safewhere.Core.Domain
5 {
6 interface pública IBooleanExpressionHolder <T>
7 {
8 expressão&lt;Func <T, bool>&gt; expressão { GET; }
9 }
10 }
A IBooleanExpressionHolder é uma interface genérica para um tipo genérico
T e contém um único tipo de propriedade da expressão&lt;Func <T, bool>&gt;. A
finalidade desta interface é manter uma expressão que irá avaliar a um
valor Booleano para uma instância de um dado genérico tipot. Quando usado em con-
junção com um repositório, uma implementação ofIBooleanExpressionHolder
pode ser utilizado para exprimir um critério de pesquisa para utilização com o encontrar, FindFirst ou
existe funções. O mais importante na classe do componente que execu- tares IBooleanExpressionHolder LambdaSpecification interface é a
classe, que é de nida como segue:
ISpecification.cs
1 usando o sistema;
2 usando o System.Linq.Expressões;
3 4 namespace Safewhere.Core.Domain
5 {
6 classe abstrata LambdaSpecification público <T>: ISpecification <T>, IBooleanExpressionHolder <T>
7 {
8 expressão&lt;Func <T, bool>&gt; _expr;
9 Func <T, bool>_compiledExpr;
10 11 LambdaSpecification protegido(Expressão&lt;Func <T, bool>&gt; specExpression)
12 {
13 _expr = specExpression;
14 }
15 16 expressão pública&lt;Func <T, bool>&gt; Expressão
17 {
18 obter { retorno _expr; }
19 }
20 21 público Func <T, bool>CompiledExpression
22 {
23 obter
24 {
25 se (_compiledExpr == null)
26 {
27 _compiledExpr = _expr.Compile();
28 }
29 retorno _compiledExpr;




111
30 }
31 }
32 33 público bool IsSatiesfiedBy elemento(T)
34 {
35 CompiledExpression retorno.invoke(element);
36 }
37 }
38 }
LambdaSpecification ISpecification.cs a classe é uma classe abstrata que implementa genérico bothISpecification (descrito mais baixo) e theIBooleanExpressionHolder
interface. A classe é abstrata desde, embora pudesse ser possível, nós não queremos que qualquer pessoa possa usar as instâncias da classe diretamente. Isto é porque em design orientado por domínio de uma especi cação deve ser explicitamente nomeadas e ser um
conceito de sua própria. No entanto TheLambdaSpecification classe implementar a
maioria da lógica para criar os explicitamente chamado especi cações. A classe
contém duas propriedades,Expressão e CompiledExpression. O valor da
expressão propriedade é o mesmo que a classe recebe no construtor.
O CompiledExpression é essa mesma expressão, apenas compilado internamente
para um melhor desempenho. Por último, a implementação do
interface ISpecification é implementado pela função theIsSatisfiedBy. O método tem
um argumento de uma instância da classe" tipo genérico e invoca o com-
empilhados sobre esta expressão instância. O ISpecification interface é de nida
como segue:
ISpecification.cs
1 namespace Safewhere.Core.Domain
2 {
3 interface pública ISpecification <T>
4 {
5 bool IsSatiesfiedBy elemento(T);
6 }
7 }
TheISpecification interface é uma interface genérica que tem uma única função,
IsSatisfiedBy, tal como o exemplo apresentado anteriormente. Podemos agora de ne
um repositório da seguinte forma:
Repositório.cs
1 usando o sistema;
2 usando o System.Coleções.genéricos;
3 usando o System.Linq;
4 usando o System.Linq.Expressões;
5 6 namespace Safewhere.Core.Domain
7 {
8 public class Repositório <TEntity, TPrimaryKey>
9 : IRepository <TEntity, TPrimaryKey>




112
10 onde TEntity : classe, IEntity <TPrimaryKey>
11 {
IUnitOfWork unitOfWork 12 protegido _;
13 IEntityContainer protegido <TEntity>_entityContainer;
14 15 IEntityContainer protegido <T>CreateEntityContainer <T>() onde T: classe
16 {
; 17 var repHelper = (IRepositoryImplementationHelper) UnitOfWork
18 repHelper.GetEntityContainer de retorno <T>();
19 }
20 21 #região IRepository <TEntity, TPrimaryKey>Membros
22 23 public void add(TEntity elemento)
24 {
25 _entityContainer.add(element);
26 }
27 28 public void remove(TEntity elemento)
29 {
30 _entityContainer.Extrair(elemento);
31 }
32 33 TEntity público este[TPrimaryKey primaryKey]
34 {
35 obtenha
retorno _entityContainer { 36.SingleOrDefault(entidade =&gt; primaryKey.equivale a(entidade.

OID));
37 }
38 }
39 40 IQueryable público <TEntity>Encontrar(Expressão&lt;Func <TEntity, bool>&gt; expr)
41 {
42 retorno _entityContainer.Onde(expr);
43 }
44 45 IQueryable público <TEntity>Encontrar(IBooleanExpressionHolder <TEntity>Spec)
46 {
47 retorno _entityContainer.Onde(spec.Expressão);
48 }
49 50 TEntity público FindFirst(Expressão&lt;Func <TEntity, bool>&gt; expr)
51 {
52 retorno _entityContainer.FirstOrDefault(expr);
53 }
54 55 TEntity FindFirst(IBooleanExpressionHolder público <TEntity>Spec)
56 {
57 retorno _entityContainer.FirstOrDefault(spec.Expressão);
58 }
59 60 públicos existe bool(Expressão&lt;Func <TEntity, bool>&gt; expr)
61 {
;0 62 retorno _entityContainer.Count(expr) &gt;
63 }
64




113
65 Existe bool(IBooleanExpressionHolder público <TEntity>Spec)
66 {
;0 67 retorno _entityContainer.Count(spec.Expressão) &gt;
68 }
69 70 IQueryable público <TEntity>FindAll()
71 {
72 retorno _entityContainer.AsQueryable();
73 }
74 75 #endregion
76 77 #região IEnumerable <TEntity>Membros
78 79 IEnumerator público <TEntity>GetEnumerator()
80 {
81 retorno _entityContainer.GetEnumerator();
82 }
83 84 #endregion
85 86 #região IEnumerable membros
87 88 Sistema.Coleções.Sistema IEnumerator.Coleções.IEnumerable.GetEnumerator()
89 {
90 retorno _entityContainer.GetEnumerator();
91 }
92 93 #endregion
94 95 #região IQueryable membros
96 97 tipo de público ElementType
98 {
99 obter { retorno _entityContainer.ElementType; }
100 }
101 102 expressão pública expressão
103 {
104 obtenha { retorno _entityContainer.Expressão; }
105 }
106 107 Provedor IQueryProvider público
108 {
109 obtenha { retorno _entityContainer.prestador; }
110 }
111 112 #endregion
113 114 #região IUnitOfWorkElement membros
115 116 IUnitOfWork UnitOfWork público
117 {
118 definir
119 {
120 _unitOfWork = valor;




114
121 _entityContainer = CreateEntityContainer <TEntity>();
122 }
123 124 obtenha
125 {
126 retorno _unitOfWork;
127 }
128 }
129 130 #endregion
131 }
132 } Repositório.cs
a classe de repositório, naturalmente, implementa a interface IRepository pré-
tantes anteriormente. A coisa mais importante de aviso está na implementação
da interface IUnitOfWorkElement. Quando a instância UnitOfWork é definida
na classe, o private_entityContainer variável é instanciado chamando
a função CreateEntityContainer. A função
volta CreateEntityContainer lança o UnitOfWork para um IRepositoryImplementationHelper que
contém a função GetEntityContainer. O resto das funções nesta classe use este EntityContainer internamente para executar o trabalho.
6.1. Preparação para o teste
conforme mencionado no capítulo 3, uma razão importante para a utilização de repositórios é que um repositório de implementação concreta, por exemplo uma que usa um SQL Server backend, podem ser intercambiados com o outro. Isto é muito útil para os testes de unidade cujo objectivo não é para testar o sistema de armazenamento de dados, mas apenas para testar a funcionalidade do domínio. Adicionando algumas classes extra para o domínio neutro componente, podemos implementar um
armazenamento de dados na memória. Para isso precisamos, entre outras coisas, anInMemoryUnitOfWork e
um InMemoryEntityContainer.
InMemoryUnitOfWork.cs
1 usando o sistema;
2 3 namespace Safewhere.Core.Domain
4 {
5 public class InMemoryUnitOfWork : IUnitOfWork, IRepositoryImplementationHelper
6 {
7 IInMemoryDataContainer readonly _contentor;
8 9 InMemoryUnitOfWork pública(IInMemoryDataContainer recipiente)
10 {
11 se (recipiente == null)
12 deite nova ArgumentNullException("contentor");




115
13 _contentor = recipiente;
14 }
15 16 #região IUnitOfWork membros
17 18 public T Criar <T>() onde T : IUnitOfWorkElement, novo()
19 {
;} 20 retorna o novo T { UnitOfWork =
21 }
22 23 public void completa()
24 {
25 //este método não faz nada
26 }
27 28 #endregion
29 30 #região implementa IDisposable membros
31 32 public void dispose()
33 {
34 //este método não faz nada
35 }
36 37 #endregion
38 39 #região IRepositoryImplementationHelper membros
40 41 IEntityContainer público <T>GetEntityContainer <T>() onde T : classe
42 {
43 retorna o novo InMemoryEntityContainer <T>(_Recipiente);
44 }
45 46 #endregion
47 }
48 } InMemoryUnitOfWork.cs
a classe InMemoryUnitOfWork é bem parecido com o seu homólogo LINQ. A mais
importante di erência é o argumento para seu construtor, uma instância de um
IInMemoryDataContainer, em vez de a instância do DataContext que é usado
pelo LINQ versão. Além disso, esta classe não utilizar a
classe TransactionScope. Este é exclusivamente pela decisão, uma vez que facilmente poderia, mas
porque o seu objectivo é facilitar a realização de testes sem um banco de dados subjacente,
a classe pode ser simples. A função GetEntityContainer usa uma
versão na memória de uma entidade recipiente.
InMemoryEntityContainer.cs
1 usando o sistema;
2 usando o System.Coleções.genéricos;
3 usando o System.Linq;
4 5 namespace Safewhere.Core.Domain
6 {




116
7 classe InMemoryEntityContainer interno <T>: IEntityContainer <T>Onde T : Classe
8 {
9 Lista readonly <T>_dados;
10 11 InMemoryEntityContainer interno(IInMemoryDataContainer recipiente)
12 {
13 _dados = contentor.Execute GetData <T>();
14 }
15 16 #região IEntityContainer <T>Membros
17 18 public void adiciona o elemento(T)
19 {
20 _dados.add(elemento);
21 }
22 23 public void remove o elemento(T)
24 {
25 _dados.Extrair(elemento);
26 }
27 28 #endregion
29 30 #região IEnumerable <T>Membros
31 32 públicas IEnumerator <T>GetEnumerator()
33 {
34 retorno _dados.GetEnumerator();
35 }
36 37 #endregion
38 39 #região IEnumerable membros
40 41 Sistema.Coleções.Sistema IEnumerator.Coleções.IEnumerable.GetEnumerator()
42 {
43 voltar _dados.GetEnumerator();
44 }
45 46 #endregion
47 48 #região IQueryable membros
49 50 tipo de público ElementType
51 {
52 obtenha
53 {
IQueryable 54 <T>Q = _dados.AsQueryable();
55 Retornar q.ElementType;
56 }
57 }
58 59 Sistema público.Linq.Expressões.Expressão a expressão
60 {
61 obtenha
62 {




117
63 IQueryable <T>Q = _dados.AsQueryable();
64 Retornar q.Expressão;
65 }
66 }
67 68 Provedor IQueryProvider público
69 {
70 obtenha
71 {
IQueryable 72 <T>Q = _dados.AsQueryable();
73 Retornar q.prestador;
74 }
75 }
76 77 #endregion
78 }
79 } InMemoryEntityContainer.cs
a implementação da classe InMemoryEntityContainer também se assemelha a
sua contrapartida LINQ, di comousemadiçãodeaçúcarou apenas na medida em que seus dados internos de suporte é uma
lista genérica (A _variável de dados). Usando o LINQ para extensões de objetos de nida no System.Linq a classe pode executar sua lógica em que lista apenas
da mesma forma que o fazem com a sua contrapartida LINQ tabela exemplo. O
IInMemoryDataContainer fornece os dados e é de nida como segue:
IInMemoryDataContainer.cs
1 usando o System.Coleções.genéricos;
2 3 namespace Safewhere.Core.Domain
4 {
5 interface pública IInMemoryDataContainer
6 {
7 Lista <T>Execute GetData <T>();
8 }
9 }
O IInMemoryDataContainer de nes uma única função genérica que fornece
dados do tipo correto.




Capítulo
7
Execução
no capítulo anterior vimos como poderíamos usar LinqToSql para criar um quadro de domínio neutro para nos ajudar com a implementação de reposicionarem- tórios, entidade objetos e especi cações. Neste capítulo I irá apresentar a implementação de algumas das classes descritas no Capítulo 4. Uma vez que toda a implementação é demasiado grande para ser aqui apresentado, I incidirá sobre as peças que eu nd mais interessante, naturalmente incluindo algumas im- plementations repositório usando o quadro descrito no capítulo anterior. Se eu tiver deixado de fora alguma parte que é do seu interesse particular, por favor sinta livre para olhar para a aplicação da parte sobre a mídia de disco fechados. A mídia de disco fechado contém uma solução Visual Studio 2008 le e todos os
respectivos les. A Figura 54 mostra uma análise da solução le.
Figura 54. Linhas de código fonte.
Como você pode ver a solução contém 155 les, 10 dos quais não contêm código fonte. Como você deve ter observado o percentual de linhas de observações é bastante baixa, mas isso é natural uma vez que o sistema não está totalmente implementado,
e portanto não está totalmente documentado.
A Figura 55 mostra a estrutura da solução. Como você pode ver a solução
118




119
estrutura e le nomes aderir estritamente à linguagem onipresente.




120
Figura 55. Solução le estrutura.




121
7.0.1 Runtime System
o runtime system é particularmente interessante, pois mostra como o IdP delegados o trabalho real para o di entravarão um plug-ins. A classe que processa
cada pedido e determina o que fazer é a
classe IdPEndpointHandlerFactory, mostrado abaixo.
IdPEndpointFactory.cs
1 usando o System.Web;
2 usando o System.Web.SessionState;
3 usando Safewhere.IdP.application.Endpoints;
4 usando Safewhere.IdP.application.Páginas;
5 usando Safewhere.IdP.domain.Registro;
6 usando Safewhere.IdP.Propriedades;
7 8 namespace Safewhere.IdP.application.HttpHandlers
9 {
10 classe pública IdPEndpointFactory : IHttpHandlerFactory, IRequiresSessionState
11 {
12 IHttpHandler público GetHandler(HttpContext contexto, Solicitação, string virtualPath String, String caminho)
13 {
14 var loginSpec = novo IsGlobalLoginUriSpecification();
15 16 se(loginSpec.IsSatiesfiedBy(contexto.Request.Url))
17 retorna o novo IdPLoginPage();
18 19 endpoint IEndpoint = EndpointService.GetEndpointForPath(virtualPath);
20 21 se o endpoint (!= null)
22 {
23 endpoint de retorno.Handler;
24 }
25 26 string errorMessage = string.Format(IdPErrorMessages.EndpointNotFound, virtualPath);
27 28 IdPContext.Current.Trace(TraceLevel.Aviso, errorMessage);
29 30 regresso novo ErrorHandler(errorMessage);
31 32 }
33 34 public void ReleaseHandler(IHttpHandler manipulador)
35 {
36 retorno;
37 }
38 }
39 }
TheIdPEndpointHandlerFactory classe implementa theIHttpHandlerFactory
framework interface E é viciado em servidor web con figuração le.
A seguir, para cada solicitação de que o servidor da Web recebe, ele irá chamar o





método dos nossos GetHandler 122 classe para obter um manipulador adequado. No
método GetHandler, é efectuada uma verificação para ver se o pedido é para a
página de login globais e se este é o caso, uma instância do 11 IdPLoginPage
é devolvido. Caso contrário, o EndpointService GetEndpointForPath do método
é chamado, de nd o endpoint que serve o caminho fornecido. Se um ponto de terminação é encontrado, seu manipulador é devolvido. Caso contrário uma mensagem de erro é rastreada e uma
página de erro genérica é devolvido.
EndpointService.cs
1 usando Safewhere.Core.Domain;
2 usando Safewhere.IdP.Domain;
3 usando Safewhere.IdP.domain.Credenciais;
4 usando Safewhere.IdP.domain.Protocolo;
5 usando Safewhere.IdP.Infra-estrutura.Util;
6 usando o System.Linq;
7 8 namespace Safewhere.IdP.application.Endpoints
9 {
10 classe pública EndpointService
11 {
12 /// <summary>
13 /// recebe uma implementação de IEndpoint que pode lidar com um determinado caminho.
14 /// procura quer o protocolo e terminação de credencial. Pontos de extremidade de protocolo
15 /// ter precedência sobre pontos de terminação de credenciais se dois deve existir
16 /// com o mesmo caminho (sinalizamos este é considerado um erro).
17 /// </summary>
18 /// <param name="path">O caminho. </param>
19 /// <returns>Uma instância de uma classe que implementa IEndpoint,
20 /// ou null se não houver uma adequada implementação é encontrado. </returns>
21 estáticos públicos IEndpoint GetEndpointForPath(string caminho)
22 {
23 var ep = GetProtocolEndpointForPath(caminho);
24 se (ep != null)
25 voltar pe;
26 27 ep = GetCredentialEndpointForPath(caminho);
28 29 Retornar ep;
30 }
31 32 IEndpoint estática privada GetProtocolEndpointForPath(string caminho)
33 {
34 usando (var uoo = novo LinqToSqlUnitOfWork(novo IdPDataClassesDataContext()))
35 {
;} 36 var cpr = novo ConfiguredProtocolRepository { UnitOfWork = uoo
37 var todos = cpr.FindAll();
38 foreach (var cp em todas)
39 {
40 var plugin =
;) 41 ActivatorUtil.GetInstance <IPlugIn>(CP.
11 TheIdPLoginPage ProtocolDefinition.ProtocolType é a página que mostra ao usuário o di entravarão um con configurados
fornecedores de credenciais e lhe permite escolher qual a usar para a autenticação.




123
42 43 se (plug-in == null) continuar;
44 45 plugin.WHERE PluginId = cp.OID;
46 47 var espec = novo EndpointHandlesPathSpecification(caminho);
48 49 endpoint var = plugin.GetEndpoints().FirstOrDefault(spec.IsSatiesfiedBy);
50 51 se (endpoint != null)
52 endpoint de retorno;
53 }
54 }
55 56 retornar null;
57 }
58 59 IEndpoint estática privada GetCredentialEndpointForPath(string caminho)
60 {
61 usando (var uoo = novo LinqToSqlUnitOfWork(novo IdPDataClassesDataContext()))
62 {
;} 63 var ccpr = novo ConfiguredCredentialProviderRepository { UnitOfWork = uoo
64 var todos = ccpr.FindAll();
65 foreach (var ccp em todas)
66 {
67 var plugin =
68 ActivatorUtil.GetInstance <IPlugIn>(ccp.CredentialProviderDefinition.

CredentialProviderType);
69 70 se (plug-in == null) continuar;
71 72 plugin.WHERE PluginId = ccp.OID;
73 74 var espec = novo EndpointHandlesPathSpecification(caminho);
75 76 endpoint var = plugin.GetEndpoints().FirstOrDefault(spec.IsSatiesfiedBy);
77 78 se (endpoint != null)
79 endpoint de retorno;
80 }
81 }
82 83 retornar null;
84 }
85 }
86 }
A EndpointService olha para pontos de extremidade de protocolo e provedor de credenciais de
endpoints e tenta nd um que corresponda ao caminho fornecido como um argu-
mento. Primeiro a que chama o método GetProtocolEndpointForPath, que usa
o ConfiguredProtocolRepository para nd con protocolos configurados. Ele usa re-
eção de instanciar cada con a implementação do protocolo totalmente configurados e então repete sobre a terminação fornecidos pela aplicação para ver se qualquer





endpoint 124 corresponde ao caminho solicitado. Algo muito semelhante é feito no
método GetCredentialEndpointForPath.
ConfiguredProtocolRepository.cs
1 usando Safewhere.Core.Domain;
2 3 namespace Safewhere.IdP.domain.Protocolo
4 {
5 public class ConfiguredProtocolRepository : Repositório <ConfiguredProtocol, int>
6 {
7 8 }
9 }
O ConfiguredProtocolRepository é muito simples, porque o
método FindAll é implementado por nossa classe de repositório genérico.
7.0.2 O Fornecedor de credenciais de usuário/senha
vamos ver como o fornecedor de credenciais de usuário/senha plug-in é execu-
tado.
UsernamePasswordPlugin.cs
1 usando o System.Coleções.genéricos;
2 usando Safewhere.IdP.application.Endpoints;
3 usando Safewhere.IdP.CredentialProviders.UserNamePassword.application.Endpoints;
4 5 namespace Safewhere.IdP.CredentialProviders.UserNamePassword.Aplicação
6 {
7 public class UsernamePasswordPlugin : IPlugIn
8 {
9 seqüência pública Descrição
10 {
11 obter { return "fornece através de login de usuário/senha"; }
12 }
13 14 Lista Pública <IEndpoint>GetEndpoints()
15 {
16 voltar nova lista <IEndpoint>{novo UsernamePasswordEndpoint(WHERE PluginId)};
17 }
18 19 público int where PluginId { GET; definir; }
20 }
21 }
A UsernamePasswordPlugin IPlugin classe implementa a interface, que
é bastante simples. A coisa mais importante de aviso é
método theGetEndpoints, que neste caso retorna uma lista com apenas um elemento de uma instância
da classe UsernamePasswordEndpoint.




125
UsernamePasswordEndpoint.cs
1 usando o System.Web;
2 usando Safewhere.IdP.application.Endpoints;
3 usando Safewhere.IdP.CredentialProviders.UserNamePassword.application.Páginas;
4 5 namespace Safewhere.IdP.CredentialProviders.UserNamePassword.application.Endpoints
6 {
7 public class UsernamePasswordEndpoint : IEndpoint
8 {
9 int privado _WHERE pluginId;
10 11 UsernamePasswordEndpoint pública(int where pluginId)
12 {
13 _WHERE pluginId = WHERE pluginId;
14 }
15 16 seqüência pública caminho
17 {
18 obter { return "unpwdlogin.idp"; }
19 }
20 21 seqüência pública Descrição
22 {
23 obter { return "Endpoint para nome de usuário/senha login."; }
24 }
25 26 manipulador IHttpHandler público
27 {
28 obter { retorna o novo UsernamePasswordPage(_WHERE pluginId); }
29 }
30 31 seqüência pública Nome
32 {
33 obter { return "UsernamePasswordEndpoint"; }
34 }
35 }
36 }
A classe implementa a interface theIEndpoint UsernamePasswordEndpoint,
e mais importante, Retorna uma instância da
classe no seu manipulador UsernamePasswordPage propriedade.
1 ï ̇z £ usando o System.Coleções.genéricos;
2 usando o System.Web.SessionState;
3 usando o System.Web.UI;
4 usando o System.Web.ui.WebControls;
5 usando Safewhere.Core.Domain;
6 usando Safewhere.IdP.Aplicação;
7 usando Safewhere.IdP.application.Páginas;
8 usando Safewhere.IdP.CredentialProviders.UserNamePassword.Propriedades;
9 usando Safewhere.IdP.Domain;
10 usando Safewhere.IdP.domain.Créditos;
11 usando Safewhere.IdP.domain.Credenciais;
12 usando o System.Linq;




126
13 usando Safewhere.IdP.domain.Registro;
14 15 Safewhere namespace.IdP.CredentialProviders.UserNamePassword.application.Páginas
16 {
17 /// <summary>
18 /// uma página que coleta informações de nome de usuário e senha através de um formulário.
19 /// </summary>
20 classe pública UsernamePasswordPage : CredentialProviderBasePage, IRequiresSessionState
21 {
22 rótulo privado _usernameLabel;
23 rótulo privado _passwordLabel;
24 privado de texto _username;
25 privado de texto _senha;
26 Botão privado _apresentar;
27 Painel privado _buttonPanel;
28 RequiredFieldValidator _usernameValidator privado;
29 RequiredFieldValidator _passwordValidator privado;
30 Painel privado _messagePanel;
31 32 públicas credentialProviderDefinitionId UsernamePasswordPage(int) : credentialProviderDefinitionId base()
33 {
34 35 }
36 37 protegidos override void OnLoad(e) System.EventArgs
38 {
39 retorno;
40 }
41 42 protegidos override void CreateChildControls()
43 {
;} 44 _usernameLabel = novo rótulo { Texto = Recursos.UsernameLabelText
45 _usernameLabel.Largura = 100;
46 _content.AddControl(_usernameLabel);
47 48 _username = novo texto{largura = 150};
49 _username.ID = "usuário";
50 _content.AddControl(_username);
51 52 _usernameValidator = novo RequiredFieldValidator
53 {
54 ControlToValidate = _username.ID,
55 Monitor = ValidatorDisplay.Dinâmico,
56 ErrorMessage = Recursos.UsernameValidationText
;} 57
58 base._content.AddControl(_usernameValidator);
59 60 base._content.AddControl(novo LiteralControl(" <br/>"));
;} 61 62 _passwordLabel = novo rótulo { Texto = Recursos.PasswordLabelText
63 _passwordLabel.Largura = 100;
64 base._content.AddControl(_passwordLabel);
;} 65 66 _senha = Novo Texto { largura = 150, TextMode = TextBoxMode.Password
67 _senha.ID = "senha";




127
68 _content.AddControl(_password);
69 70 _passwordValidator = novo RequiredFieldValidator
71 {
72 ControlToValidate = _senha.ID,
73 Monitor = ValidatorDisplay.Dinâmico,
74 ErrorMessage = Recursos.PasswordValidationText
;} 75
76 base._content.AddControl(_passwordValidator);
77 78 base._content.AddControl(novo LiteralControl(" <br/>"));
;} 79 80 _buttonPanel = Novo Painel { largura = 255
81 _buttonPanel.Estilo.add("text-align", "direito");
; 82 _apresentar = Botão novo {Texto = Recursos.SubmitButtonText, CausesValidation = true}
83 _submit.Clique em += _submit_Clique;
84 _buttonPanel.Controles.add(_SUBMIT);
85 base._content.AddControl(_buttonPanel);
86 87 _messagePanel = Novo painel {Visível = Falso};
88 89 base._content.AddControl(_messagePanel);
90 }
91 92 void _submit_Clique(objeto remetente, System.EventArgs e)
93 {
94 se(IsValid)
95 {
96 var usuário = UserService.GetUser(_username.Text);
97 98 se (usuário == null || !user.VerifyPassword(_password.Text))
99 {
100 LoginError();
101 retorno;
102 }
103 104 RetrieveCredentialClaims(usuário);
105 106 }
107 }
108 109 RetrieveCredentialClaims privado void(utilizador utilizador)
110 {
111 var créditos = nova lista <CredentialClaim>();
112 usando (var uoo = novo LinqToSqlUnitOfWork(novo IdPDataClassesDataContext()))
113 {
114 var ccpr = novo ConfiguredCredentialProviderRepository {UnitOfWork = uoo};
115 var PCC = ccpr.FindByPrimaryKey(CredentialProviderDefintionId);
116 foreach(var ccd no ccp.CredentialClaimDefinitions)
117 {
118 se (CCD.IsIdentityBearer)
119 créditos.add(CredentialClaim.FromDefinition(user.Username, CCD));
120 }
121 }
122




128
123 Se(créditos.Count &gt; 0)
124 {
125 IdPContext.Current.AuthenticationDone(créditos.AsQueryable());
126 }o resto
127 {
128 IdPContext.Current.Trace(TraceLevel.Erro, "Nenhuma credencial pedidos encontrados para o usuário " + user.Username);
129 }
130 }
131 132 privados void LoginError()
133 {
134 _messagePanel.Visível = true;
135 _messagePanel.Controles.add(novo LiteralControl("errado a combinação de nome de usuário e senha"));
136 }
137 }
138 }
TheUsernamePasswordPage herda thePage classe do quadro (que
por sua vez implementa a interface theIHttpHandler). Esta página exibe
duas texto basicamente euratomdoconselho onde o utilizador pode introduzir o seu nome de utilizador e a sua palavra-passe. O
mais interessante é o método _submit_Clique em método. Esse método usa
a classe UserRepository para obter uma instância da classe de usuário correspondente
ao nome digitado pelo usuário. Ele então chama o método VerifyPassword
sobre o usuário de instância de classe, para ver se a senha digitada pelo usuário cor-
responde a um usuário armazenados na instância. Se não for este o caso, uma
mensagem de erro é exibida e o usuário pode tentar novamente. Caso contrário, a
credencial do usuário reclamações são extraídos e o método do
IdPContext AuthenticationDone classe é chamado, assim nalizing a autenticação.
UserRepository.cs
1 usando o System.Linq;
2 usando Safewhere.Core.Domain;
3 usando Safewhere.IdP.domain.Os utilizadores.Especificações;
4 5 namespace Safewhere.IdP.domain.Repositórios
6 {
7 public class UserRepository : Repositório <User, int>
8 {
9 IQueryable público <User>BeginsWith FindUsersBeginningWith(String)
10 {
11 var espec = novo UserNameBeginningWith(beginsWith);
12 Retornar Encontrar(SPEC);
13 }
14 15 /// <summary>
16 /// verifica se um usuário com o nome de utilizador fornecido já existe.
17 /// A verificação é executada caso insensibilidade foram
18 /// </summary>
19 /// <param name="userName">O nome de usuário. </param>
20 /// <returns>Verdadeiro se o usuário existe caso contrário, FALSE </returns>




129
21 Usuário público FindByName(string userName)
22 {
23 retornar FindFirst(novo ExactUserName(Usuário));
24 }
25 26 público bool ExistsByName(string userName)
27 {
28 Existe retorno(novo ExactUserName(Usuário));
29 }
30 }
31 }
A classe UserRepository tem também uma implementação simples, embora alguns
métodos extra foram adicionados. O FindUserByName método utilizado pela
_submit_clique em método acima descrito simplesmente usa uma instância da
classe de catiões ExactUserName especi a nd a instância do usuário correspondente.
7.0.3 Um detonador inerte protocolo
embora não prontas para a produção da implementação do protocolo foi desenvolvido como parte da tese, vou mostrar a seguinte aplicação de um detonador inerte protocolo. O detonador inerte protocolo responde em um único URI. O detonador inerte pro-
protocolo exibe todas as solicitações para o usuário que efetua o login.
TestProtocolPlugin.cs
1 usando o System.Coleções.genéricos;
2 usando Safewhere.IdP.application.Endpoints;
3 usando Safewhere.IdP.Protocolos.TestProtocol.application.Endpoints;
4 5 namespace Safewhere.IdP.Protocolos.TestProtocol.Aplicação
6 {
7 public class TestProtocolPlugin : IPlugIn
8 {
9 seqüência pública Descrição
10 {
11 obter { return "teste simples protocolo"; }
12 }
13 14 Lista Pública <IEndpoint>GetEndpoints()
15 {
16 voltar nova lista <IEndpoint>{novo TestEndpoint(WHERE PluginId)};
17 }
18 19 público int where PluginId{obtenha; definir;}
20 }
21 }
TheTestProtocolPlugin classe é muito semelhante ao theUsernamePasswordPlugin
apresentadas acima.




130
TestEndpoint.cs
1 usando o System.Web;
2 usando Safewhere.IdP.application.Endpoints;
3 usando Safewhere.IdP.Protocolos.TestProtocol.application.Handlers;
4 5 namespace Safewhere.IdP.Protocolos.TestProtocol.application.Endpoints
6 {
7 public class TestEndpoint : IEndpoint
8 {
9 10 particulares readonly int _protocolId;
11 12 protocolId TestEndpoint pública(int)
13 {
14 _protocolId = protocolId;
15 }
16 17 seqüência pública caminho
18 {
19 obter { return "test.idp"; }
20 }
21 22 seqüência pública Descrição
23 {
24 obter { return "endpoint de teste"; }
25 }
26 27 manipulador IHttpHandler público
28 {
29 obter { retorna o novo TestHandler{Caminho = caminho, ProtocolId = _protocolId}; }
30 }
31 32 públicas string Nome
33 {
34 obter { return "testendpoint"; }
35 }
36 }
37 }
o recurso mais importante do O TestEndpoint classe é que retorna uma
instância da classe TestHandler, que é mostrado abaixo.
TestHandler.cs
1 usando o System.Coleções.especializado;
2 usando o System.Web;
3 usando Safewhere.IdP.Aplicação;
4 usando Safewhere.IdP.application.HttpHandlers;
5 6 namespace Safewhere.IdP.Protocolos.TestProtocol.application.Handlers
7 {
8 public class TestHandler : IdPHttpHandlerBase
9 {
NameValueCollection 10 particulares _requestParams;
11 12 público override bool(NameValueCollection ValidateRequest requestParams)




131
13 {
14 _requestParams = requestParams;
15 return true;
16 }
17 18 cancelamento público bool RequiresAuthentication()
19 {
20 return true;
21 }
22 23 cancelamento público bool ForceReauthentication()
24 {
25 retornar FALSE;
26 }
27 28 cancelamento público void SendResponse(HttpContext contexto)
29 {
30 string username = IdPContext.Current.UserName
string connectionName; 31 = _requestParams["conexão"];
32 contexto.Response.Write(" <html><head>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8" />
<title>Créditos para o usuário: ");
33 contexto.Response.Write.username + " </title></head><body>");
34 contexto.Response.Write(" <h1>" + username + " </h1>");
35 36 var créditos = ClaimMappingService.GetMappedClaimsForUser(username, ProtocolId , connectionName);
37 claimStr string = " <claims>\n";
38 foreach(var reclamação de créditos)
39 {
40 contexto.Response.Write("<b>" + alegação.DisplayName + " </b><br/>");
41 contexto.Response.Write("Nome: " + alegação.Nome + " <br/>");
42 contexto.Response.Write("Valor: " + alegação.value + " <br/>");
43 contexto.Response.Write("O NameFormat: " + pedido.O NameFormat + " <br/>");
44 contexto.Response.Write("ValueType: " + alegação.ValueType + " <br/><br/>");
45 claimStr += " <claim>\n";
46 claimStr += " <name>" + alegação.Nome + " </name>\n";
47 claimStr += " <value>" + alegação.value + " </value>\n";
48 claimStr += " <nameformat>" + pedido.O NameFormat + " </nameformat>\n";
49 claimStr += " <valuetype>" + alegação.ValueType + " </valuetype>\n";
50 claimStr += " </claim>\n";
51 }
52 claimStr += " </claims>\n";
53 contexto.Response.Write(" <form><textarea cols=100 rows=50>" + claimStr);
54 55 contexto.Response.Write(" </textarea></form>");
56 contexto.Response.Write(" </body></html>");
57 }
58 }
59 }
você pode ver que este manipulador participa da seqüência de solicitação de execução de
definí-na seção 4.11 na página 79. Ele faz isso por razões imperiosas theValidateRequest,
RequiresAuthentication, ForceReauthentication e SendResponse meth-
ods de sua classe pai. Uma vez que o método RequiresAuthentication re-
voltas verdadeiro, o núcleo do IdP torna a certeza de que o usuário é autenticado antes de





chamar o método SendResponse 132. Por conseguinte, este método pode fazer uso de
IdPContext.Current.UserName e chamar o ClaimMappingService para obter os
créditos do usuário, que então apenas saídas como html.




Capítulo
8

validação do projeto
o objetivo deste capítulo é avaliar o projeto que apresentei esta tese, e não menos, para avaliar a viabilidade do projeto orientado por domínio. Antes de olhar para o que foi aprendido, desejo apresentar o pano de
fundo para a introdução de um novo paradigma de projeto em Safewhere.
Safewhere é uma empresa relativamente nova com apenas três anos de existência.
Como com muitas pequenas empresas, Safewhere começou com uma boa ideia e uma pro- totype escritos pelos fundadores. No início da vida da empresa dinheiro foi escasso, e a fim de atrair capital de risco tendo em um produto real para mostrar foi a prioridade número um. Assim, dadas as circunstâncias, não há muito tempo foi despendido no design de software e modelagem. Em vez disso, alguns programas- mers foram contratados, eu próprio incluído, e cada programador foi dada a poucos recursos de alto nível para implementar. como ele transformaram no entanto, cada programador tinha o seu próprio estilo de codificação individual e compreensão no domínio comercial.


No início, esta não parecem causar que o big de um problema e a versão do produto foi entregue e totalmente funcional. Após o lançamento inicial a necessidade de novos recursos cresceu rapidamente, e estes foram adicionados em uma base ad hoc. O produto estava funcionando bem, mas se tornou cada vez mais di cult para adicionar novos recursos e funcionalidades existentes, como refatorar o código base cresceu. Apesar de codificação estabelecidas orientações, teste extensivo suites e uma cultura de comunicação geralmente aberto, havia algo faltando no nosso método de desenvolvimento. Uma das maneiras de como isso se manifesta em si foi que tínhamos várias classes na di entravarão um conjuntos com nomes semelhantes mas com significado desiguais. Foi também di cult para explicar a arquitectura para novos membros da equipa, dado que o código não foi organizado de forma heterogênea.
Em retrospecto, o problema foi claramente que não têm um modelo (quadro e modelo) nem um idioma onipresente. Um dia, a maioria dos desenvolvedores de Safewhere participou num seminário onde estávamos rst introduzido para projeto orientado ao domínio. Embora o design orientado por domínio não era o principal tema do seminário que todos nós fomos deixados com a impressão de que ele foi um inteligente coisa a fazer. Por isso decidimos experimentar design orientado por domínio na prática. Desde que eu estava prestes a escrever a minha tese foi decidido que o meu projeto atual poderia ser um projeto de cobaias para a introdução de projeto orientado no domínio Safewhere. Mediante escrito esta tese, apresentei o meu trabalho a minha
133




134
colegas. A rst finalidade deste foi para lhes avaliar a usabilidade e integridade do modelo, e em segundo lugar para fazer deles me dar o seu parecer do projeto orientado por domínio e se iriam apoiar a intro- dução de projeto orientado de domínio como um padrão de design em futuros projectos no
12 Safewhere. I entrevistados três pessoas, e abaixo é o que eu achei.
8.1. Avaliação do modelo
com base nas entrevistas, posso concluir que a seguir é verdadeira sobre o
modelo:
resolve o problema de negócio bem.
Ele representa uma forma concisa e expressiva onipresente linguagem
que facilita a falar.
É provisionamento flexível e tem uma clara repartição de responsabilidades
entre os órgãos, tornando fácil refatorar.
Ele irá conduzir a um estável e maduro do produto final.
Ele irá reduzir o custo total de propriedade do software.
De modo geral o meu trabalho tem sido muito bem recebido, e não há dúvida de que o design orientado por domínio será o futuro design paradigma em Safewhere. Dito isto, houve também um número de menos coisas positivas, que eu endereço
abaixo.
Primeiro de tudo o que foi observado que alguns termos poderiam ter tido melhor nomes.
13 Estas incluem o di entravarão um tipos de reclamações ; CredentialClaim
IssuedClaim IdentityProviderClaim,e. A distinção entre os três tipos de reclamações é mais
importante do que os seus nomes, e embora os nomes podem não ser os mais elegantes, eles não transmitem informações importantes. Um outro conceito que poderia
ter sido chamado de melhor é o conceito de registro. A palavra é o registo mais-
carregados e tem potencialmente di entravarão um significados a di entravarão um povo. Um nome melhor para este modelo conceito poderia ter sido a monitorização de actividades de negócio que é tanto mais expressiva e inequívoca. Como para o modelo de rastreamento - conceito, deve provavelmente não teria sido feito parte do modelo uma vez que se trata de um conceito de infra-estrutura e não tem relevância para o problema de negócio.
12 As entrevistas podem ser encontrados no comprimento total no apêndice B.
13 Apenas um entrevistado embora que esses nomes poderiam ter sido melhor. Outro inter-
viewee, Pedro, descobriu que eles realmente bom.




135
Se tudo o que poderia ter sido parte do componente de domínio neutro, mas
não é claro se ele mesmo pertence aqui.
Foi igualmente salientado que existe um uso excessivo de fábricas no modelo. Há no entanto uma boa razão para que o uso de um lote de fábricas é uma boa convenção para este modelo. As fábricas são usados principalmente para construir objetos de entidade. O problema é que o quadro LinqToSql gera o parâmetro-menos construtores. É claro que é ainda possível adicionar mais con- structors com mais parâmetros. No entanto se construtores em vez de fábricas foram utilizados ao longo do código, que poderia potencialmente conduzir outros desenvolvedores para a impressão de que o parâmetro-menos construtores também são uma opção que não o são. Isso utilizando fábricas para criar objetos de entidade em todo o código que eu criei uma convenção que outros podem seguir, e esperamos evitar a utilização acidental do parâmetro-menos construtores. Infelizmente esta convenção é implícito e eu não tenho sido capaz de chegar a uma forma de o exprimir explicitamente no modelo. Este é um ponto fraco na nitely modelo,
e espero que a melhor solução pode ser encontrada no futuro.
Outra fraqueza do modelo tem a ver com o plug-in da natureza do sistema. Refatoração do sistema plug-in, principalmente as interfaces, poderia levar a quebrar a compatibilidade com plug-ins de terceiros. Eu não acho que essa é uma aw no modelo per se, mas sim uma consequência natural de qualquer arquitetura de plug-in. Não há planos para permitir que terceiros plug-ins no IdP, portanto, essa não é uma grande preocupação no momento, desde as alterações danosas para auto-desenvolvido plug-ins podem ser tratadas em tempo de compilação e durante o teste.




Capítulo
9
Conclusão
Este capítulo contém a minha conclusão sobre o que foi aprendido durante todo
o processo de escrita esta tese.
9.1. O modelo de
todos em todos os eu acho que o modelo que tem sido desenvolvido é boa e aprofundada e resolve o problema de negócio de ned na especi cação bem, facto que é comprovado pelo as entrevistas que foram realizadas. Agora, é o modelo perfeito? Não, não é. E o que é exatamente um dos pontos do domínio- projeto orientado. Você nunca vai fazer o seu modelo cem por cento para a direita o tempo rst, e é por isso que é tão importante que o modelo é provisionamento flexível de modo a que as futuras refactorings pode ser realizado com facilidade. Eu tenho conseguido esta exibilidade para um alto grau através da distribuição de responsabilidades e por ter feito o modelo de storage agnóstico. Também quando se trata da componente de domínio neutro ou modelo quadro, estou certo de que isso irá contribuir para encurtar o tempo de desenvolvimento em futuros projectos porque é
altamente reutilizáveis.
9.1.1 Perspectivas futuras de
software de hospedagem na nuvem é mais provável que vai se tornar muito com- mon no futuro. Serviços de hospedagem em nuvem estão sendo o desaconselhem por muitos dos grandes jogadores no mercado com produtos como o Google App Engine , Microsoft Azure , Amazônia Nuvem elástica e muito mais. O bene t desses serviços é que eles fornecem o Instant on-demand dimensionamento de aplicativos host. Seria natural para hospedar um produto como o IdP na nuvem para garantir que mesmo cargas extremamente altas sobre a aplicação poderia ser tratada. No entanto, os mecanismos de armazenamento utilizado nestes serviços em nuvem são muito diferentes para bancos de dados relacionais. Por conseguinte, o modelo vai enfrentar o seu
maior teste se em algum ponto é decidido para hospedar o IdP na nuvem.
136




137
9.2. Design orientado para o domínio
só posso dizer que este meu rst encontro com design orientado para o domínio, tem sido muito positiva. Design orientado por domínio é baseado em alguns muito prin- cípios de som que pode ser aplicado a qualquer tarefa de projeto de software que posso pensar.
Livros sobre design orientado por domínio muitas vezes usam exemplos de domínios de negócio que são normalmente entendida, tais como os sistemas de reserva de hotel, sistemas de ordem ou similares. No domínio comercial que foi modelado aqui é de natureza muito técnica e no início deste projecto Eu estava ansioso para nd se a princípios de design orientado por domínio poderia ser aplicado a este tipo de sistema como bem. Penso que é seguro concluir que ele pode. Apesar de não ter havido nenhuma separação nítida entre especialistas em domínio e desenvolvedores sobre este projecto, tendo uma ampla onipresente linguagem que é re eccionado no modelo e o código tornou o sistema de forma muito mais fácil falar e discutir. Além disso, muito tempo foi salvo pela capacidade de refatorar no modelo em vez de refatoração código que tomou um longo tempo para escrever. E usando o design orientado por domínio de conceitos tais como enti- dades, repositórios, serviços, especi cátions, etc torna o código muito mais
reconhecível para os novatos da equipe.
Usando o projeto orientado de domínio em um projeto que requer o compromisso de todos os desenvolvedores. Na fase de modelagem, os desenvolvedores envolvidos devem ter habilidades de modelagem de forte e uma compreensão profunda do design orientado por domínio. Na fase de desenvolvimento, quando o modelo já foi revestida, é ainda importante que cada desenvolvedor sobre a equipe tem o conhecimento sobre o domínio- projeto orientado de tal forma que todos os conceitos utilizados no modelo pode ser compreendida por todos. Eu não tive a oportunidade de experimentar o design orientado por domínio em maior escala desde esse projeto não envolvidos outros desenvolvedores do que eu.
Estou no entanto convencido de que os decretos de ts de domínio usando o projeto orientado será ainda maior quando trabalhando em grandes equipes. As maiores equipas, mais importante se torna ter uma
linguagem comum e uma forte onipresente e provisionamento flexível de modelo.
Design orientado por domínio de masterização é algo que não pode ser aprendido a partir de um único projecto, mas o meu trabalho com ele até agora tem de nitely me incentivou a continuar a utilizá-lo, e estou ansioso para se tornar ainda mais hábeis em aplicar os seus princípios. Para mim pessoalmente, sendo capaz de software design muito bem é uma meta que eu lutar para conseguir porque ele vai me dar maior satisfação profissional e pela prática do meu domínio de competências projeto orientado estou certo que




138
I será capaz de alcançar essa meta.




Capítulo
Apêndice A
elementos de linguagem C#
Este objectivo do presente anexo é fornecer uma breve introdução à linguagem C#, permitindo que os leitores sem o conhecimento prévio da linguagem C# para compreender as amostras de código em tese. O conteúdo aqui apresentados são baseados na linguagem C# especifi cação [Microsoft 2009], e não deve de modo algum ser considerada como completa. Consulte [Microsoft 2009] para a
referência completa.
A.1. Estrutura do programa
os principais conceitos organizacionais em C# são programas, os namespaces, tipos,
membros e conjuntos. C# programas consiste de um ou mais fonte les.
Programas declarar tipos, que contêm membros e podem ser organizados em namespaces. Classes e interfaces são exemplos de tipos. Campos, métodos, propriedades e eventos são exemplos de membros. Quando os programas são compilados C#, eles são fisicamente embalados em conjuntos. Conjuntos normalmente têm a extensão de le .exe ou .dll, consoante se trate de implementar
aplicativos ou bibliotecas.
A.2. Tipos de
programas de C# usar declarações do tipo para criar novos tipos. Uma declaração do tipo especi es o nome e os membros do novo tipo. Cinco dos C#'s categorias
de tipos de usuário: tipos de classe P ermitir, struct tipos, os tipos de interface, enum tipos e tipos de delegado.
Classe, struct, interface e delegar o apoio de todos os tipos genéricos, através do qual
eles podem ser parametrizados com outros tipos.
Existem dois tipos de tipos em C#: tipos de valor e tipos de referência.
Variáveis de tipos de valor conter diretamente seus dados considerando as variáveis de ref- erência tipos armazenar referências a seus dados, sendo este último conhecido como objetos.
139




140
Com tipos de referência, é possível que duas variáveis a referência ao mesmo objeto e assim possível para as operações em uma variável a um ect o objeto referenciado pela outra variável. Com tipos de valor, as variáveis que cada um tem a sua própria cópia dos dados e não é possível para as operações de um para
um outro ect
A.2.1 Classes
um tipo de classe de nes uma estrutura de dados que contém dados membros () e função euratomdoconselho membros (métodos, propriedades e outros). Suporte a tipos de classe única herança e polimorfismo, mecanismos com os quais classes derivadas
podem ampliar e especializar as classes base.
Membros
os membros de uma classe são membros ou membros da instância estática.
Os membros estáticos pertencem às classes e instância membros pertencem a objetos (instâncias de classes). A tabela a seguir fornece uma visão geral dos tipos
de membros de uma classe pode conter.
Descrição do membro constantes constante os valores associados com a
campos de classe variáveis de classe Métodos de cálculos e ações que podem ser executadas pela
classe
propriedades as ações associadas com a leitura e a escrita
denominado propriedades da classe
indexadores ações associadas com a indexação de instâncias da
classe como uma matriz
Eventos Notifi cações que podem ser gerados por operadores de classe conversões e expressão operadores suportados pelo

os construtores de classe de ações necessárias para inicializar instâncias da
classe ou a própria classe
Destructors acções a executar antes de instâncias da classe
são permanentemente descartadas
tipos tipos aninhados declarada pela classe




141
Acessibilidade que
cada membro de uma classe tem associado um acessibilidade, que controla as regiões de texto de programa que são Capaz de acessar o membro. Existem ve formas possíveis de acessibilidade. Estes estão resumidos na tabela a seguir.
Acessibilidade significa o
acesso público não limitado
acesso protegido limitados a esta classe ou classes derivadas de
esta classe de
acesso interno limitado a este programa
interno protegido acesso limitado a este programa ou classes
derivadas de esta classe de
acesso privado limitado a esta
herança de classes
uma classe herda os membros da sua directa tipo de classe de base. Herança significa que uma classe contém implicitamente todos os membros da sua directa tipo de classe de base, exceto para a instância construtores, destructors estático e construtores da
classe base.
Acesso à base de
uma base de acesso consiste na palavra reservada base, seguido por um "."
token e um identifi er ou uma lista de expressão entre parêntesis rectos:
base-acesso:
base .
base identificador de lista de expressão [ ]
uma base-access é utilizado para acessar os membros de classe de base que são ocultadas por simi- cularmente os membros nomeados na classe atual ou struct. Uma base de acesso é permitir- ted apenas no bloco de uma instância construtor, uma instância ou o método de uma
instância o acessor.




142
Este acesso
a este acesso consiste da palavra reservada.
este acesso:
este
um presente de acesso só é permitido no bloco de uma instância construtor, uma instância ou o método de uma instância o acessor. Dentro de uma instância construtor ou função de instância membro de uma classe, este é classificado ed como um valor. Assim, embora este pode ser usado para consultar a instância para a qual a função membro foi invocado, não é possível atribuir a este em função de um membro de uma classe.
Construtores
a esta(...) forma de inicializador de construtor é comumente usado em interpola Ño
com sobrecarga para implementar a instância do construtor parâmetros opcionais-
dores.
1 classe de Texto
2 {
3 Texto público(): este(0, 0, null) {}
4 Texto público(int x int y): este(x, y nulo) {}
5 públicos texto(int x int y, string s) {
6 // construtor real implementação
7 }
8 }
no exemplo acima, o rst dois construtores de instância fornecem apenas os valores padrão para a falta de argumentos. Ambos usam um presente(...) o inicializador de construtor para invocar a terceira instância construtor, que realmente faz o
trabalho de inicializar a nova instância.
Da mesma forma, um construtor pode invocar o construtor da sua classe base usando
base-acesso como ilustrado abaixo:
1 usando o sistema;
2 3 classe A
4 {
5 string theString protegido;
6 público um(string aString){
7 este.theString = aString;
8 }




143
9 }
10 11 classe B : UM
12 {
treze privadas int retiradonoint;
14 15 público B(string aString, int anInt) : base(aString) {
16 este.RETIRADONOINT = anInt;
17 }
18 19 public void PrintIt(){
20 Console.WriteLine("A string theString: " + + ". O int: " + RETIRADONOINT);
21 }
22 }
A.2.2 Structs
um struct tipo é semelhante a um tipo de classe na medida em que representa uma estrutura com membros de dados e função de membros. No entanto, diferentemente de classes, structs são tipos de valor e não exigem alocação de heap. Tipos Struct não suportam o utilizador-especi ed herança, e todos os tipos de struct implicitamente Herdar do tipo
objeto.
A.2.3 Interfaces
uma interface de nes um contrato que pode ser implementada por classes e structs. Uma interface pode conter métodos, propriedades, eventos e indexadores.
Um interfaces não fornecer implementações dos membros é de nes, apenas os membros que especi es devem ser fornecidos por classes ou structs que implemente a interface. Uma classe ou struct que implementa uma interface deve fornecer implementações da função da interface de membros. Uma- terface pode herdar a partir de múltiplas interfaces de base e uma classe ou struct pode
implementar várias interfaces.
A.2.4 Delegados
um delegado tipo representa as referências aos métodos com uma determinada lista de parâmetros e tipo de retorno. Os delegados tornam possível para o tratamento de métodos como entidades que podem ser atribuídos a variáveis e passados como parâmetros. Os delegados são semelhantes ao conceito de ponteiros de função encontrada em alguns outros idiomas,




144
mas ao contrário de ponteiros de função, delegados são orientadas a objeto e o tipo de seguro.
O exemplo a seguir declara e usa um tipo de função de delegado.
1 usando o sistema;
2 delegar função dupla(x);
3 duas vezes o multiplicador de classe
4 {
5 duplo fator
multiplicador público; 6(duplo fator) {
7 este factor.= factor;
8 }
9 duplo público multiplicar(x) duplo {
10 Retornar x factor ∗;
11 }
12 }
13 classe de Teste
14 {
15 Praça duplo estático(duplo x) {
;x 16 regresso x ∗∗∗∗
17 }
18 duplo estático[] aplicável(duplo[] uma função, f) {
19 duplo[] resultado = nova dupla[a.Length];
i &lt; a.Comprimento; i++) resultado[i] = f(A[i]); ;0 20 para (int i =
21 Resultado do retorno;
22 }
23 static void main() {
24 duplo[] a = {0.0, 0,5, 1.0};
25 duplo[] praças = aplicável(a, Square);
26 duplo[] sines = aplicável(a, Math.Sin);
Multiplicador 27 m = Multiplicador de novo(2,0);
28 duplos[] duplica = aplicável(a, m.Multiplique a);
29 }
30 }
Uma instância da função tipo de delegado pode fazer referência a qualquer método que
leva a um duplo argumento e retorna um valor duplo. O método Apply
aplica uma determinada função para os elementos de dupla via[], retornando um duplo[]
com os resultados. No método principal, Aplicar é usado para aplicar três di entravarão um
funções para um duplo[]. Um delegado pode fazer referência a um método estático
(como Quadrado ou Math.o pecado no exemplo anterior) ou uma instância método (como m.Multiplique no exemplo anterior). Um delegado que faz referência a um
método de instância também as referências de um determinado objeto e quando a instância método é invocado através do delegado, que objeto se torna presente na invocação. Os delegados também pode ser criado usando as funções anônimas, que são métodos de "inline" que são criados no y. Funções anônimas podem ver as variáveis locais em redor dos métodos. Assim, o multiplicador
exemplo acima pode ser escrito mais facilmente sem usar aMultiplier Classe:




145
1 duplo[] duplica = aplicável(a, (duplo x) =&gt; x ∗ 2.0);
um interessante e útil propriedade de um delegado é que ele não sabe ou cuidados sobre a classe do método referências; tudo o que interessa é que o método referenciado tem os mesmos parâmetros e tipo de retorno como delegado.
A.2.5 tipos de
uma declaração do tipo parcial pode ser dividido em várias declarações do tipo parcial. A declaração do tipo é construído a partir de suas peças seguindo as regras nesta seção, após o que é tratada como uma declaração única durante o resto
do tempo de compilação e runtime transformação do programa.
A.2.6 métodos de extensão
quando o parâmetro rst de um método inclui a este método modi er, que é dito ser um método de extensão. Métodos de extensão só pode ser declarada não genérico não aninhadas classes de estática. O parâmetro de um ramal rst
método pode ter nenhuma modi ers diferente deste, e o tipo de parâmetro
não pode ser um tipo de ponteiro. O seguinte é um exemplo de uma classe estática que
declara dois métodos de extensão:
1 extensões de classe estáticos públicos
2 {
3 int ToInt estáticos públicos32(s) esta string {
4 retornar Int32.Parse(s);
5 }
6 estáticos públicos T[] Slice <T>(Este T[] Fonte, int index, int count) {
7 se (índice &lt; 0 || contagem &lt; 0 || fonte.Length - índice &lt; contagem)
8 passos novo ArgumentException();
9 T[] resultado = nova contagem T[];
10 Array.Copiar(Fonte, Índice, resultado, 0, contagem);
11 Resultado do retorno;
12 }
13 }
Uma extensão é um método regular de método estático. Além disso, onde sua classe estática juntando está no escopo de um método de extensão pode ser invocado us- ing instância Method Invocation sintaxe, usando a expressão do receptor como argumento a RST. O programa a seguir usa a extensão métodos declarados
acima:




146
1 Programa de classe estática
2 {
3 static void main() {
;} 4 strings String[] = { "1", "22", "333", "4444"
5 foreach (string s em strings.fatia(1, 2)) {
6 Console.WriteLine(s.ToInt32());
7 }
8 }
9 }
TheSlice método está disponível em thestring[], e theToInt32 método está
disponível no string, porque eles têm sido declarados como métodos de extensão.
O significado do programa é o mesmo que o seguinte, usando
chamadas de método estático ordinária:
1 Programa de classe estática
2 {
3 static void main() {
;} 4 strings String[] = { "1", "22", "333", "4444"
5 foreach (string s em Extensions.fatia(strings, 1, 2)) {
6 Console.WriteLine(Extensions.ToInt32(s));
7 }
8 }
9 }




Capítulo
Apêndice B
entrevistas
B.1. Mikkel Christensen desenvolvedor no Safewhere
-me qual é a sua impressão geral do modelo?
Penso que o modelo dinamarquês Mikkel resolve os requisitos de negócios apresentado na
especi cação bem e em um provisionamento flexível de forma.
Depois de me ter lido esta tese, é óbvio para você como você poderia im-
estipulem um novo plug-in.
Mikkel Sim. Eu teria de implementar a interface theIPlugin. Ou melhor,
quer o ICredentialProviderPlugin ou IProtocolPlugin.
Me acha que o modelo é provisionamento flexível ou boa o suficiente para fazer refac-
dimento fácil.
Mikkel Bem, sim e não. Eu acho que a estrutura de plug-in apresenta alguns
problemas com compatibilidade retroativa, no que respeita à refatoração.
No entanto, reconheço que estas questões estarão sempre presentes em sistemas que usam uma estrutura de plug-in, e que não é um problema com o modelo per se. Como uma questão de facto o modelo provavelmente não tornam mais fácil, devido à forma como ele claramente distribui responsabilidades. Eu acho que ter um bem de ned modelo como este, você pode realmente executar um lote de refatoração sobre o próprio modelo, antes de começar a programação.
Me que está correto e que já tenho feito que muitas vezes.
Me acha que este sistema especi c bene ts de sendo modelada
usando o paradigma orientado por domínio?
Mikkel Sim. Penso que a DDD permite que o modelo a ser descrito em um curto
e conciso. Penso que a legibilidade deste modelo é melhor do que
muitos outros modelos padrão OO tenho visto no passado.
-me o que você pensa sobre design orientado por domínio de foco em um
idioma onipresente? Faz sentido?
Mikkel faz muito sentido. Eu acho que você evitar a desconexão entre
os programadores e os negócios. Ele faz com que os desenvolvedores a compreender a pertinência de todas as classes e eles não têm de gastar tempo para apresentar com boa nomes de classe. O que as torna mais produtivo, penso.
Você me parece um ventilador de design orientado para o domínio já. Você não acha
que há nada negativo sobre ele?
147




148
Mikkel bem, se eu tenho algo a dizer que seria que ela requer bastante
habilidosos programadores na fase de modelagem, para colmatar a lacuna entre
a empresa e o código. Mas para além de que, n°
Na fase de modelagem me apenas?
Mikkel Sim. Quando o sistema tiver sido modelada, penso que deveria
ser um pedaço de bolo para implementar, uma vez que todas as decisões já tenham sido efectuadas. Passado a fase de modelagem, os desenvolvedores ainda teria de estar familiarizado com design orientado por domínio, mas eles não têm a grande
business insight para implementar o modelo, penso.
Me, você gostaria de utilizar o design orientado por domínio sobre o seu próximo projecto?
Mikkel baseado no que li na sua tese, parece e pr esente directiva. Não posso
concluir que é a solução para tudo, mas estou pronto
para tentar nitely de que na prática.
B.2. Mark Seemann Desenvolvedora Sênior em Safewhere
-me qual é a sua impressão do modelo?
Marcar a minha impressão geral é que é bom. Penso que a distinção ser-
tween di entravarão um tipos de reclamação é bom, no entanto penso que os nomes poderiam
ter sido melhor.
Mim você tem uma sugestão melhor para os nomes?
Mark Hehe, não, realmente.
Me Ok, outra coisa?
Mark eu não gosto da designação de registro . Penso que é uma palavra
e que sobrecarregado não descrever o significado exacto. Penso que a monitorização de actividades de negócio , ou algo como o que teria sido melhor.
Me bom ponto. Concordo.
A marca também não estou certo de que o rastreamento efectivamente pertence ao domínio. No
meu entendimento é mais uma coisa de infra-estrutura.
Eu não gostaria de dizer que discordo. A única razão pela qual eu ter escolhido para fazer
parte do modelo de domínio é que quero expor serviços que permita a
inspeção de mensagens de rastreamento na interface de utilizador do administrador.
Marcar também, você tem algumas fábricas. Compreendo que o
padrão de fábrica é frequentemente útil, mas parece que neste modelo, tudo o que estas fábricas não podia ter apenas como bem foi feito em
funções de construtor.
Me um válido ponto. As fábricas são usados principalmente para construir objetos de entidade.
O problema é que o quadro LinqToSql gera o parâmetro-menos




149
construtores. É claro que é ainda possível adicionar mais construtores com mais parâmetros. No entanto se eu usado construtores em vez de fábricas em todo o código, que poderia potencialmente conduzir os outros para a impressão de que o parâmetro-menos construtores também são uma opção que não o são. Isso utilizando fábricas para criar objetos de entidade em todo o código, vou criar uma convenção que outros podem seguir, e esperamos evitar a
utilização acidental do parâmetro-menos construtores.
Marque Ok, que faz sentido. Que é uma boa convenção em seguida.
Me Sim, e reconheço que é um menor aw no modelo. Mas penso que
a produtividade extra fornecida pelo ou-mapper é que vale a pena fazer este
sacri ce para.
Me qual é a sua impressão geral do projeto orientado de domínio?
Mark I pensar que o design orientado por domínio é uma boa abordagem. O
modelo de domínio padrão foi efectivamente introduzido por Martin Fowler há muito tempo. No seu livro, foi apresentado em 10 de 15 páginas. No entanto Eu gosto da forma como de Eric Evans escreveu um livro inteiro sobre ele, porque ele
realmente é um padrão essencial que exige que tipo de atenção.
Me tão você acha que há algo de negativo a dizer sobre
design orientado por domínio?
Marcar bem e não realmente. Mas o uso do projeto orientado de domínio requer
habilidades de modelagem de forte. E maturidade. Tanto a maturidade técnica para a pro-
grammer, mas também uma organização madura.
Marca-me, você é grande o Advocate para teste de desenvolvimento (TDD).
Mesmo que você tenha o seu próprio blog sobre TDD (http://blog.ploeh.dk). Você
acha que um modelo como este se torna bem a TDD?
Mark bem, TDD é tudo sobre a resposta rápida. Você deseja escrever testes que
abrangem todo o sistema e executar esses testes mais uma vez para ter certeza de que você não está fazendo as alterações danosas. Para um sistema como o que pode ter modelado, não seria antinatural ter cerca de 1000 testes de unidade. Por conseguinte, estou preocupado com o acoplamento para o banco de dados relacional que você apresentou no seu modelo. Você ver por TDD ser e sòes você realmente tem para executar seus testes muitas vezes. E a execução de todos os testes de 1000, digamos, muitas vezes, exigem executar realmente rápido.
E aqui, o acesso ao banco de dados se torna realmente uma garrafa de gargalo. Se os testes não executar em poucos segundos, você apenas parar de funcionar, e tornam o
exercício parar TDD.
De mim bem, concordo que testes de unidade não deve confiar no acesso ao banco de dados. Por
conseguinte, o domínio neutro componente tem uma memória equivalente ao componente de acesso a dados. Este equivalente na memória foi feita





com o teste de unidade de 150 exatamente em mente.
Mark Oh, ok. Devo ter perdido. Nesse caso eu acho que o modelo
se torna bem a TDD.
B.3. Pedro Haastrup diretor técnico da Safewhere
me acha que o modelo abranja as especifi cação?
Pedro Haastrup penso que é geralmente cobre especi cação bem, mas
eu não acho que ele abrange o aspecto multi-tenancy.
Me que está correto. O modelo é multi-tenancy desconhecer, e toda a
questão de multi-locação é suposto ser tratadas no momento da instalação, utilizando esquemas de banco de dados separado, aplicativos da web separados no IIS e
contas de máquina separado para execução.
Me acha que modelo apresentado neste documento representa um bom onipresente
linguagem?
Pedro Haastrup Sim, penso que o modelo apresentou um lote de conceitos
explícito, tornando o modelo fácil de falar sobre a um nível muito detalhado.
Um dos outros entrevistados verificou que o pedido nomes poderiam ter
sido melhor. Você concorda com esta.
Pedro Haastrup não, de todo. Estou muito feliz com esses nomes e
pensar que transmitam informações importantes sobre o que represen-
enviada.
Me acha que usando o paradigma de projeto orientado por domínio e o
componente de domínio neutro aqui apresentada irá tornar o desenvolvimento mais rápido?
Pedro Haastrup penso que é positivo que um grande número de decisões sobre a
forma de estruturar o código já tenham sido efectuadas. Será mais fácil para manter o código e programadores será capaz de reconhecer os
conceitos utilizados a partir de projecto para projecto.
Me Qual o impacto que você acha que o uso do projeto orientado de domínio para este
projecto IdP terá sobre o custo total de propriedade para o produto?
Pedro Haastrup Embora a introdução de um novo paradigma de projeto, tais como o
design orientado por domínio, parece exigir mais tempo de preparação antes de codificação pode iniciar, estou certo de que este custo extra é composta por tempos de desenvolvimento mais rápido. Como uma questão de facto penso que é feita para já por altura da rst liberação e que tendo como um bom modelo tornará muito mais fácil e mais rápido para o desenvolvimento de futuros lançamentos.
Além disso, penso que usando domínio projeto orientado a forma como você tem
aqui, irá resultar em um muito mais estável e produto maduro.




Capítulo
Bibliografia
Referências
Daarbak, Torben. 2008. Hver tredje CRM SaaS løsning er baseret i 2012. Em
computerworld.dk/arte/49054.
Evans, Eric. 2004. Design orientado para o domínio. Editora Addison-Wesley.
Gamma, Erich, Helm, Richard Johnson, Ralph e Vlissides, João. 1995. Design Pat-
andorinhas-: Elementos de Software Orientado a Objetos reutilizáveis. Editora Addison-Wesley.
Prático, Alex. 2009. Design orientado para o domínio através dos olhos de Eric Evans em
sdtimes.com/content/article.aspx?ArticleID=33357..
Harding, Kim. 2008. Curso de Design http://www.kimharding.com. Domain-Driven.
McCarthy, Tim. 2008. .NET Domain-Driven Design com C#. Wiley Publishing Inc.
Microsoft. 2007. Execução de uma transação usando o escopo de transação implícita. http:
//msdn.microsoft.com/en-us/library/ms172152.aspx.
Microsoft. 2009. Linguagem C# Especi cação 3.0. Http://go.microsoft.com/fwlink/
?LinkId=64165.
OpenSAML. 2009. Site http://www.opensaml.org. OpenSAML.
151




